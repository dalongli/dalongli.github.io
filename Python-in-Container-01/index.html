<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<link rel="icon" href="/assets/images/logo.png">

<title>Python in Container Part One | Dalong's personal blog</title>

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Python in Container Part One | Dalong’s personal blog</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Python in Container Part One" />
<meta name="author" content="Dalong" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="在本教程中，您将学习如何创建描述简单 Python 容器的 Dockerfile 文件。 使用容器创建 Web 服务器、数据库构建、运行和验证 Django、Flask 并通用 Python 应用实现程序的功能. 最后还会学习调试在容器中运行的应用程序。" />
<meta property="og:description" content="在本教程中，您将学习如何创建描述简单 Python 容器的 Dockerfile 文件。 使用容器创建 Web 服务器、数据库构建、运行和验证 Django、Flask 并通用 Python 应用实现程序的功能. 最后还会学习调试在容器中运行的应用程序。" />
<link rel="canonical" href="http://localhost:4000/Python-in-Container-01/" />
<meta property="og:url" content="http://localhost:4000/Python-in-Container-01/" />
<meta property="og:site_name" content="Dalong’s personal blog" />
<meta property="og:image" content="http://localhost:4000/assets/images/container.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-26T00:00:00+08:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Python in Container Part One","dateModified":"2021-07-26T00:00:00+08:00","datePublished":"2021-07-26T00:00:00+08:00","description":"在本教程中，您将学习如何创建描述简单 Python 容器的 Dockerfile 文件。 使用容器创建 Web 服务器、数据库构建、运行和验证 Django、Flask 并通用 Python 应用实现程序的功能. 最后还会学习调试在容器中运行的应用程序。","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/images/logo.png"},"name":"Dalong"},"image":"http://localhost:4000/assets/images/container.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Python-in-Container-01/"},"url":"http://localhost:4000/Python-in-Container-01/","author":{"@type":"Person","name":"Dalong"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    
<link href="/assets/css/screen.css" rel="stylesheet">

<link href="/assets/css/main.css" rel="stylesheet">

<script src="/assets/js/jquery.min.js"></script>

</head>




<body class="layout-post">
	<!-- defer loading of font and font awesome -->
	<noscript id="deferred-styles">
		<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
        <link rel="preconnect" href="https://fonts.googleapis.com"> 
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
        <link href="https://fonts.googleapis.com/css2?family=Carter+One&display=swap" rel="stylesheet">
    </noscript>


<!-- Begin Menu Navigation
================================================== -->
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">

    <div class="container pr-0">

    <!-- Begin Logo -->
    <a class="navbar-brand" href="/">
    <img src="/assets/images/logo.png" alt="Dalong's personal blog">
    </a>
    <!-- End Logo -->

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarMediumish">

        <!-- Begin Menu -->

            <ul class="navbar-nav ml-auto">

                
                <li class="nav-item">
                
                <a class="nav-link" href="/index.html">Blog</a>
                </li>

                <li class="nav-item">
                <a class="nav-link" href="/about">About</a>
                </li>

<!-- 以后再加上相关链接

                <li class="nav-item">
                <a target="_blank" class="nav-link" href="https://bootstrapstarter.com/bootstrap-templates/template-mediumish-bootstrap-jekyll/"> Docs</a>
                </li>

                <li class="nav-item">
                <a target="_blank" class="nav-link" href="https://www.wowthemes.net/themes/mediumish-wordpress/"><i class="fab fa-wordpress-simple"></i> WP Version</a>
                </li>

                <li class="nav-item">
                <a target="_blank" class="nav-link" href="https://www.wowthemes.net/themes/mediumish-ghost/"><i class="fab fa-snapchat-ghost"></i> Ghost Version</a>
                </li>
-->
                <li class="nav-item">
                <a target="_blank" class="nav-link" href="https://github.com/dalongli"><i class="fab fa-github"></i> Fork on Github</a>
                </li>

                <script src="/assets/js/lunr.js"></script>


<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>


<form class="bd-search" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
    <input type="text" class="form-control text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Type and enter..."/>
</form>

<div id="lunrsearchresults">
    <ul></ul>
</div>

<script src="/assets/js/lunrsearchengine.js"></script>

            </ul>

        <!-- End Menu -->

    </div>

    </div>
</nav>
<!-- End Navigation
================================================== -->

<div class="site-content">

<div class="container">

<!-- Site Title
================================================== -->
<div class="mainheading">
    <h1 class="sitetitle">Dalong's personal blog</h1>
    <p class="lead">
        Record the bits and pieces of the technology big bang.
    </p>
</div>

<!-- Content
================================================== -->
<div class="main-content">
    <!-- Begin Article
================================================== -->
<div class="container">
    <div class="row">

        <!-- Post Share -->
        <div class="col-md-2 pl-0">
            <div class="share sticky-top sticky-top-offset">
    <p>
        Share
    </p>
    <ul>
        <li class="ml-1 mr-1">
            <a target="_blank" href="https://twitter.com/intent/tweet?text=Python in Container Part One&url=http://localhost:4000/Python-in-Container-01/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                <i class="fab fa-twitter"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://facebook.com/sharer.php?u=http://localhost:4000/Python-in-Container-01/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=435');return false;">
                <i class="fab fa-facebook-f"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/Python-in-Container-01/" onclick="window.open(this.href, 'width=550,height=435');return false;">
                <i class="fab fa-linkedin-in"></i>
            </a>
        </li>

    </ul>
    
    <div class="sep">
    </div>
    <ul>
        <li>
        <a class="small smoothscroll" href="#disqus_thread"></a>
        </li>
    </ul>
    
</div>

        </div>

        <!-- Post -->
        

        <div class="col-md-9 flex-first flex-md-unordered">
            <div class="mainheading">

                <!-- Author Box -->
                
                <div class="row post-top-meta">
                    <div class="col-xs-12 col-md-3 col-lg-2 text-center text-md-left mb-4 mb-md-0">
                        
                        <img class="author-thumb" src="/assets/images/avatar_dl.png" alt="Dalong">
                        
                    </div>
                    <div class="col-xs-12 col-md-9 col-lg-10 text-center text-md-left">
                        <a target="_blank" class="link-dark" href="https://dalongli.github.io/about">Dalong</a><a target="_blank" href="https://dalongli.github.io." class="btn follow">Follow</a>
                        <span class="author-description">A profesional technical consultant and blogger.</span>
                    </div>
                </div>
                

                <!-- Post Title -->
                <h1 class="posttitle">Python in Container Part One</h1>

            </div>

            <!-- Adsense if enabled from _config.yml (change your pub id and slot) -->
            
            <!-- End Adsense -->

            <!-- Post Featured Image -->
            

            
            <img class="featured-image img-fluid" src="/assets/images/container.jpg" alt="Python in Container Part One">
            

            
            <!-- End Featured Image -->

            <!-- Post Content -->
            <div class="article-post">
                <!-- Toc if any -->
                
                    
                    <div class="toc mt-4 mb-4 lead">
                        <h3 class="font-weight-bold">Summary</h3>
                        <ul>
  <li><a href="#python-in-container-01">Python in Container 01</a>
    <ul>
      <li><a href="#容器的生态">容器的生态</a></li>
      <li><a href="#尝试在-docker-中-运行-python">尝试在 Docker 中 运行 Python</a>
        <ul>
          <li><a href="#从-git-hub-上获取代码">从 Git Hub 上获取代码</a></li>
          <li><a href="#创建docker镜像-并运行docker镜像">创建Docker镜像, 并运行Docker镜像</a></li>
          <li><a href="#将docker-镜像上传到-docker-hub-上">将Docker 镜像上传到 Docker Hub 上</a></li>
        </ul>
      </li>
      <li><a href="#docker-deep-dive">Docker Deep Dive</a>
        <ul>
          <li><a href="#play-with-docker">Play with Docker</a></li>
          <li><a href="#docker-进行虚机管理---docker-machine">Docker 进行虚机管理 - docker-machine</a></li>
          <li><a href="#docker-命令行">Docker 命令行</a></li>
          <li><a href="#查看版本和帮助">查看版本和帮助</a></li>
          <li><a href="#docker-version">docker version</a></li>
          <li><a href="#docker-命令缩写">Docker 命令缩写</a></li>
          <li><a href="#一步一步创建和运行一个能运行-python-的容器镜像">一步一步，创建和运行一个能运行 Python 的容器镜像</a></li>
          <li><a href="#从-docker-hub-上拉一个-python-最新版本的镜像">从 docker hub 上拉一个 python 最新版本的镜像</a></li>
          <li><a href="#创建一个新的-python-容器">创建一个新的 python 容器</a></li>
          <li><a href="#启动-python-容器">启动 python 容器</a></li>
          <li><a href="#删除-python-容器-删除镜像">删除 Python 容器， 删除镜像</a></li>
          <li><a href="#在本地系统中和容器交互">在本地系统中和容器交互</a></li>
          <li><a href="#文件拷贝-docker-cp">文件拷贝 docker cp</a></li>
          <li><a href="#docker-和主机目录共享---docker-bind-mount">docker 和主机目录共享 - Docker Bind Mount</a></li>
          <li><a href="#本地和容器进行端口映射">本地和容器进行端口映射</a></li>
          <li><a href="#玩转-container-image">玩转 Container Image</a></li>
          <li><a href="#container-image-包含两部分内容">Container Image 包含两部分内容</a></li>
          <li><a href="#查看-image-内容的命令">查看 image 内容的命令</a></li>
          <li><a href="#image-启动的时候需要-entrypoint-和-cmd">image 启动的时候需要 entrypoint 和 cmd</a></li>
          <li><a href="#dockert-image-id">Dockert image ID</a></li>
          <li><a href="#image-镜像的清理">image 镜像的清理</a></li>
          <li><a href="#管理容器">管理容器</a></li>
          <li><a href="#交互模式和非交互模式">交互模式和非交互模式</a></li>
          <li><a href="#查看容器日志-logs">查看容器日志 logs</a></li>
          <li><a href="#贴附模式--attach">贴附模式  attach</a></li>
          <li><a href="#在容器中执行命令-exec">在容器中执行命令 exec</a></li>
          <li><a href="#控制容器的资源">控制容器的资源</a></li>
          <li><a href="#运行多个容器">运行多个容器</a></li>
          <li><a href="#在容器中设置-hosts">在容器中设置 hosts</a></li>
          <li><a href="#创建一个容器网络-network">创建一个容器网络 network</a></li>
          <li><a href="#创建一个-posgres-数据库">创建一个 posgres 数据库</a></li>
          <li><a href="#容器网络-networking">容器网络 Networking</a></li>
          <li><a href="#创建一个没有网络的容器---none">创建一个没有网络的容器 - none</a></li>
          <li><a href="#创建一个链接到-主机的容器---bridge">创建一个链接到 主机的容器 - bridge</a></li>
          <li><a href="#删除网络">删除网络</a></li>
          <li><a href="#创建指定网段的容器">创建指定网段的容器</a></li>
          <li><a href="#创建内网">创建内网</a></li>
          <li><a href="#数据永久存储---volumes">数据永久存储 - volumes</a></li>
          <li><a href="#创建永久存储">创建永久存储</a></li>
          <li><a href="#删除-volume">删除 volume</a></li>
          <li><a href="#dockerfile">Dockerfile</a></li>
          <li><a href="#了解-dockerfile">了解 Dockerfile</a></li>
          <li><a href="#spdockerfile-语法">spDockerfile 语法</a></li>
          <li><a href="#docker-hub-介绍">Docker Hub 介绍</a></li>
          <li><a href="#docker-guis---portainer">Docker GUIs - Portainer</a></li>
          <li><a href="#docker-machine">Docker Machine</a></li>
          <li><a href="#docker-machine-with-virtualbox">Docker Machine with VirtualBox</a></li>
          <li><a href="#docker-machine-with-hyper-v">Docker Machine with Hyper-V</a></li>
          <li><a href="#docker-machine-on-aws-cloud-hosts">Docker Machine on AWS Cloud Hosts</a></li>
          <li><a href="#docker-machine-on-google-cloud">Docker Machine on Google Cloud</a></li>
        </ul>
      </li>
      <li><a href="#build-conrainer-images">Build Conrainer Images</a>
        <ul>
          <li><a href="#python-容器化项目的元素">Python 容器化项目的元素</a></li>
          <li><a href="#容器化-python-项目的生命周期">容器化 Python 项目的生命周期</a></li>
          <li><a href="#容器化应用的设计原则">容器化应用的设计原则</a></li>
          <li><a href="#手动流程-image-build-process">手动流程 Image Build Process</a>
            <ul>
              <li><a href="#第一步写代码并在容器中进行测试">第一步：写代码，并在容器中进行测试</a></li>
              <li><a href="#第二步-为修改的容器创建镜像---docker-commit">第二步： 为修改的容器创建镜像 - docker commit</a></li>
              <li><a href="#第三部-让镜像创造出来的容器可以直接运行-flask">第三部： 让镜像创造出来的容器可以直接运行 flask</a></li>
            </ul>
          </li>
          <li><a href="#通过-dockerfile-进行镜像自动创建---docker-build">通过 Dockerfile 进行镜像自动创建 - docker build</a>
            <ul>
              <li><a href="#要手动准备的三个文件">要手动准备的三个文件</a></li>
              <li><a href="#要准备的dockerfile">要准备的Dockerfile</a></li>
              <li><a href="#创建镜像docker-build-并运行">创建镜像docker build 并运行</a></li>
              <li><a href="#为-dockerfile-创建环境变量">为 dockerfile 创建环境变量</a></li>
              <li><a href="#dockerfile-procedure">Dockerfile Procedure</a></li>
            </ul>
          </li>
          <li><a href="#dockerfile-命令---from">Dockerfile 命令 - FROM</a>
            <ul>
              <li><a href="#一些-from-的例子">一些 FROM 的例子</a></li>
              <li><a href="#创建一个dockerfile---dockerfilepython374">创建一个Dockerfile - Dockerfile.python.3.7.4</a></li>
              <li><a href="#多个-from-的例子---dockerfilefrom3">多个 FROM 的例子 - Dockerfile.from.3</a></li>
            </ul>
          </li>
          <li><a href="#dockerfile-命令---workdir-copy-add">Dockerfile 命令 - WORKDIR, COPY, ADD</a>
            <ul>
              <li><a href="#workdir-定义了容器的工作目录">WORKDIR 定义了容器的工作目录</a></li>
              <li><a href="#dockerignore-文件">.dockerignore 文件</a></li>
              <li><a href="#copy-的例子">COPY 的例子</a></li>
              <li><a href="#add">ADD</a></li>
            </ul>
          </li>
          <li><a href="#dockerfile-命令---run">Dockerfile 命令 - RUN</a>
            <ul>
              <li><a href="#例子--写入追加文件--dockerfileredirect">例子- 写入，追加文件:  Dockerfile.redirect</a></li>
              <li><a href="#例子-管道符命令-dockerfilepipe">例子-管道符命令: Dockerfile.pipe</a></li>
              <li><a href="#例子---把默认-bash-命令改为-python-命令行--dockerfileshell">例子 - 把默认 bash 命令改为 python 命令行  Dockerfile.shell</a></li>
              <li><a href="#例子---下载安装软件">例子 - 下载，安装软件</a></li>
            </ul>
          </li>
          <li><a href="#镜像的层---image-layers">镜像的层 - Image Layers</a></li>
          <li><a href="#dockerfile-命令---env-label-user">Dockerfile 命令 - ENV, LABEL, USER</a>
            <ul>
              <li><a href="#env">ENV</a></li>
              <li><a href="#user">USER</a></li>
              <li><a href="#label">LABEL</a></li>
            </ul>
          </li>
          <li><a href="#dockerfile-命令---volume-and-expose">Dockerfile 命令 - VOLUME and EXPOSE</a>
            <ul>
              <li><a href="#语法">语法</a></li>
              <li><a href="#例子-dockerfilevol">例子-Dockerfile.vol</a></li>
              <li><a href="#不用--v-的情况">不用 -v 的情况</a></li>
              <li><a href="#开发本机目录-mount-到-容器">开发本机目录 mount 到 容器</a></li>
              <li><a href="#expose">EXPOSE</a></li>
            </ul>
          </li>
          <li><a href="#docker-命令---entrypoint-和-cmd">Docker 命令 - ENTRYPOINT 和 CMD</a>
            <ul>
              <li><a href="#entrypoint-和-cmd-是容器启动后要执行的命令">ENTRYPOINT 和 CMD 是容器启动后要执行的命令</a></li>
              <li><a href="#例子-dockerfilesimple">例子: Dockerfile.simple</a></li>
              <li><a href="#例子---dockerfileentry">例子 - Dockerfile.entry</a></li>
              <li><a href="#例子---dockerfileparent">例子 - Dockerfile.parent</a></li>
              <li><a href="#docker-run-可以通过参数复写-entrypoint">docker run 可以通过参数复写 entrypoint</a></li>
            </ul>
          </li>
          <li><a href="#dockerfile-的-arg-参数">Dockerfile 的 ARG 参数</a>
            <ul>
              <li><a href="#用环境变量来控制-args">用环境变量来控制 args</a></li>
              <li><a href="#用-args-为-label-打标签">用 ARGS 为 LABEL 打标签</a></li>
            </ul>
          </li>
          <li><a href="#创建可重用的python镜像">创建可重用的python镜像</a>
            <ul>
              <li><a href="#用-defaultini-来运行-python-命令">用 default.ini 来运行 python 命令</a></li>
            </ul>
          </li>
          <li><a href="#镜像创建-build-time-与-run-time">镜像创建 Build time 与 Run time</a>
            <ul>
              <li><a href="#创建镜像---runtime">创建镜像 - runtime</a></li>
              <li><a href="#创建镜像---buildtime">创建镜像 - buildtime</a></li>
              <li><a href="#一个极端的例子">一个极端的例子</a></li>
            </ul>
          </li>
          <li><a href="#build-更小的镜像">Build 更小的镜像</a>
            <ul>
              <li><a href="#基于标准python-镜像-的-image-创建">基于标准Python 镜像 的 image 创建</a></li>
              <li><a href="#基于-python-slim-版本的镜像创建">基于 Python Slim 版本的镜像创建</a></li>
              <li><a href="#基于-python-alpione-的-python-镜像">基于 python alpione 的 python 镜像</a></li>
            </ul>
          </li>
          <li><a href="#image-build-的多个阶段">Image build 的多个阶段</a>
            <ul>
              <li><a href="#用-factorpy-来计算">用 factor.py 来计算</a></li>
              <li><a href="#改成-factorpyx-计算">改成 factor.pyx 计算</a></li>
              <li><a href="#用-multi-stage-方法创建镜像-镜像小速度快">用 multi stage 方法创建镜像, 镜像小，速度快</a></li>
            </ul>
          </li>
          <li><a href="#定制自己的-python-镜像">定制自己的 python 镜像</a></li>
          <li><a href="#build-base-image-from-scratch-从头做一个基础镜像">Build base image from scratch 从头做一个基础镜像</a>
            <ul>
              <li><a href="#dockerfiletestscratch-的例子">Dockerfile.testscratch 的例子</a></li>
              <li><a href="#用-debootstrap-创建一个全新的镜像">用 debootstrap 创建一个全新的镜像</a></li>
              <li><a href="#创建基础镜像所需的-tar-包-然后将包导入到-docker-镜像中">创建基础镜像所需的 tar 包， 然后将包导入到 docker 镜像中</a></li>
              <li><a href="#还可以用-dockerfile-把-targz-做成镜像">还可以用 Dockerfile 把 tar.gz 做成镜像</a></li>
              <li><a href="#构建一个生产的镜像">构建一个生产的镜像</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
                    </div>
                
                <!-- End Toc -->
                <p>在本教程中，您将学习如何创建描述简单 Python 容器的 Dockerfile 文件。 使用容器创建 Web 服务器、数据库构建、运行和验证 Django、Flask 并通用 Python 应用实现程序的功能. 最后还会学习调试在容器中运行的应用程序。</p>

<h1 id="python-in-container-01">Python in Container 01</h1>

<p>[TOC]</p>

<h2 id="容器的生态">容器的生态</h2>

<p><a href="https://landscape.cncf.io/?category=certified-kubernetes-distribution%2Ccertified-kubernetes-hosted%2Ccertified-kubernetes-installer&amp;grouping=category">CNCF</a> 可以看到整个生态图</p>

<p>运行时</p>

<ul>
  <li>Docker Engine</li>
  <li>containered</li>
  <li>rkt</li>
  <li>CRI-O</li>
  <li>Podman</li>
</ul>

<p>容器管理</p>

<ul>
  <li>Docker</li>
  <li>Rancher</li>
  <li>Amazon Elastic Container Service</li>
</ul>

<p>Registries  镜像</p>

<ul>
  <li>Docker Hub &amp; Registry &amp; Trusted Registry</li>
  <li>GitLab</li>
  <li>Amazon Elastic Container Registry</li>
</ul>

<p>Orchestration 编排</p>

<ul>
  <li>K8s</li>
  <li>Swarm</li>
  <li>OpenShift</li>
  <li>Mesos DC/OS</li>
  <li>Google Kubernetes Engine</li>
</ul>

<p>Monitoring 监控</p>

<ul>
  <li>Prometheus</li>
  <li>cAdvisor</li>
  <li>DataDog</li>
  <li>Elastic</li>
</ul>

<h2 id="尝试在-docker-中-运行-python">尝试在 Docker 中 运行 Python</h2>

<h3 id="从-git-hub-上获取代码">从 Git Hub 上获取代码</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="c"># 获取简单的代码, 包括 Python 的 flask 文件， docker file 和 requirements.txt</span>
git clone https://github.com/dalongli/simple-flask
<span class="nb">cd </span>simple-flask   

</pre></td></tr></tbody></table>
</div>
</div>

<p>用到的三个文件</p>

<ul>
  <li>Dockerfile</li>
</ul>

<pre><code class="language-dockerfile">FROM python:3
# 用最新的 Python3 版本
WORKDIR /usr/src/app
# 指定安容器的工作目录
COPY requirements.txt .
# 拷贝当前目录的文件到容器目录
RUN pip install -r requirements.txt
# 安装python依赖包
COPY hello.py .
# 拷贝 python 运行文件
EXPOSE 5000
# 暴露容器的端口号
CMD python hello.py
# 运行 python 
</code></pre>

<ul>
  <li>requirements.txt</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>Flask
# 依赖包安装 Flask
</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>Python 文件</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">'Flask Hello world! Version 1'</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/test'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">'Testing hidden functionality ;)'</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">host</span><span class="o">=</span><span class="s">'0.0.0.0'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="创建docker镜像-并运行docker镜像">创建Docker镜像, 并运行Docker镜像</h3>

<ul>
  <li>37016175 是我的 Docker Hub 账号</li>
  <li>simple-flask 是 repostory 的名字</li>
  <li>v1.0 是tag 名称</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre><span class="c"># 创建 Docker 本地镜像, 当前目录(.)中应该有一个 Dockerfile </span>
docker build -t 37016175/simple-flask:v1.0 .
<span class="c"># -t 镜像名字带上 tag</span>
docker run --rm -it -p 5001:5000 --name my-simple-python 37016175/simple-flask:v1.0
<span class="c"># 在 Docker 镜像上运行一个临时容器</span>
<span class="c"># --rm 当推出容器就删除这个容器</span>
<span class="c"># -i, --interactive                    Keep STDIN open even if not attached</span>
<span class="c"># -t, --tty                            Allocate a pseudo-TTY</span>
<span class="c"># -p, --publish list                   Publish a container's port(s) to the host</span>
docker container ps --all
</pre></td></tr></tbody></table>
</div>
</div>

<p>访问 http://localhost:5001 可以看到 <strong>Flask Hello world! Version 1</strong></p>

<h3 id="将docker-镜像上传到-docker-hub-上">将Docker 镜像上传到 Docker Hub 上</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>docker push 37016175/simple-flask:v1.0
</pre></td></tr></tbody></table>
</div>
</div>

<blockquote>
  <p>push 结束后就可以在 https://hub.docker.com/repositories 上看到新的 simple-flask 仓库了</p>
</blockquote>

<h2 id="docker-deep-dive">Docker Deep Dive</h2>

<h3 id="play-with-docker">Play with Docker</h3>

<ul>
  <li>访问https://labs.play-with-docker.com 可以有一个沙箱环境让我们尝试 Docker</li>
  <li>每一次只能玩 4 个小时，并且有 CPU 和存储的限制</li>
  <li>可以创建多个 Docker Nodes</li>
  <li>Sign in 后点击 start ， 点击 add new instance</li>
  <li>然后复制 ssh 的命令行登录到 服务器并运行如下命令</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre>apk add figlet
figlet python
git clone https://github.com/dalongli/simple-flask
<span class="nb">cd </span>simple-flask
vim hello.py <span class="c"># 有的时候这里的代码会被修改掉， 注意调整正确</span>
docker build -t 37016175/simple-flask:v1.0.5 .
<span class="c"># 运行 Docker 镜像</span>
docker run --rm -it -p 5000:5000 37016175/simple-flask:v1.0.5
</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>点击 console 中的 5000 端口链接就可以访问 web hello.py 页面了</li>
  <li>记住这个地址，从互联网哪里都可以访问</li>
</ul>

<h3 id="docker-进行虚机管理---docker-machine">Docker 进行虚机管理 - docker-machine</h3>

<ul>
  <li>安装 VirtualBox 之后</li>
  <li>运行如下命令进行测试</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>brew install docker-machine
docker-machine create docker4kris
docker-machine rm docker4kris
</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>docker-machine命令</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></td><td class="code"><pre>
docker-machine active
<span class="c">#显示当前的活动主机</span>
docker-machine config
<span class="c">#显示连接主机的配置</span>
docker-machine create
<span class="c">#创建一个主机</span>
docker-machine env
<span class="c">#设置当前的环境与哪个主机通信</span>
docker-machine inspect
<span class="c">#查看主机的详细信息</span>
docker-machine ip
<span class="c">#查看主机的IP</span>
docker-machine <span class="nb">kill</span>
<span class="c">#强制关闭一个主机</span>
docker-machine ls
<span class="c">#查看所有的主机信息</span>
docker-machine provision
<span class="c">#重新配置现在主机</span>
docker-machine regenerate-certs
<span class="c">#为主机重新生成证书</span>
docker-machine restart
<span class="c">#重启主机</span>
docker-machine rm
<span class="c">#删除主机</span>
docker-machine ssh
<span class="c">#以SSH的方式连接到主机上</span>
docker-machine scp
<span class="c">#远程复制</span>
docker-machine status
<span class="c">#查看主机的状态</span>
docker-machine stop
<span class="c">#停止一个正在运行的主机</span>
docker-machine upgrade
<span class="c">#升级主机的docker服务到最新版本</span>
docker-machine version
<span class="c">#查看docker-machine版本</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="docker-命令行">Docker 命令行</h3>

<h3 id="查看版本和帮助">查看版本和帮助</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">docker --help</code> 可以查看主命令的用法</li>
  <li><code class="language-plaintext highlighter-rouge">docker COMMAND --help</code> 可以查看子命令用法</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre>docker --version
docker-compose --version
docker-machine --version

docker --help
docker run --help
</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>Docker 的子命令如下</li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre></td><td class="code"><pre>Commands:
  attach      Attach local standard input, output, and error streams to a running container
  build       Build an image from a Dockerfile
  commit      Create a new image from a container's changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  deploy      Deploy a new stack or update an existing stack
  diff        Inspect changes to files or directories on a container's filesystem
  events      Get real time events from the server
  exec        Run a command in a running container
  export       a container's filesystem as a tar archive
  history     Show the history of an image
  images      List images
  import      the contents from a tarball to create a filesystem image
  info        Display system-wide information
  inspect     Return low-level information on Docker objects
  kill        Kill one or more running containers
  load        Load an image from a tar archive or STDIN
  login       Log in to a Docker registry
  logout      Log out from a Docker registry
  logs        Fetch the logs of a container
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  ps          List containers
  pull        Pull an image or a repository from a registry
  push        Push an image or a repository to a registry
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  rmi         Remove one or more images
  run         Run a command in a new container
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  search      Search the Docker Hub for images
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  version     Show the Docker version information
  wait        Block until one or more containers stop, then print their exit codes
</pre></td></tr></tbody></table>
</div>
</div>

<p><img src="/Users/dalong/Library/Mobile Documents/com~apple~CloudDocs/python1702笔记/images/Docker Commands.png" alt="" /></p>

<h3 id="docker-version">docker version</h3>

<ul>
  <li>查看docker 的客户端版本和服务端版本， 如果都能看到信息说明服务端已经正常启动</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>docker version
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="docker-命令缩写">Docker 命令缩写</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre> docker pull = docker image pull
 docker create = docker container create  
 docker start = docker container start  
 docker ps = docker container ps  
 docker rm = docker container rm  
 docker run = docker create; docker start
 # 如果run 使用的镜像不存在，docker 会尝试自动 pull 这个镜像下来
 # 比如 如下， 如果本地没有 centos 镜像， docker 会自动 pull 一个 centos 下来，然后 create + start
 # docker run -it --name mycentos centos 
 docker rmi =docker image rm
 
 
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="一步一步创建和运行一个能运行-python-的容器镜像">一步一步，创建和运行一个能运行 Python 的容器镜像</h3>

<h3 id="从-docker-hub-上拉一个-python-最新版本的镜像">从 docker hub 上拉一个 python 最新版本的镜像</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>docker image pull python
<span class="c"># 成功后也可以再 docker desktop 中的 image tab 中可以看到</span>
docker image list  <span class="c"># 查看所有的 本地 image</span>

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="创建一个新的-python-容器">创建一个新的 python 容器</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre>docker container create --tty --interactive python
<span class="c"># --tty                            Allocate a pseudo-TTY</span>
<span class="c"># --interactive                    Keep STDIN open even if not attached</span>
<span class="c"># 创建后可以在 docker desktop 中的 container tab 中看到</span>
docker container ps --all  <span class="c"># 查看运行中的容器</span>
<span class="c"># CONTAINER ID   IMAGE        COMMAND                  CREATED          STATUS                      PORTS     NAMES</span>
<span class="c"># ffb2d557e2c6   python       "python3"                8 minutes ago    Created                               fervent_lamport</span>
</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>容器的名字是一个随机创建的名字，可以被修改</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>docker container rename fervent_lamport mypython
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="启动-python-容器">启动 python 容器</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre>docker container start --interactive mypython
<span class="c"># --interactive 启动后就直接进入了 Python 的命令行。不带 interactive 参数， 就是单纯启动</span>
<span class="c"># python 命令行中可以看到python 的主机名就是容器名，因为 Python 运行在容器中</span>
<span class="c"># &gt;&gt;&gt; import socket</span>
<span class="c"># &gt;&gt;&gt; print(socket.gethostname())</span>
<span class="c"># ffb2d557e2c6</span>
<span class="c"># 在 Docker desktop 中可以看到这个容器由红色变成了绿色</span>
docker container ps --all 
<span class="c"># 可以看到原来的STATUS 由 Created 状态变成了 Up 32 seconds </span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="删除-python-容器-删除镜像">删除 Python 容器， 删除镜像</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>docker container rm mypython
docker rmi python
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="在本地系统中和容器交互">在本地系统中和容器交互</h3>

<h3 id="文件拷贝-docker-cp">文件拷贝 docker cp</h3>

<p>我们在进行代码开发的时候经常需要把我们开发好的代码拷贝到容器中， 下面是一个例子</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><pre>git clone https://github.com/pythonincontainers/myfirst
<span class="nb">cd </span>myfirst
docker pull python
docker create -it --name mypython python

<span class="c"># 在容器和本地之间互相 拷贝文件</span>
docker cp --help
docker cp myfirst.py mypython:/tmp/myfirst.py
docker start -i mypython 
<span class="c"># 进入 docker 看看。 exec 是要在 docker 中执行一个命令（/bin/sh）</span>
<span class="c"># -it 是要交互方式进行</span>
docker <span class="nb">exec</span> -it mypython /bin/sh  <span class="c"># 进入容器命令行</span>
<span class="nb">cd</span> /tmp
ls <span class="c"># 可以看到拷贝过来的文件</span>
touch abc.txt
<span class="nb">exit</span>  <span class="c"># 退出容器，回到主机</span>
docker cp mypython:/tmp/abc.txt ./abc.txt
ls  <span class="c"># 可以看到拷贝出来的 abc.txt</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="docker-和主机目录共享---docker-bind-mount">docker 和主机目录共享 - Docker Bind Mount</h3>

<ul>
  <li>让容器可以访问主机的目录</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="c"># 通过 run 命令在创建容器的时候，用-v 来指定 mount 的目录</span>
<span class="c"># -v, --volume list                    Bind mount a volume</span>
<span class="c"># -d, --detach                         Run container in background and print container ID</span>
docker run -it --name mypython -v <span class="k">${</span><span class="nv">PWD</span><span class="k">}</span>:/app python 
<span class="c"># or docker run -d -v ${PWD}/data:/data python </span>
docker start mypython
docker <span class="nb">exec</span> -it mypython /bin/sh <span class="c"># 进入容器</span>
<span class="nb">cd</span> /app
ls  <span class="c"># 可以看到本地共享目录中的文件</span>
<span class="c"># 尝试在本地修改一个文件保存， 然后在 容器中 cat 一下</span>



</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>还可以在创建容器时默认执行一个python命令, 就算没有 启动容器也可以执行</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre>docker run -it --name myfirst -v <span class="k">${</span><span class="nv">PWD</span><span class="k">}</span>:/app python python /app/myfirst.py
<span class="c"># 参数中第一个python 是镜像的名字，第二个参数就是运行容器后要执行的命令了</span>
<span class="c"># 输出了 myfirst.py 的打印内容 - Python in Containers! Version 1.2</span>
docker start -i myfirst  
<span class="c"># 以后只要启动，就会输出 Python in Containers! Version 1.2</span>
<span class="c"># -i, --interactive          Attach container's STDIN </span>
</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>可以让容器启动时进行交互</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre>docker run -it --name mysecond -v <span class="k">${</span><span class="nv">PWD</span><span class="k">}</span>:/app python python /app/mysecond.py
<span class="c"># 这里，mysecond.py 代码中有 如下代码要求用户进行交互操作</span>
<span class="c"># 所以当容器被创建后，会要求用户输入姓名，并打印你好+姓名</span>
<span class="c"># print('Python in Containers!')</span>
<span class="c"># name = input('What is your name? ')</span>
<span class="c"># print('Greetings ' + name)</span>

</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>创建容器后不需要 exec 直接进入容器命令行, 执行 python 命令</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>docker run -it --name mypython -v <span class="k">${</span><span class="nv">PWD</span><span class="k">}</span>:/app python /bin/bash <span class="c"># 创建容器后直接进入容器命令行</span>
<span class="nb">cd</span> /app
ls
python mysecond.py 
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="本地和容器进行端口映射">本地和容器进行端口映射</h3>

<ul>
  <li>尝试在容器中安装 flask, 并启动 flask</li>
  <li>进行端口映射 ， 在本地修改代码然后在 浏览器中查看flask web page 的变化</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre>docker run -it -p 5001:5000 --name mythird -v <span class="k">${</span><span class="nv">PWD</span><span class="k">}</span>:/app python /bin/bash <span class="c"># 创建容器后直接进入容器命令行</span>
<span class="c"># or docker run -p 8080:80 python ... 来指定 我们的主机用 8080端口映射容器的 80端口</span>
<span class="c"># 在 mythird 容器中执行</span>
pip install flask 
<span class="c"># 设置临时环境变量（仅限于本次登录）; export -p 列出所有当前环境变量， -n 删除指定变量</span>
<span class="nb">export </span><span class="nv">FLASK_DEBUG</span><span class="o">=</span>1
<span class="nb">export </span><span class="nv">FLASK_APP</span><span class="o">=</span>mythird.py
flask run --host<span class="o">=</span>0.0.0.0   <span class="c"># 启动 flask</span>
</pre></td></tr></tbody></table>
</div>
</div>

<blockquote>
  <p>访问本机的 http://localhost:5001 可以访问到容器运行的 flask web 页面</p>

  <p>回到本机，尝试修改 mythird.py 文件， 然后刷新浏览器，就可以看到变化。</p>
</blockquote>

<h3 id="玩转-container-image">玩转 Container Image</h3>

<h3 id="container-image-包含两部分内容">Container Image 包含两部分内容</h3>

<ol>
  <li>Filesystem</li>
  <li>Metadata</li>
</ol>

<p>比如 Python 的 image 里面包含了创建一个 python 容器所必要的文件系统和需要运行 python 所必要的元数据。 都是以非不要不添加的原则。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre>docker run --rm -it python bash  
<span class="c"># --rm Automatically remove the container when it exits</span>
ls -l /usr/local/bin  <span class="c"># 可以看到容器中只有必须的一些命令</span>
env   <span class="c"># 可以看到环境信息， 和下面 docker image inspect python 中输入的内容相同</span>
<span class="nb">exit</span>

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="查看-image-内容的命令">查看 image 内容的命令</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre>docker image inspect python 
<span class="c"># 输出一个 json 文件</span>
<span class="c"># 其中下面部分和 python 相关。 python3 是容器启动后的默认命令</span>
 					<span class="s2">"Env"</span>: <span class="o">[</span>
                <span class="s2">"PATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>,
                <span class="s2">"LANG=C.UTF-8"</span>,
                <span class="s2">"GPG_KEY=&lt;your own key&gt;"</span>,
                <span class="s2">"PYTHON_VERSION=3.9.3"</span>,
                <span class="s2">"PYTHON_PIP_VERSION=21.0.1"</span>,
                <span class="s2">"PYTHON_GET_PIP_URL=https://github.com/pypa/get-pip/raw/29f37dbe6b3842ccd52d61816a3044173962ebeb/public/get-pip.py"</span>,
                <span class="s2">"PYTHON_GET_PIP_SHA256=&lt;your own code&gt;"</span>
            <span class="o">]</span>,
            <span class="s2">"Cmd"</span>: <span class="o">[</span>
                <span class="s2">"python3"</span>
            <span class="o">]</span>,

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="image-启动的时候需要-entrypoint-和-cmd">image 启动的时候需要 entrypoint 和 cmd</h3>

<ul>
  <li>Entrypoint 就是 命令 + 第一个参数</li>
  <li>cmd 就是 后面的参数</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre></td><td class="code"><pre>docker run pythonincontainers/entrypoint
<span class="c"># pythonincontainers/entrypoint 是一个镜像的名字， 就和 python 是一个镜像的名字一样</span>
<span class="c"># 输出 one two three</span>
docker run pythonincontainers/entrypoint 3 4 5 6 7
<span class="c"># 输出 one 3 4 5 6 7</span>
docker inspect pythonincontainers/entrypoint 
<span class="c"># 可以看到 cmd 和 entrypoint 的设置内容</span>
<span class="s2">"Config"</span>: <span class="o">{</span>...
						<span class="s2">"Cmd"</span>: <span class="o">[</span>
                <span class="s2">"two"</span>,
                <span class="s2">"three"</span>
            <span class="o">]</span>, ....
            <span class="s2">"Entrypoint"</span>: <span class="o">[</span>
                <span class="s2">"echo"</span>,
                <span class="s2">"one"</span>
            <span class="o">]</span>, ....
<span class="c"># 为什么上面第一个 run 命令 可以打印出 one two three </span>
<span class="c"># 因为组合出来的命令是 echo one two three</span>
<span class="c"># 为什么上面第二个 run 命令 可以打印出 one 3 4 5 6 7</span>
<span class="c"># 因为 echo 命令不变，one 被 3 覆盖， two 和 three 被 4，5，6，7 覆盖</span>

</pre></td></tr></tbody></table>
</div>
</div>

<p>快速打印出 一个Image 的 entrypointy 和 cmd</p>

<ul>
  <li>下面可以看到很多 不同 image 的 entrypoint 和 cmd</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre>docker inspect --format <span class="s2">"ENTRYPOINT={{.Config.Entrypoint}} CMD={{.Config.Cmd}}"</span> pythonincontainers/entrypoint
<span class="c"># 输出 ENTRYPOINT=[echo one] CMD=[two three]</span>
docker inspect --format <span class="s2">"ENTRYPOINT={{.Config.Entrypoint}} CMD={{.Config.Cmd}}"</span> python
<span class="c"># 输出 ENTRYPOINT=[] CMD=[python3]</span>
docker inspect --format <span class="s2">"ENTRYPOINT={{.Config.Entrypoint}} CMD={{.Config.Cmd}}"</span> alpine
<span class="c"># 输出 ENTRYPOINT=[] CMD=[/bin/sh]</span>
docker inspect --format <span class="s2">"ENTRYPOINT={{.Config.Entrypoint}} CMD={{.Config.Cmd}}"</span> centos
<span class="c"># 输出 ENTRYPOINT=[] CMD=[/bin/sh]</span>
docker inspect --format <span class="s2">"ENTRYPOINT={{.Config.Entrypoint}} CMD={{.Config.Cmd}}"</span> nginx
<span class="c"># 输出 ENTRYPOINT=[] CMD=[nginx -g daemon 0ff;]</span>
docker inspect --format <span class="s2">"ENTRYPOINT={{.Config.Entrypoint}} CMD={{.Config.Cmd}}"</span> postgres
<span class="c"># 输出 ENTRYPOINT=[docker-entrypint.sh] CMD=[postgres]</span>


</pre></td></tr></tbody></table>
</div>
</div>

<blockquote>
  <p>可以发现很多Image 默认是不设置 entrypoint 的</p>
</blockquote>

<p>创建容器时如果想要覆盖默认的 entrypoint 可以用参数 –entrypoint</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>docker run -it --entrypoint /bin/sh pythonincontainers/entrypoint
<span class="c"># 这样，创建容器后，默认就不是 echo one ，而是 /bin/sh 作为默认进入容器的命令了</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="dockert-image-id">Dockert image ID</h3>

<ul>
  <li>id 由 shar256 创建， 有 64 个字符</li>
  <li>前 12 个字符作为 短 ID</li>
</ul>

<h3 id="image-镜像的清理">image 镜像的清理</h3>

<p>删除无用镜像，节省空间</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre>docker image ls
docker rmi pythonincontainers/entrypoint
docker image prune  <span class="c"># 删除所有没有对应容器的 image ，需要谨慎</span>
<span class="c"># WARNING! This will remove all images without at least one container associated to them.</span>
<span class="c"># Are you sure you want to continue? [y/N] </span>

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="管理容器">管理容器</h3>

<h3 id="交互模式和非交互模式">交互模式和非交互模式</h3>

<ul>
  <li>运行容器时进行交互</li>
  <li>比如运行一个 python 容器，希望直接进入 python 命令行</li>
  <li>比如运行 centos, 希望直接进入 centos 命令行</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="c"># --interactive --tty = -it</span>
docker run --rm -it python bash  
</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>运行容器时，非交互模式。</li>
  <li>默认会返回一个容器 ID</li>
  <li>比如运行一个 flask web server, 就不需要卡在 命令行上，让它自己在后台运行就可以了</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="c"># --detach = -d</span>
docker run -d -p 5000:5000 --name simple-flask pythonincontainers/simple-flask
<span class="c"># 输出 7754e1e53d5e534b87278576ee5650da9f01e891ebf078c6df2810ec3ab73549</span>

</pre></td></tr></tbody></table>
</div>
</div>

<p>http://localhost:5000</p>

<h3 id="查看容器日志-logs">查看容器日志 logs</h3>

<p>当容器运行不是交互模式的时候， 需要查看容器的运行情况，就需要用 logs 或者 attach</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre>docker logs simple-flask
docker logs --since 1m simple-flask  <span class="c"># 查看最近一分钟的日志</span>
docker logs -n 10 simple-flask  <span class="c"># 查看最后 10 行日志</span>
<span class="c"># 输出</span>
<span class="c"># 172.17.0.1 - - [05/Apr/2021 02:43:50] "GET / HTTP/1.1" 200 -</span>
<span class="c"># 172.17.0.1 - - [05/Apr/2021 02:43:51] "GET /abc HTTP/1.1" 404 -</span>
<span class="c"># 172.17.0.1 - - [05/Apr/2021 02:43:51] "GET /favicon.ico HTTP/1.1" 404 -</span>

<span class="c"># 跟随模式，可以实时看到最新的日志</span>
docker logs -t -f simple-flask  <span class="c"># -t Show timestamps . -f Follow log output</span>



</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="贴附模式--attach">贴附模式  attach</h3>

<ul>
  <li>
    <p>Attach local standard input, output, and error streams to a running container</p>
  </li>
  <li>和 docker logs -f 的效果类似</li>
  <li>不管运行的容器有什么输出，都可以看到</li>
  <li>退出好像有点问题 ， control + c/p/q 不好使，</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>docker attach simple-flask 
<span class="c"># 和 docker logs -f 的效果类似</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="在容器中执行命令-exec">在容器中执行命令 exec</h3>

<blockquote>
  <p>Run a command in a running container</p>
</blockquote>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">docker exec &lt;容器名&gt; &lt;命令。。。&gt;</code></p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre>docker <span class="nb">exec </span>simple-flask ps -ef
<span class="c">#输出</span>
<span class="c">#UID        PID  PPID  C STIME TTY          TIME CMD</span>
<span class="c">#root         1     0  0 02:38 ?        00:00:00 /bin/sh -c python hello.py</span>
<span class="c">#root         8     1  0 02:38 ?        00:00:01 python hello.py</span>
<span class="c">#root        26     0  0 03:04 ?        00:00:00 ps -ef</span>


</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>进入运行中的容器命令行直接操作bash命令</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>docker <span class="nb">exec</span> -it simple-flask bash  <span class="c"># 进入容器</span>
apt-get update  <span class="c"># 升级安装库</span>
apt-get install vim  <span class="c"># 安装需要的软件 vim</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="控制容器的资源">控制容器的资源</h3>

<blockquote>
  <p>在创建容器的时候如果不指定资源， 默认是会使用 主机的所有资源</p>

  <p>在创建容器的时候可以给容器指定所需要的 CPU, 内存， swap 空间</p>

  <p>一旦容器运行时超出了规定的限制， 进程就会被 自动kill 掉</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre>docker run -it -m 100m --memory-swap 100m --cpus 0.6 python bash
<span class="c"># --cpus 指的是虚拟 cpu 个数</span>
pip install numpy 
python
&gt;&gt;&gt;import numpy
&gt;&gt;&gt;result <span class="o">=</span> <span class="o">[</span>numpy.random.bytes<span class="o">(</span>1024<span class="k">*</span>1024<span class="o">)</span> <span class="k">for </span>x <span class="k">in </span>range<span class="o">(</span>1024<span class="o">)]</span>
<span class="c"># 这里python 进程会因为内存使用超出限制而被 kill 掉</span>

</pre></td></tr></tbody></table>
</div>
</div>

<p>查看 docker 状态</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>docker stats  <span class="c"># 查看docker 资源使用情况</span>
docker logs laughing_johnson <span class="c"># 查看 docker 最后的命令，寻找为什么 docker 被 kill 掉的原因</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>删除所有容器</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>docker rm -f <span class="k">$(</span>docker ps -a -q<span class="k">)</span>   <span class="c"># -f 强制删除</span>
<span class="c"># docker ps -a -q 会列出来所有停止了的容器的 id ： -a 所有， -q 只列 id</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="运行多个容器">运行多个容器</h3>

<ul>
  <li>让容器之间可以进行访问</li>
</ul>

<h3 id="在容器中设置-hosts">在容器中设置 hosts</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><pre><span class="c"># 先创建一个容器</span>
docker run -d -p 5000:5000 --name simple-flask pythonincontainers/simple-flask
<span class="c"># 查看这个容器的 IP</span>
docker inspect --format <span class="s2">"{{.NetworkSettings.IPAddress}}"</span> simple-flask

<span class="c"># 创建另一个 centos 容器，并追加一行到 hosts 文件  </span>
docker run --rm -it --name centos --add-host simple-flask:<span class="k">$(</span>docker inspect --format <span class="s2">"{{.NetworkSettings.IPAddress}}"</span> simple-flask<span class="k">)</span> centos
<span class="c"># docker run --rm -it --name centos --add-host simple-flask:172.17.0.2 centos</span>

more /etc/hosts  <span class="c"># 进入centos 容器后查看 /etc/hosts 文件</span>
<span class="c"># 输出如下  172.17.0.2	simple-flask</span>
curl simple-flask:5000  <span class="c"># 尝试访问另一个容器的 web</span>
<span class="c"># 输出 Flask Hello world! Version 1</span>
curl 172.17.0.2:5000 <span class="c"># 效果一样</span>

<span class="nb">exit
</span>docker rm -f simple-flask

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="创建一个容器网络-network">创建一个容器网络 network</h3>

<ul>
  <li>好处是所有创建的容器都可以通过容器网络直接互相链接，不会因为某个容器的 IP 发生变化而需要修改配置</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><pre><span class="c"># 创建容器网络</span>
docker network create my-net
docker network ls
<span class="c"># 创建flask容器并使用网络</span>
docker run -d --name simple-flask --network my-net pythonincontainers/simple-flask
<span class="c"># 创建 centos 容器并使用网络</span>
docker run --rm -it --name centos --network my-net centos
curl simple-flask:5000  <span class="c"># 在centos 容器内访问 flask 网页</span>
<span class="c"># 输出 Flask Hello world! Version 1</span>

<span class="c"># 创建一个 proxy 服务器</span>
<span class="c"># 进入另一个 terminal 并执行如下命令创建nginx 容器</span>
docker run -d --name proxy-server --network my-net nginx

<span class="c"># 然后返回到 centos 的 terminal 执行如下命令</span>
curl proxy-server:80
<span class="c"># 输出 nginx 的 html 代码</span>
<span class="c"># 。。。&lt;title&gt;Welcome to nginx!&lt;/title&gt;。。。</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p><code class="language-plaintext highlighter-rouge">--link</code> 的用处和–add-host 差不多</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="c"># 删掉 simple-flask 并重新创建</span>
docker rm -f simple-flask
docker run -d --name simple-flask pythonincontainers/simple-flask
<span class="c"># 通过 --link 将 simple-flask 容器添加到 centos 的 hosts </span>
<span class="c"># webserver 是 simple-flask 的别名</span>
docker run --rm -it --link simple-flask:webserver centos
<span class="c"># 进入容器</span>
curl simple-flask:5000  <span class="c"># 尝试访问 simple-flask</span>
env |grep WEBSERVER  <span class="c"># 查看所有centos 配置的关于 simple-flask(webserver) 的信息</span>
<span class="nb">exit
</span>docker rm -f simple-flask

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="创建一个-posgres-数据库">创建一个 posgres 数据库</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre>docker run -d --name postgres --network my-net --env <span class="s2">"POSTGRES_PASSWORD=mysecret"</span> postgres

docker logs postgres <span class="c"># 查看 postgres 是否正常启动</span>
<span class="c"># 看到输出 。。。database system is ready to accept connections</span>
<span class="c"># 创建一个 postgre 的管理工具容器 - pgadmin4</span>
docker run -d --name pgadmin --network my-net -e <span class="s2">"PGADMIN_DEFAULT_EMAIL=user@example.com"</span> -e <span class="s2">"PGADMIN_DEFAULT_PASSWORD=supersecret"</span> -p 8088:80 dpage/pgadmin4

</pre></td></tr></tbody></table>
</div>
</div>

<blockquote>
  <p>访问 http://localhost:8088</p>

  <p>用户名密码 user@example.com  supersecret</p>

  <ul>
    <li>创建一个 db server : mydb</li>
    <li>指定 connection (要链接的服务器/容器名字) : postgres</li>
    <li>username : postgres</li>
    <li>password : mysecret</li>
  </ul>

  <p>完成后左侧可以看到 mydb</p>

  <ul>
    <li>创建一个新的数据库：mydatabase</li>
  </ul>
</blockquote>

<p>下载此部分的实验代码</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre>git clone https://github.com/pythonincontainers/sqlalchemy-psql
<span class="nb">cd </span>sqlalchemy-psql/
<span class="c"># 创建一个python 容器并和当前目录共享下载下来的 python 文件</span>
docker run --rm -it -v <span class="k">${</span><span class="nv">PWD</span><span class="k">}</span>:/app --network my-net python bash
<span class="c"># 已经进入容器</span>
<span class="nb">cd</span> /app
pip install -r requirements.txt  <span class="c"># 安装所需的扩展包</span>
<span class="c"># 执行创建表和插入数据的 python 文件</span>
python alchemy-psql.py 
<span class="c"># 执行后，数据库中会创建一个 user 表并插入多条数据</span>
<span class="c"># mydb-&gt;mydatabase-&gt;schemas-&gt;public-&gt;tables-&gt;person 右键 -&gt;view/edit data -&gt; all rows</span>

<span class="c">#清理实验</span>
docker rm -f <span class="k">$(</span>docker ps -a -q<span class="k">)</span>
docker image prune 

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="容器网络-networking">容器网络 Networking</h3>

<ul>
  <li>当我们创建一个容器，如果不指定网络， 默认他会使用 bridge network
    <ul>
      <li>容器会通过连接到主机网络接口来访问外网</li>
      <li>如果没有进行 expost 暴露端口映射， 外网不能访问容器网络，</li>
      <li>ip 地址段是 172.17.0.0/16</li>
      <li>没有 DNS 设置</li>
    </ul>
  </li>
</ul>

<h3 id="创建一个没有网络的容器---none">创建一个没有网络的容器 - none</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre>docker network ls
<span class="c"># 输出</span>
<span class="c"># NETWORK ID     NAME      DRIVER    SCOPE</span>
<span class="c"># a76c7ba20fbc   bridge    bridge    local   桥接网络</span>
<span class="c"># 5656ec8f0876   host      host      local   主机网络</span>
<span class="c"># 338713d26e03   my-net    bridge    local   我们为容器创建的网络</span>
<span class="c"># b3e935e8c6fe   none      null      local   </span>

docker run --rm -it --network none alpine <span class="c"># 创建一个没有网络的linux - alpine容器</span>
<span class="c"># 进入容器</span>
ifconfig <span class="c"># 查看本地网络信息</span>
ip add show <span class="c"># 查看 IP 地址</span>
ip route <span class="c"># 查看路由</span>
ping -c 3 8.8.8.8 <span class="c"># ping 外网， 不通</span>
<span class="nb">exit</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="创建一个链接到-主机的容器---bridge">创建一个链接到 主机的容器 - bridge</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre>docker run --rm -it --network host alpine
ifconfig  <span class="c"># 查看本地网络， 此时使用的是桥接模式， 主要看 docker0 这个网络</span>
ip add show <span class="c"># 查看 IP 地址</span>
ip route <span class="c"># 查看路由</span>
ping -c 3 8.8.8.8 <span class="c"># ping 外网， 通</span>
<span class="nb">exit</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="删除网络">删除网络</h3>

<ul>
  <li>当一个网络已经有容器连接他，那么需要先删除容器或者断开网络，才能删除</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre>docker network create new-net
docker network ls

<span class="c"># 找出使用了 new-net 网络的容器，并准删掉后，才能删掉对应的网络</span>
docker ps --filter <span class="nv">network</span><span class="o">=</span>new-net   
docker network rm new-net <span class="c"># 删除网络</span>

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="创建指定网段的容器">创建指定网段的容器</h3>

<ul>
  <li>打开第一个 terminal</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="c"># </span>
docker network create --subnet 10.10.0.0/16 my-addr
docker network ls
docker run --rm -it --name alpine1 --network my-addr alpine
<span class="c"># 进入容器</span>
ifconfig
<span class="c"># 输出 eth0 addr:10.10.0.2</span>


</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>打开第二个 terminal</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre>docker run --rm -it --name alpine2 alpine
<span class="c"># 进入容器</span>
ifconfig
<span class="c"># 输出 eth0 addr:172.17.0.2  ， 因为没有指定网络，所以使用了 bridge</span>


</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>打开第三个 terminal</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>docker network connect my-addr alpine2
</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>回到第二个 terminal</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre>ifconfig
<span class="c"># 输出 eth1 addr:10.10.0.3, 因为容器 alpine2 已经连接到了指定的网段的网络</span>
ping -c 1 alpine1  <span class="c"># 可以ping 通</span>


</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>回到第三个</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>docker ps --filter <span class="nv">network</span><span class="o">=</span>my-addr  <span class="c"># 查看所有在 my-addr 下面的容器</span>
docker network disconnect my-addr alpine2  <span class="c"># 断开 alpine2 的链接</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="创建内网">创建内网</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre>docker network create --internal int-net 
docker run -dit --name int1 --network int-net alpine
docker run -it --rm --name int2 --network int-net alpine
ping -c 1 int1  <span class="c"># 通</span>
ping -c 1 8.8.8.8 <span class="c"># ping google 不通</span>

docker rm -f <span class="k">$(</span>docker ps -a -q<span class="k">)</span>
docker image prune 
docker network rm my-addr int-net my-net new-net 

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="数据永久存储---volumes">数据永久存储 - volumes</h3>

<ul>
  <li>容器的存储是跟着容器的生命周期的， 容器没了，存储的数据就没了</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><pre>docker run -it --name mypython python bash
mkdir /app  <span class="c"># 进入容器</span>
<span class="nb">cd</span> /app
cat <span class="sh">&lt;&lt;-EOF &gt; script.py  # 创建一个 script.py 的脚本，输入 EOF 后保存退出
print('Hello from a container')
EOF
</span>python script.py
<span class="nb">exit</span>  <span class="c"># 退出容器</span>

docker start -i mypython   <span class="c"># 重新启动，并进入容器， 默认是用 bash 交互</span>
<span class="c"># 和 docker start mypython + docker exec -it mypython bash 效果一样</span>
<span class="nb">exit
</span>docker rm mypython 
docker run -it --name mypython python bash
<span class="nb">cd</span> /app  <span class="c"># 没有这个目录</span>
<span class="nb">exit
</span>docker rm mypython

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="创建永久存储">创建永久存储</h3>

<ul>
  <li>创建容器的时候是唯一的机会 mount 到存储上</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></td><td class="code"><pre>docker volume create my-vol 
docker volume ls

<span class="c"># 创建容器，并 mount 到 volume 上 （唯一的机会）</span>
docker run -it --name mypython --volume my-vol:/app python bash
<span class="nb">cd</span> /app
<span class="c"># 创建数据 （到 volume 上）</span>
cat <span class="sh">&lt;&lt;-EOF &gt; script.py
print("hello my volume")
EOF
</span>python script.py 
<span class="nb">exit</span> 
<span class="c"># 删除容器</span>
docker rm mypython

<span class="c"># 查看 volume </span>
docker volume ls
docker volume inspect my-vol

<span class="c"># 重建容器， /app 下还能看到原来的数据</span>
docker run -it --name mypython --volume my-vol:/app python bash
<span class="nb">cd</span> /app
python script.py

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="删除-volume">删除 volume</h3>

<ul>
  <li>volume 在使用的时候是不能被删除的，会报错</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>docker volume rm my-vol <span class="c"># 报错</span>
docker rm mypython
docker volume rm my-vol  <span class="c"># 成功</span>
</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>创建容器时用 -v 可以把容器的目录和主机目录共享</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre>docker run --rm -it -v <span class="k">${</span><span class="nv">PWD</span><span class="k">}</span>:/app python bash
<span class="nb">cd</span> /app
cat <span class="sh">&lt;&lt;-EOF &gt; script.py
print("hello from a container")
EOF

</span><span class="c"># 在主机上用编辑器增加一行 print('second line from host')</span>
python script.py <span class="c"># 可以看到新增加的内容</span>

docker rm -f <span class="k">$(</span>docker ps -a -q<span class="k">)</span>
docker image prune 
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="dockerfile">Dockerfile</h3>

<ul>
  <li>传统的运行 python 容器的方法</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre>git clone https://github.com/pythonincontainers/flask-hello
<span class="nb">cd </span>flask-hello
docker run --rm -it -p 5000:5000 -v <span class="k">${</span><span class="nv">PWD</span><span class="k">}</span>:/app python bash
<span class="nb">cd</span> /app
pip install Flask
<span class="nb">export </span><span class="nv">FLASK_DEBUG</span><span class="o">=</span>True
python flask-hello.py

Control + C
<span class="nb">exit</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="了解-dockerfile">了解 Dockerfile</h3>

<pre><code class="language-dockerfile">FROM python  # 这个 image 是基于 python 这个 image 做的
WORKDIR /myproject  # 指定要创建的容器的工作目录
COPY . .  # 将当前目录（clone 下来的目录）的所有内容拷贝到容器的工作目录中
RUN pip install -r requirements.txt  # 安装所有必须的包
EXPOSE 5000  # 设置 容器对外暴露的端口号。只是容器的，不是 host 的
ENV FLASK_DEBUG=True  # 打开 debug 模式
CMD python flask-hello.py  # 当运行容器时，默认的命令启动 flask

</code></pre>

<p>用 dockerfile 建立一个本地image</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></td><td class="code"><pre>docker build -t flask-hello:1.0 .  <span class="c"># . 表示当前目录，当前目录中需要有一个 dockerfile </span>
<span class="c"># 运行成功后就自动执行了 dockerfile 中的一系列动作，包括</span>
<span class="c">#设置工作目录</span>
<span class="c">#拷贝 clone 下来的文件到工作目录</span>
<span class="c">#安装 flask</span>
<span class="c">#暴露端口</span>
<span class="c">#设置环境变量</span>
<span class="c">#设置默认命令</span>

docker run -d -P --name flask-hello flask-hello:1.0  <span class="c"># 创建容器</span>
<span class="c"># -p, --publish list  Publish a container's port(s) to the host</span>
<span class="c"># -P 自动把所有容器的端口都和 hots 主机进行 mapping </span>
<span class="c"># flask-hello:1.0  是本地镜像的名字</span>

docker ps  <span class="c"># 查看端口映射情况</span>
<span class="c"># 输出 0.0.0.0:55000-&gt;5000/tcp</span>
<span class="c"># 访问 http://localhost:55000</span>
docker logs flask-hello  

<span class="c"># 建立好镜像后，通过命令查看 image 的配置信息</span>
docker inspect flask-hello:1.0

docker rm -f flask-hello
docker rmi flask-hello:1.0


</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="spdockerfile-语法">spDockerfile 语法</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre>FROM 基础镜像
WORKDIR  工作目录
COPY 拷贝文件到工作目录
RUN 安装类库和模块
ENV 配置环境变量
EXPOSE 设置暴露的的端口
LABEL 设置标签
ENTERYPOINT  容器启动后的默认命令
CMD 默认命令的参数
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="docker-hub-介绍">Docker Hub 介绍</h3>

<ul>
  <li>一个仓库可以由多个镜像和多个 tag.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">37016175/simple-flask:latest</code></p>

<p>37016175 是账户名</p>

<p>simple-flask 是仓库名</p>

<p>latest 是  tag</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre>docker image ls 37016175/simple-flask

docker login  <span class="c"># 登录 ducker hub</span>

docker <span class="nb">logout

cd </span>flask-hello/

docker build -t 37016175/flask-hello:1.0 .

<span class="c"># 为 1.0 再打一个 latest 标签</span>
docker tag 37016175/flask-hello:1.0 37016175/flask-hello:latest
<span class="c"># 上传镜像到 docker hub</span>
docker push 37016175/flask-hello:1.0

<span class="c"># 修改一下代码， 然后重新 buile 另一个版本的镜像</span>
docker build -t 37016175/flask-hello:2.0 .
<span class="c"># 把 2.0 tag 成 latest</span>
docker tag 37016175/flask-hello:2.0 37016175/flask-hello:latest
docker push 37016175/flask-hello:2.0


</pre></td></tr></tbody></table>
</div>
</div>

<p>其他人如果想要同时用我们的镜像的两个版本，就执行下面命令</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>docker run -d -p 5001:5000 37016175/flask-hello:1.0
docker run -d -p 5002:5000 37016175/flask-hello:2.0
</pre></td></tr></tbody></table>
</div>
</div>

<p>http://localhost:5001</p>

<p>http://localhost:5002</p>

<ul>
  <li>免费的docker hub 账号不限制 public repository 个数，只能有 1 个 private repository</li>
  <li>付费的可以由多个私有仓库</li>
</ul>

<p>比较常用的是 python 官方库</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="c"># 使用 python 镜像，默认是用了 latest tag</span>
docker run -it --name mypython python bash
</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>可以在 python 仓库的描述中找到 latest 对应的 version 3.9.4</li>
  <li><code class="language-plaintext highlighter-rouge">docker pull python:latest</code> 可以将最新的 Python 镜像更新到本地镜像仓库</li>
  <li>有  <code class="language-plaintext highlighter-rouge">slim</code> 标签的镜像会比普通镜像小很多，可以节省空间。 正常镜像 1G, slim 的只有 200M ， 但是很多 模块需要手动安装 apt-get install</li>
  <li>alpine 也很小，但是兼容性差</li>
  <li>windows 是要在 windows 主机上运行的容器</li>
</ul>

<h3 id="docker-guis---portainer">Docker GUIs - Portainer</h3>

<ul>
  <li>大部分的 Docker 操作都是通过命令行完成的，优势是可以跨平台。但是有些不喜欢命令行的可以使用 Docker GUI</li>
  <li>Kitematic  https://kitematic.com  已经不更新了，需要转到 Docker desktop</li>
  <li>Portainer https://www.portainer.io  可视化容器管理工具</li>
</ul>

<p>Portainer for Docker安装方法</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="c"># 先创建一个volume</span>
docker volume create portainer_data
<span class="c"># 启动一个服务端</span>
docker run -d -p 8000:8000 -p 9000:9000 --name<span class="o">=</span>portainer --restart<span class="o">=</span>always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce
<span class="c"># 启动一个客户端</span>
<span class="c"># docker run -d -p 9001:9001 --name portainer_agent --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /var/lib/docker/volumes:/var/lib/docker/volumes portainer/agent</span>


</pre></td></tr></tbody></table>
</div>
</div>

<p>访问 http://localhost:9000</p>

<p>创建密码后登陆访问</p>

<ul>
  <li>测试创建一个 image 的docker file</li>
</ul>

<pre><code class="language-dockerfile">FROM python:3
ENV TEST hello
CMD echo 'print("Hello from my-test")' |python
</code></pre>

<h3 id="docker-machine">Docker Machine</h3>

<ul>
  <li>
    <p>Docker Machine 用来创建和管理在虚拟机中的Docker 运行时环境</p>
  </li>
  <li>
    <p>docker machine 可以在本地创建，也可以在云上的虚机中创建容器。</p>
  </li>
  <li>
    <p>支持的本地虚机类型  完整列表https://docs.docker.com/machine/drivers/</p>

    <ul>
      <li>Hyper-V</li>
      <li>Virtual</li>
      <li>vmware fusion</li>
      <li>vmware workstation</li>
      <li>Generic</li>
    </ul>
  </li>
  <li>
    <p>支持的共有云类型</p>

    <ul>
      <li>AWS</li>
      <li>Azure</li>
      <li>Digital Ocean</li>
      <li>Exoscale</li>
      <li>Google Cloud Engine</li>
      <li>Rackspace</li>
      <li>IBM Softlayer</li>
      <li>VMware Vcloud Air</li>
      <li>OpenStack</li>
      <li>Vmware Vsphere</li>
    </ul>
  </li>
  <li>
    <p>Docker Machine 命令</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></td><td class="code"><pre>  
docker-machine active
<span class="c">#显示当前的活动主机</span>
docker-machine config
<span class="c">#显示连接主机的配置</span>
docker-machine create
<span class="c">#创建一个主机</span>
docker-machine env
<span class="c">#设置当前的环境与哪个主机通信</span>
docker-machine inspect
<span class="c">#查看主机的详细信息</span>
docker-machine ip
<span class="c">#查看主机的IP</span>
docker-machine <span class="nb">kill</span>
<span class="c">#强制关闭一个主机</span>
docker-machine ls
<span class="c">#查看所有的主机信息</span>
docker-machine provision
<span class="c">#重新配置现在主机</span>
docker-machine regenerate-certs
<span class="c">#为主机重新生成证书</span>
docker-machine restart
<span class="c">#重启主机</span>
docker-machine rm
<span class="c">#删除主机</span>
docker-machine ssh
<span class="c">#以SSH的方式连接到主机上</span>
docker-machine scp
<span class="c">#远程复制</span>
docker-machine status
<span class="c">#查看主机的状态</span>
docker-machine stop
<span class="c">#停止一个正在运行的主机</span>
docker-machine upgrade
<span class="c">#升级主机的docker服务到最新版本</span>
docker-machine version
<span class="c">#查看docker-machine版本</span>
</pre></td></tr></tbody></table>
</div>
    </div>
  </li>
</ul>

<h3 id="docker-machine-with-virtualbox">Docker Machine with VirtualBox</h3>

<ul>
  <li>可以先网上下载 virtualbox, 记得一定要允许 VirtualBox 的权限
    <ul>
      <li>Grant permission to VirtualBox under System Preferences &gt; Security &amp; Privacy &gt; General (this request is new to macOS High Sierra)</li>
    </ul>
  </li>
  <li>删除由docker-machine 创建的虚机，要用 docker-machine rm 命令， 不要从 virtualbox 手动删除</li>
  <li>创建一个虚机后， 和虚机相关的文件会存储在 /Users/dalong/.docker/machine/machines/<虚机名>/目录下</虚机名></li>
  <li>安装 docker-machine 官方的<a href="https://docs.docker.com/machine/install-machine/">安装方法</a></li>
</ul>

<p>创建一个虚机</p>

<ul>
  <li>可以用如下参数定制虚机的容量</li>
  <li><code class="language-plaintext highlighter-rouge">--virutalbox-cpu-count</code></li>
  <li><code class="language-plaintext highlighter-rouge">--virtualbox-memory</code></li>
  <li><code class="language-plaintext highlighter-rouge">--virtualbox-disk-size</code></li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46</pre></td><td class="code"><pre>docker-machine create <span class="nb">test</span>-vm  <span class="c"># 创建一个 docker 虚机</span>
<span class="c">#Running pre-create checks...</span>
<span class="c">#Creating machine...</span>
<span class="c">#(test-vm) Copying /Users/dalong/.docker/machine/cache/boot2docker.iso to /Users/dalong/.docker/machine/machines/test-vm/boot2docker.iso...</span>
<span class="c">#(test-vm) Creating VirtualBox VM...</span>
<span class="c">#(test-vm) Creating SSH key...</span>
<span class="c">#(test-vm) Starting the VM...</span>
<span class="c">#(test-vm) Check network to re-create if needed...</span>
<span class="c">#(test-vm) Waiting for an IP...</span>
<span class="c">#Waiting for machine to be running, this may take a few minutes...</span>
<span class="c">#Detecting operating system of created instance...</span>
<span class="c">#Waiting for SSH to be available...</span>
<span class="c">#Detecting the provisioner...</span>
<span class="c">#Provisioning with boot2docker...</span>
<span class="c">#Copying certs to the local machine directory...</span>
<span class="c">#Copying certs to the remote machine...</span>
<span class="c">#Setting Docker configuration on the remote daemon...</span>
<span class="c">#Checking connection to Docker...</span>
<span class="c">#Docker is up and running!</span>
<span class="c">#To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env test-vm</span>

docker-machine env <span class="nb">test</span>-vm  <span class="c"># 连接 Docker client 到刚创建的 Docker VM</span>
<span class="c">#export DOCKER_TLS_VERIFY="1"</span>
<span class="c">#export DOCKER_HOST="tcp://192.168.99.101:2376"</span>
<span class="c">#export DOCKER_CERT_PATH="/Users/dalong/.docker/machine/machines/test-vm"</span>
<span class="c">#export DOCKER_MACHINE_NAME="test-vm"</span>
<span class="c"># Run this command to configure your shell: </span>
<span class="c"># eval $(docker-machine env test-vm)    运行了这个命令，你当前terminal 的 docker 环境就是模拟在虚机上的命令行了</span>


docker-machine ls

docker-machine ssh <span class="nb">test</span>-vm   <span class="c"># 登录到新建的容器虚机上</span>
<span class="c"># 也可以 ssh docker@&lt;docker-machine-ip&gt;</span>
<span class="c"># 密码 tcuser</span>
<span class="c"># 进入后默认用户是 docker, 可以 sodu -i 成为 root 用户</span>

docker ps -a  <span class="c"># 这时的虚机上什么容器和镜像都没有</span>
docker image ls -a 
docker-machine rm -f <span class="nb">test</span>-vm  <span class="c"># 删掉容器虚机</span>
<span class="c"># 查看之前设置的环境变量</span>
docker-machine env -u
<span class="c"># 清理掉之前设置的环境变量</span>
<span class="nb">unset </span>DOCKER_TLS_VERIFY DOCKER_HOST DOCKER_CERT_PATH DOCKER_MACHINE_NAME


</pre></td></tr></tbody></table>
</div>
</div>

<p>在虚机上建立容器</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre>docker-machine create <span class="nb">test</span>-vm   <span class="c"># 创建虚机</span>
docker-machine env <span class="nb">test</span>-vm  <span class="c"># 将当前环境设置成虚机</span>
<span class="nb">eval</span> <span class="k">$(</span>docker-machine env <span class="nb">test</span>-vm<span class="k">)</span>  <span class="c"># 运行了这个命令，你当前terminal 的 docker 环境就是模拟在虚机上的命令行了</span>
docker run -it -v <span class="k">${</span><span class="nv">PWD</span><span class="k">}</span>:/app alpine  <span class="c"># 创建一个小容器，并把当前目录和容器的/app 共享</span>
ls /app  <span class="c"># 进入容器后查看共享目录</span>
touch abc.txt <span class="c"># 在虚机容器的共享目录中创建一个文件， 本地也可以看见</span>

<span class="c"># 清理掉之前设置的环境变量</span>
<span class="nb">unset </span>DOCKER_TLS_VERIFY DOCKER_HOST DOCKER_CERT_PATH DOCKER_MACHINE_NAME



</pre></td></tr></tbody></table>
</div>
</div>

<p>创建第二个虚机</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre>docker-machine create second-vm
<span class="c"># 如果还用 docker-machine env second-vm 会覆盖掉原来的设置，所以可以用 </span>
docker-machine config second-vm  <span class="c"># 查看链接 second-vm 的配置文件</span>
<span class="c"># 定义一个环境变量， 把 second-vm 的配置文件信息写入</span>
<span class="nv">SECONDVM</span><span class="o">=</span><span class="k">$(</span>docker-machine config second-vm<span class="k">)</span>
<span class="nb">echo</span> <span class="nv">$SECONDVM</span> 
docker <span class="nv">$SECONDVM</span> image ls  <span class="c"># 查看 second-vm 的镜像列表</span>

</pre></td></tr></tbody></table>
</div>
</div>

<p>升级虚机的docker服务到最新版本, 重新生成证书或者重置</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre>docker-machine ls
<span class="c"># 升级虚机的docker服务到最新版本 并不会改变虚机的 IP， 已经创建的 content </span>
docker-machine upgrade <span class="nb">test</span>-vm  <span class="c"># </span>
docker-machine ls
<span class="c">#为主机重新生成TLS 证书</span>
docker-machine regenerate-certs <span class="nb">test</span>-vm
<span class="c">#重新配置现在的虚机, 一般在虚机崩掉不能重启的时候，又不想毁掉数据的时候可以考虑使用</span>
docker-machine provision <span class="nb">test</span>-vm 
<span class="c">#查看虚机的IP</span>
docker-machine ip <span class="nb">test</span>-vm 

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="docker-machine-with-hyper-v">Docker Machine with Hyper-V</h3>

<ul>
  <li>在 Windows 平台上可以考虑使用 Docker ,就要使用 Hyper-V. 但是不太稳定。</li>
  <li>Windows 上不能同时使用 Hyper-V 和 Virtual BOx, 有冲突</li>
</ul>

<h3 id="docker-machine-on-aws-cloud-hosts">Docker Machine on AWS Cloud Hosts</h3>

<ul>
  <li>
    <p>Docker Machine 可以帮助我们在 AWS 上创建容器虚机</p>
  </li>
  <li>
    <p>操作就像管理本地虚机一样</p>
  </li>
</ul>

<p>准备工作：</p>

<ul>
  <li>创建 AWS 账号 ， https://aws.amazon.com
    <ul>
      <li><a href="mailto:dalong_coo@163.com">dalong_coo@163.com</a></li>
      <li><code class="language-plaintext highlighter-rouge">@mama******</code></li>
    </ul>
  </li>
  <li>创建一个子账号，用于操作 Docker Machine , 证书的 key 构建与子账号，万一该员工离职，删除子账号就可以让 key 不生效了。
    <ul>
      <li>aws management console - &gt; IAM -&gt; users -&gt; add user</li>
      <li>machine-admin  with programmatic access</li>
      <li>Attach existing policies directly with AmazonEc2FullAccess</li>
      <li>用户创建成功, 下载含有证书的 .csv</li>
    </ul>
  </li>
  <li>生成证书
    <ul>
      <li>Access Key ID :<your own="" key=""></your></li>
      <li>Secret Access Key :<your own="" key=""></your></li>
    </ul>
  </li>
  <li>保存证书到  ~/.aws/credentials</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre>mkdir ~/.aws
sudo vi ~/.aws/credentials 

<span class="c"># 输入如下内容</span>
<span class="c"># default 是 profile 的 name</span>

<span class="o">[</span>default]
aws_access_key_id <span class="o">=</span> &lt;your own key&gt;
aws_secret_access_key <span class="o">=</span> &lt;your own key&gt;

</pre></td></tr></tbody></table>
</div>
</div>

<p>有三种方式传递证书给 AWS</p>

<ul>
  <li>证书文件</li>
  <li>环境变量
    <ul>
      <li>aws_access_key_id</li>
      <li>aws_secret_access_key</li>
    </ul>
  </li>
  <li>命令参数
    <ul>
      <li>–amazonec2-access-key</li>
      <li>–amazonect-secret-key</li>
    </ul>
  </li>
</ul>

<p>创建虚机到 AWS 上</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></td><td class="code"><pre>docker-machine create --driver amazonec2 --amazonec2-region eu-west-1 --amazonec2-open-port 5000 aws-machine
<span class="c"># --driver amazonec2 ： 用 aws ec2 作为虚机 driver</span>
<span class="c"># --amazonec2-region eu-west-1  ： 把建好的虚机放在爱尔兰</span>
<span class="c"># --amazonec2-open-port 5000 ： 虚机开放 5000 端口</span>
<span class="c"># aws-machine 虚机名</span>
<span class="c"># 其他可选参数</span>
<span class="c"># --amazonec2-instance-type t2.medium   # CPU 和内存大小， 默认是t2.micro 1 个 cpu 1g 内存</span>
<span class="c"># https://aws.amazon.com/ec2/instance-types/</span>
<span class="c"># --amazonec2-root-size 200   #  根的大小</span>
<span class="c"># --amazonec2-volume-type io1   # 存储类型</span>
<span class="c"># https://aws.amazon.com/AWSEC2/latest/Userguide/ebsvolumetypes.html</span>

docker-machine ls  <span class="c"># 创建成功后， 查看虚机</span>
<span class="c"># 输出如下</span>
<span class="c"># NAME          ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER      ERRORS</span>
<span class="c"># aws-machine   -        amazonec2    Running   tcp://34.243.30.56:2376             v20.10.5    </span>
<span class="c"># second-vm     -        virtualbox   Running   tcp://192.168.99.103:2376           v19.03.12   </span>
<span class="c"># test-vm       -        virtualbox   Running   tcp://192.168.99.102:2376           v19.03.12   </span>

<span class="c"># 激活环境变量, 然后就可以在本地操作 aws 虚机上的容器了</span>
docker-machine env aws-machine
<span class="nb">eval</span> <span class="k">$(</span>docker-machine env aws-machine<span class="k">)</span>

docker-machine ip aws-machine
<span class="c"># 输出 34.243.30.56</span>
docker-machine ssh aws-machine  
sudo -i 
docker run -it --rm -p 5000:5000 pythonincontainers/flask-hello:1.0
<span class="c"># 访问  https://34.243.30.56:5000</span>

<span class="nb">exit
exit
</span>docker-machine rm aws-machine
<span class="nb">unset </span>DOCKER_TLS_VERIFY DOCKER_HOST DOCKER_CERT_PATH DOCKER_MACHINE_NAME


</pre></td></tr></tbody></table>
</div>
</div>

<p>登录到 AWS  web portal 看虚机实例</p>

<ul>
  <li>Services -&gt; EC2 -&gt; instances</li>
</ul>

<p>登录到 AWS 为容器创建一个安全组，设置inbound 端口为 7000</p>

<ul>
  <li>Services -&gt; EC2 -&gt; security group</li>
  <li>创建一个新的安全组，
    <ul>
      <li>name  machine-rule-7000</li>
      <li>Add inbound rules
        <ul>
          <li>Port range : 7000</li>
          <li>Source: anywhere</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>回到 instance, 选中 aws-machine, action 选中 security -&gt; change security group -&gt; 添加新建的 security group</li>
</ul>

<h3 id="docker-machine-on-google-cloud">Docker Machine on Google Cloud</h3>

<p>步骤</p>

<ol>
  <li>访问 cloud.google.com</li>
  <li>为 Docker Machine 创建子账号</li>
  <li>安装 google cloud sdk</li>
  <li>登录，并授权应用证书</li>
</ol>

<h2 id="build-conrainer-images">Build Conrainer Images</h2>

<h3 id="python-容器化项目的元素">Python 容器化项目的元素</h3>

<p>当创建一个基于容器的 python 项目，需要以下元素</p>

<ul>
  <li>代码</li>
  <li>类库和依赖包</li>
  <li>数据</li>
  <li>网络，DNS 主机名，IP 地址</li>
  <li>配置文件</li>
  <li>环境变量</li>
</ul>

<h3 id="容器化-python-项目的生命周期">容器化 Python 项目的生命周期</h3>

<p>容器化项目的阶段</p>

<ol>
  <li>Architecture &amp; Design</li>
  <li>Project Initialization</li>
  <li>Coding</li>
  <li>Creating Images</li>
  <li>Testing &amp; Debugging in Development</li>
  <li>Deployment Planning &amp; Automation</li>
  <li>Integration &amp; Deployment in Testing Environment</li>
  <li>Shipping the App</li>
  <li>Deployment in Production</li>
  <li>Updating &amp; Upgrading</li>
</ol>

<h3 id="容器化应用的设计原则">容器化应用的设计原则</h3>

<p>Basic Principles</p>

<ul>
  <li>One Application or Component per container  每个应用或者组件用一个容器</li>
  <li>Horizontal Scalling  能够水平扩展</li>
  <li>Application Observability  应用可被观察</li>
  <li>Security Framework  采用安全框架</li>
  <li>Application Secrets  应用保密性</li>
  <li>Automated Deployment  采用自动化部署</li>
  <li>Immutable &amp; Disposable Containers  不可改变容器&amp;一次性的容器</li>
  <li>Application Data in Volumes   应用数据放在存储中</li>
  <li>Virtual Networks  采用虚拟网路</li>
  <li>Small Container images  保持小镜像</li>
  <li>Image Tagging  要给镜像打 tag</li>
  <li>Seamless Update &amp; Upgrade  无缝的自动更新和升级</li>
</ul>

<h3 id="手动流程-image-build-process">手动流程 Image Build Process</h3>

<p>我们希望所有 image build 都是自动完成， 但我们需要知道如何手动完成 image build 的流程</p>

<h4 id="第一步写代码并在容器中进行测试">第一步：写代码，并在容器中进行测试</h4>

<ol>
  <li>创建一个目录</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>mkdir manual-build
<span class="nb">cd </span>manual-build
</pre></td></tr></tbody></table>
</div>
</div>

<ol>
  <li>创建一个flask 文件 hello.py</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">escape</span><span class="p">,</span> <span class="n">request</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"name"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="s">'Hello, {escape(name)}! Greetings from a Container'</span>
</pre></td></tr></tbody></table>
</div>
</div>

<ol>
  <li>创建一个执行脚本  start-app.sh</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="nb">cd</span> /app
<span class="nb">export </span><span class="nv">FLASK_APP</span><span class="o">=</span><span class="s2">"hello"</span>
<span class="nb">export </span><span class="nv">FLASK_ENV</span><span class="o">=</span><span class="s2">"development"</span>
<span class="nb">export </span><span class="nv">FLASK_RUN_HOST</span><span class="o">=</span><span class="s2">"0.0.0.0"</span>
flask run
</pre></td></tr></tbody></table>
</div>
</div>

<ol>
  <li>在本地创建一个python容器 名字叫 manual</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><pre><span class="c"># 创建容器</span>
docker create -it --name manual -p 5000:5000 python /bin/bash
<span class="c"># 进入容器并创建目录 /app</span>
docker start -i manual
mkdir /app
<span class="nb">exit</span>  <span class="c"># 退出容器</span>
<span class="c"># 将新建的两个文件拷贝到容器中</span>
docker cp hello.py manual:/app
docker cp start-app.sh manual:/app
docker start -i manual
<span class="nb">cd</span> /app
ls
<span class="c"># 修改执行权限</span>
chmod +x start-app.sh 
<span class="c">#安装 flask</span>
pip install Flask
<span class="c"># 执行脚本, 启动 flask</span>
/app/start-app.sh
<span class="c"># control +c 退出 flask , 退出容器</span>
<span class="c"># exit </span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>打开浏览器 http://localhost:5000  就可以看到 Hello, world! Greetings from a Container</p>

<h4 id="第二步-为修改的容器创建镜像---docker-commit">第二步： 为修改的容器创建镜像 - docker commit</h4>

<p>commit      Create a new image from a container’s changes</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="c"># 将我们修改过的 manual 创建成一个叫做 manual-image 的镜像，版本是 1.0</span>
docker commit manual manual-image:1.0
<span class="c"># 运行新的容器</span>
docker run -it --rm -p 5001:5000 manual-image:1.0
<span class="c"># 进入容器后执行</span>
<span class="nb">cd</span> /app
ls <span class="c"># 新的容器已经包含了 app 目录和下面的两个文件</span>
/app/start-app.sh
</pre></td></tr></tbody></table>
</div>
</div>

<p>打开浏览器 http://localhost:5001 可以看到 新的运行的容器</p>

<h4 id="第三部-让镜像创造出来的容器可以直接运行-flask">第三部： 让镜像创造出来的容器可以直接运行 flask</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="c"># 通过给 docker commit 追加 --change 参数 提供dockerfile 的命令, 让这个镜像的容器创建的时候就会执行脚本</span>
docker commit --change <span class="s2">"CMD /app/start-app.sh"</span> manual manual-image:1.1

<span class="c"># 创建一个新的容器</span>
<span class="c"># 容器启动后就直接执行了脚本，启动了 flask ， 补充需要再进入容器后去启动这个脚本</span>
docker run -it --rm -p 5001:5000 manual-image:1.1
<span class="c"># control + c</span>

</pre></td></tr></tbody></table>
</div>
</div>

<p>访问浏览器 http://localhost:5001</p>

<h3 id="通过-dockerfile-进行镜像自动创建---docker-build">通过 Dockerfile 进行镜像自动创建 - docker build</h3>

<p>build - Build an image from a docker file</p>

<p>镜像创建流程</p>

<ol>
  <li>Create the source code</li>
  <li>Create Dockerfile</li>
  <li>create a container with base image</li>
  <li>create a working directory</li>
  <li>copy the source code to working directory</li>
  <li>install libraries</li>
  <li>install additional softwoare</li>
  <li>commit the container to a new image</li>
  <li>test the new image</li>
</ol>

<h4 id="要手动准备的三个文件">要手动准备的三个文件</h4>

<ul>
  <li>hello.py</li>
  <li>Start-app.sh</li>
  <li>Dockerfile</li>
</ul>

<h4 id="要准备的dockerfile">要准备的Dockerfile</h4>

<pre><code class="language-dockerfile"># 在 manual-build 目录下创建一个 Dockerfile 文件
FROM python:3   # 这是 base image
WORKDIR /app    # 创建工作目录
COPY hello.py .  # copy the source code to working directory
COPY start-app.sh .  # copy the source code to working directory
RUN pip install Flask    # install libraries
CMD ["/bin/bash", "/app/start-app.sh"]    # 设置容器的启动命令
</code></pre>

<h4 id="创建镜像docker-build-并运行">创建镜像docker build 并运行</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="c"># 将当前目录下的内容 build 到新的镜像 中</span>
<span class="c"># -t 指定 tag </span>
docker build -t automated-image:1.0 .  
<span class="c"># 成功后运行容器， 可以直接启动 flask </span>
docker run -it --rm -p 5000:5000 automated-image:1.0 
<span class="c"># docker run -it --rm -p 5000:5000 automated-image:1.0 /bin/bash # 这个命令用/bin/bash 代替原有的命令，不会启动 flask</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>访问 http://localhost:5000</p>

<p>以后每次修改代码后，就执行<code class="language-plaintext highlighter-rouge">docker build</code> ， <code class="language-plaintext highlighter-rouge">docker run</code>  就可以把最新的代码部署到镜像和容器中了</p>

<h4 id="为-dockerfile-创建环境变量">为 dockerfile 创建环境变量</h4>

<ul>
  <li>
    <p>前面手动 build 的方法中， 我们通过 start-app.sh 设置 环境变量并启动 flask</p>
  </li>
  <li>
    <p>在 build image 的时候在 dockerfile 中也可以设置环境变量并启动 flask, 就不需要单独写一个启动脚本了</p>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre>FROM python:3   
WORKDIR /app    
COPY hello.py .     
<span class="c"># COPY start-app.sh .   # 这行就不需要了</span>
RUN pip install Flask 
ENV FLASK_APP <span class="s2">"hello"</span>     <span class="c"># 设置三个环境变量</span>
ENV FLASK_ENV <span class="s2">"development"</span>
ENV FLASK_RUN_HOST <span class="s2">"0.0.0.0"</span>
CMD <span class="o">[</span><span class="s2">"flask"</span>, <span class="s2">"run"</span><span class="o">]</span>    <span class="c"># 设置容器的启动命令， 不再执行脚本，而是直接启动 flask</span>

</pre></td></tr></tbody></table>
</div>
</div>

<p>用新的 Dockerfile 创建镜像，并运行容器</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre>cp Dockerfile Dockerfile.env
<span class="c"># 将Dockerfile.env 内容改成上面的内容</span>
<span class="c"># 重新 build , -f 指定 Dockerfile 的名字， 默认是 Dockerfile</span>
docker build -f Dockerfile.env -t automated-image:1.1 .
docker run -it --rm -p 5000:5000 automated-image:1.1
</pre></td></tr></tbody></table>
</div>
</div>

<p>访问 http://localhost:5000</p>

<h4 id="dockerfile-procedure">Dockerfile Procedure</h4>

<ol>
  <li>Create the Source Code</li>
  <li>Create Dockerfile
    <ol>
      <li>Define Base Image</li>
      <li>define a working directory</li>
      <li>Copy source code to working directory</li>
      <li>set environment variables</li>
      <li>Install libraries and software</li>
      <li>Set a start-up command</li>
    </ol>
  </li>
  <li>Build the image</li>
  <li>Test the image - docker run</li>
</ol>

<h3 id="dockerfile-命令---from">Dockerfile 命令 - FROM</h3>

<ul>
  <li>FROM 必须放在第一行，否则会报错</li>
  <li>FROM 可以有多行， 定义多个 base image</li>
  <li>定义了 base image</li>
</ul>

<h4 id="一些-from-的例子">一些 FROM 的例子</h4>

<pre><code class="language-dockerfile">FROM python  # 默认是 latest tag
FROM ubuntu:16.04 # 可以指定版本
FROM 37016175/flask-hello:1.0  # 镜像名可以带斜杠，斜杠前面是docker hub的账户名，后面是镜像名
# 通过 image ID指定进行用哪个 Python 版本的镜像
FROM
python@sha256:7e6c00cc553fdce06c1bcfcbf34c73a0f3623a8fc9ce88c8fb91671f2cbc0dab  
FROM docker.elastic.co/elasticsearch/elasticsearch:7.0.0  # 从非 Docker hub 拿镜像
FROM private-registry.mycompany.com:5000/my-pyt   # 从私有镜像库拿镜像


</code></pre>

<h4 id="创建一个dockerfile---dockerfilepython374">创建一个Dockerfile - Dockerfile.python.3.7.4</h4>

<pre><code class="language-dockerfile">FROM python:3.7.4
</code></pre>

<p>创建镜像和容器</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="c"># 创建一个本地的 python.3.7.4 的镜像</span>
docker build -t python.3.7.4 -f Dockerfile.python.3.7.4 .
<span class="c"># 创建容器, 并进入 python console</span>
docker run -it --rm python.3.7.4

</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="多个-from-的例子---dockerfilefrom3">多个 FROM 的例子 - Dockerfile.from.3</h4>

<pre><code class="language-dockerfile">FROM alpine
FROM ubuntu:16.04
FROM python
</code></pre>

<p>创建镜像和容器</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre>docker build -t who-knows -f Dockerfile.from.3 .
docker run -it --rm who-knows

<span class="c"># exit()</span>
<span class="c"># </span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="dockerfile-命令---workdir-copy-add">Dockerfile 命令 - WORKDIR, COPY, ADD</h3>

<h4 id="workdir-定义了容器的工作目录">WORKDIR 定义了容器的工作目录</h4>

<p>比如在 Dockerfile 中设置了 <code class="language-plaintext highlighter-rouge">WORKDIR /app</code>, 那么，镜像在创建容器的时候就会建立这个目录。 如果目录已经存在，在建立容器的时候会报错。如果想建立两层目录，需要</p>

<pre><code class="language-dockerfile"># 想要设置 /app/subdir 作为工作目录
WORKDIR /app
WORKDIR subdir

</code></pre>

<ul>
  <li>
    <p>COPY 是从当前工作电脑 copy 文件到镜像中， 未来镜像创建容器的时候会把文件 copy 到工作目录下</p>

    <pre><code class="language-dockerfile">COPY hello.py .    # 拷贝文件到工作目录
COPY hello.py /app/hello.py    # 拷贝到指定目录，定制指定名字
COPY hello.py start-app.Sh /app/  # 将多个文件拷贝到指定目录， 文件用空格分隔，目录后面带斜杠；不带斜杠，会被被拷贝成文件名叫 app 的文件
COPY /hello.py /very/long/path/to/a/directory/  # 拷贝当前电脑的绝对路径下文件
COPY *.py sources/    # 拷贝当前工作目录下所有以.py 结尾的文件到工作目录下的 sources 目录下；目的目录前面没有斜杠表示是工作目录
COPY . /app/  # 拷贝当前目录下的所有文件和目录到 /app/目录下
COPY . .  # 拷贝当前目录下的所有文件和目录到 工作目录
COPY ["name with spaces.py, "/app"] # 如果文件名有空格， 用这种方式
  
  
</code></pre>
  </li>
</ul>

<h4 id="dockerignore-文件">.dockerignore 文件</h4>

<p>用来配置需要忽略的copy 文件，防止不许忘被拷贝的文件拷贝到镜像中</p>

<p>下面是一个例子</p>

<pre><code class="language-dockerfile">Dockerfile*  # 所有以Dockerfile 开头的文件被忽略
*.pyc        # 所有.pyc 文件被忽略
!important.pyc   # 除了 important.pyc ,这个文件可以被拷贝
#comments
</code></pre>

<p>另一个例子</p>

<pre><code class="language-dockerfile"># 只有 mysite 目录和 mysite_nginx.conf 可以被拷贝，其他的都不行
*
!mysite
!mysite_nginx.conf
</code></pre>

<h4 id="copy-的例子">COPY 的例子</h4>

<pre><code class="language-dockerfile">COPY --chown=web:web html/ /usr/local/html/  # 拷贝html/ 到 /usr/local/html 目录， 并将user:group权限设置成 web:web 
COPY --chown=root . .  # 将当前目录的所有文件和目录拷贝到工作目录， 并user:group 都设置成 root
COPY --chown=100:100 hello.py /app/ # 将 hello.py 拷贝到 /app/目录下，并设置 user:group ID为 100:100 的 ID
</code></pre>

<h4 id="add">ADD</h4>

<p>和 COPY 类似，但是功能更强大</p>

<ul>
  <li>
    <p>将本地的压缩包进行解压并 build</p>
  </li>
  <li>
    <p>通过 Git URL , clone 一个项目，并 build</p>
  </li>
</ul>

<pre><code class="language-dockerfile">ADD https//raw.githubusercontent.Com/pythonincontainers/flask-hello/master/flask-hello.py /app

</code></pre>

<p>一个例子：远程clone github，然后用下载文件中的 Dockerfile build image 的例子</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="c"># gitclone 之后，  用下载文件中的 Dockerfile build 一个 image flask-hello</span>
<span class="c"># 前提是下载的文件当中必须有 Dockerfile</span>
docker build -t flask-hello https://github.com/pythonincontainers/flask-hello.git


</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="dockerfile-命令---run">Dockerfile 命令 - RUN</h3>

<ul>
  <li>RUN 就是让镜像生成容器的时候，执行一个命令</li>
  <li>该命令必须是镜像里面自带的命令，命令不存在会报错</li>
  <li>RUN 只能运行非交互命令，不会有 user input , 但是会有输出，输出是在 docker build 的时候输出</li>
  <li>如果命令执行出现错误， 那么build 会失败</li>
  <li>如果执行一个后台命令，比如 <code class="language-plaintext highlighter-rouge">RUN (sleep 10; echo "i am late") &amp;</code> 不会看到预想的结果， 因为 docker build 会另外已启动一个进程去执行这个命令</li>
</ul>

<p>使用方法</p>

<pre><code class="language-dockerfile">RUN command argument1 argument2
RUN ["command", "argument1", "argument2"]
# command 必须是在镜像生成的容器中已经存在的命令，否则报错
</code></pre>

<h4 id="例子--写入追加文件--dockerfileredirect">例子- 写入，追加文件:  Dockerfile.redirect</h4>

<pre><code class="language-dockerfile">FROM python
RUN echo "This is multiline" &gt; /tmp/file
RUN echo "message" &gt;&gt; /tmp/file
RUN more /tmp/file
</code></pre>

<p>运行 build</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>docker build -t redirect -f Dockerfile.redirect .
<span class="c"># build 过程中会有这两行内容</span>
<span class="c"># This is multiline</span>
<span class="c"># message</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="例子-管道符命令-dockerfilepipe">例子-管道符命令: Dockerfile.pipe</h4>

<pre><code class="language-dockerfile">FROM python
RUN find / -name "python*" | wc -l   # 寻找所有以 python 开头的文件的个数
</code></pre>

<p>运行 build</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>docker build -t pipe -f Dockerfile.pipe . 
<span class="c"># 输出了计数 148 </span>
</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="例子---把默认-bash-命令改为-python-命令行--dockerfileshell">例子 - 把默认 bash 命令改为 python 命令行  Dockerfile.shell</h4>

<p>python 镜像中的环境变量位置</p>

<p><code class="language-plaintext highlighter-rouge">/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</code></p>

<pre><code class="language-dockerfile">FROM python
SHELL ["/usr/local/bin/python", "-c"]
RUN print("Hello at Build time")
</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>docker build -t shell -f Dockerfile.shell .
<span class="c"># 输出了 Hello at Build time</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="例子---下载安装软件">例子 - 下载，安装软件</h4>

<p>Dockerfile.mysql</p>

<pre><code class="language-dockerfile">FROM python
RUN apt-get update &amp;&amp; apt-get install -y default-mysqi-client  
RUN mysql --version
RUN pip install Django mysqlclient
</code></pre>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>docker build -t mymysql -f Dockerfile.mysql .

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="镜像的层---image-layers">镜像的层 - Image Layers</h3>

<ul>
  <li>FROM, COPY, ADD, RUN 会增加新的层, 执行上面 build mysql 的时候就可以看到有 4 层，每层分别被放在缓存中, 增加执行效率 （using cache ）</li>
  <li>WORKDIR, ENV, ENTRYPOINT, CMD, LABEL 等修改镜像的 Metadata</li>
</ul>

<h3 id="dockerfile-命令---env-label-user">Dockerfile 命令 - ENV, LABEL, USER</h3>

<h4 id="env">ENV</h4>

<p>语法</p>

<pre><code class="language-dockerfile">ENV name value
ENV name1=value1 name2=value2 ...
</code></pre>

<p>例子</p>

<pre><code class="language-dockerfile"># 定义一个数据库链接
ENV SQLALCHEMY_DATABASE_URI "postgresql://kris:secret@postgres/mydatabase"
ENV FLASK_APP=hello FLASK_RUN_HOST="0.0.0.0"  # 定义两个变量
ENV PATH $PATH:/app    # 追加 /app 到 $PATH 变量中
ENV PATH "${PATH}${PATH:-/bin}:/app"  ENV PATH $PATH:/app    # 追加 /app 到 $PATH 变量中
ENV PATH "${PATH}${PATH:+:}/app"   # 追加 /app 到 $PATH 变量中
ENV EMPTY ""  # 变量不能从 Dockerfile 中删除， 但是可以被设置为空

</code></pre>

<p>在创建容器的时候，也可以通过参数设置变量, 或者覆盖之前在 dockerfile 中设置过的变量</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>docker run --env <span class="nv">var</span><span class="o">=</span>value ...
</pre></td></tr></tbody></table>
</div>
</div>

<p>一个完整的例子 - Dockerfile.var</p>

<pre><code class="language-dockerfile">FROM pyhthon
ENV NEW hello
</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="c"># 创建一个叫做 var 的镜像</span>
docker build -t var -f Dockerfile.var .
<span class="c"># var 是镜像， 最后 env 是进入容器后执行的命令，这里 env 会打印出来所有环境变量，包含在 Dockerfile 中定义的变量</span>
docker run --rm var env  
<span class="c"># 这里执行 run 的时候用--env 参数复写了 NEW 这本变量</span>
docker run --rm --env <span class="nv">NEW</span><span class="o">=</span><span class="s2">"Hi there"</span> var env  


</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="user">USER</h4>

<ul>
  <li>
    <p>Dockerfile 中的命令默认是 root 用户权限执行的</p>
  </li>
  <li>
    <p>USER 命令可以改变当前用户的 ID</p>
  </li>
</ul>

<p>Dockerfile.user</p>

<pre><code class="language-dockerfile"># 一个例子，创建 mysql 用户和组，然后切换成 mysql 用户，然后查看该用户的 id
FROM python
RUN groupadd mysql &amp;&amp; useradd -g mysql mysql
USER mysql
# USER mysql:root  # 可以同时设置用户和组
RUN id
</code></pre>

<p>创建一个叫做 user 的  image</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>docker build -t user -f Dockerfile.user .
<span class="c"># build 过程中可以看到 myswl 的 user id 的输出</span>
docker run --rm user id  <span class="c"># 创建容器， 并执行 id 命令， 可以看到和刚才一样的输出</span>

</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="label">LABEL</h4>

<ul>
  <li>
    <p>Dockerfile 可以有任意行 LABEL</p>
  </li>
  <li>没有强制的 lables</li>
  <li>label 是给镜像打标签， 为了以后好找，或者好归类</li>
</ul>

<p>Dockerfile.label</p>

<pre><code class="language-dockerfile">FROM python
LABEL maintainer=lidalong@cn.ibm.com
LABEL com.mycompany.version="0.7"
LABEL com.mycompany.production="true"
</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre>docker build -t label -f Dockerfile.label .
docker inspect -f <span class="s2">"{{json .Config.Labels}}"</span> label  <span class="c"># 查看创建的 Labels </span>
docker image --filter <span class="s2">"label=com.mycompany.production"</span>


</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="dockerfile-命令---volume-and-expose">Dockerfile 命令 - VOLUME and EXPOSE</h3>

<ul>
  <li>当我们创建容器的时候， 就会根据 Dockerfile 中定义的 VOLUME , 给容器设置 mount 的点</li>
  <li>用 Volume 的好处
    <ul>
      <li>性能更好，因为存储在容器外</li>
      <li>数据持久， 不会因为容器毁掉而丢失数据</li>
      <li>让数据无状态， 和容器无关</li>
    </ul>
  </li>
</ul>

<h4 id="语法">语法</h4>

<pre><code class="language-dockerfile">VOLUME /data  # 自动创建一个 volumen 叫做 data . Volume mount 到 /data
VOLUME ["/data"]  # 同上
VOLUME /web/ /static  # Volume mount 两个点
</code></pre>

<h4 id="例子-dockerfilevol">例子-Dockerfile.vol</h4>

<pre><code class="language-dockerfile">FROM python
VOLUME /data   # 这里是要让镜像在创建容器的时候创建一个/data 的 mount点，以后在创建容器的时候可以用这个点 mount volume
COPY hello.py /data/  
</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre>mkdir dockerfile-vol  <span class="c">#创建一个本地目录</span>
<span class="nb">cd </span>dockerfile-vol   <span class="c"># 进入目录</span>
docker build -t vol -f Dockerfile.vol .  <span class="c">#在当前目录下创建镜像 vol</span>
<span class="c"># 输出  VOLUME /data</span>
docker inspect -f <span class="s2">"{{json.Config.Volumes}}"</span>   <span class="c"># 查看进项的 Volume 配置</span>
<span class="c"># 输出 {"/data":{}}</span>
docker volume create mydata  <span class="c"># 创建一个叫做 data 的 volume</span>
docker run -it --name myvol -v data:/data vol bash <span class="c"># 创建一个容器， mount 上新建的 volume</span>
<span class="c"># 进入容器</span>
<span class="nb">cd</span> /data
ls -la
mv hello.py hello.old
<span class="nb">echo</span> <span class="s2">"One more line"</span> &gt;&gt; hello.old
<span class="nb">exit</span>
<span class="c"># 退出 docker</span>
docker rm myvol <span class="c"># 删除这个容器</span>
docker volume ls <span class="c"># volume 还在</span>
docker run -it --rm -v mydata:/mnt vol bash <span class="c"># 创建另一个容器, </span>
<span class="c"># 进入容器， 可以看到 hello.py 还在 /data 下面，</span>
<span class="c"># hello.old 在 /mnt 下面</span>


</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="不用--v-的情况">不用 -v 的情况</h4>

<ul>
  <li>不指定 -v 参数， docker 会自动创建一个匿名存储，并 mount 到容器 /data 目录上</li>
  <li>如果带上 –rm 参数, 那么当退出容器的时候， 包括容器和匿名存储都会被删除</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre>docker rm myvol 
docker volume rm mydata
docker run -it --name myvol vol bash  <span class="c"># 不用 -v 一样可以创建volumen 并 mount 到 /data 目录上</span>
<span class="nb">exit
</span>docker volume list 
<span class="c"># 输出 可以看到一个匿名的存储</span>
<span class="c"># DRIVER    VOLUME NAME</span>
<span class="c"># local     00b81be043af1dcb4e94fabaf32ba456bd401ba76bd07f3f0a758d0da3c3d00f</span>

docker rm myvol 
docker volume rm 00b81be043af1dcb4e94fabaf32ba456bd401ba76bd07f3f0a758d0da3c3d00f
docker run -it --rm --name myvol vol bash
<span class="nb">exit</span>
<span class="c"># 这时候不需要删除容器和 volume, 他们已经在退出容器的时候被自动删除了</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="开发本机目录-mount-到-容器">开发本机目录 mount 到 容器</h4>

<ul>
  <li>可以把本机目录 mount 到 /data 目录上， 但是不会有 hello.py 文件的 copy</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>docker run -it --name myvol -v <span class="k">${</span><span class="nv">PWD</span><span class="k">}</span>/temp:/data vol bash
</pre></td></tr></tbody></table>
</div>
</div>

<p>另一个例子 Dockerfile.vol2</p>

<ul>
  <li>如果要初始化文件，记得要把 RUN 命令 放在 VOLUME前面，否则可能会丢失对数据的操作</li>
</ul>

<pre><code class="language-dockerfile">FROM python
COPY start-app.sh /data/
RUN echo "One more line" &gt;&gt; /data/start-app.sh
VOLUME /data
COPY hello.py /data/
RUN echo "One more line" &gt;&gt; /data/hello.py
RUN more /data/start-app.sh
RUN more /data/hello.py
</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre>docker build -t vol2 -f Dockerfile.vol2 .
docker run -it --name myvol2 vol2 bash
<span class="nb">cd</span> /data
more hello.py
more start-app.sh
<span class="nb">exit
</span>docker volume list

</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="expose">EXPOSE</h4>

<ul>
  <li>定期imange 创建的容器的对外暴露的端口号</li>
</ul>

<p>语法</p>

<pre><code class="language-dockerfile">EXPOSE &lt;port&gt;
EXPOSE &lt;port&gt;/&lt;protocol&gt;
</code></pre>

<p>例子</p>

<pre><code class="language-dockerfile">EXPOSE 22/tcp 
EXPOSE 80 443
EXPOSE 1234/udp
</code></pre>

<p>例子 - Dockerfile.expose</p>

<pre><code class="language-dockerfile">FROM python
WORKDIR /app
COPY hello.py .
COPY start-app.sh .
RUN pip install Flask
CMD ["/bin/bash", "start.app.sh"]
EXPOSE 5000
</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre>docker build -t hello-port -f Dockerfile.expose .
docker inspect -f <span class="s2">"{{json .Config.ExposedPorts}}"</span> hello-port
docker run -d --name my-hello-port -P hello-port  <span class="c"># -P 好像并没有给 5000 指定一个主机的端口号</span>
<span class="c"># -P 自动把所有容器的端口都和 hots 主机进行 mapping </span>
<span class="c"># docker run -d --name my-hello-port -p 5000:5000 hello-port</span>
docker ps -a

</pre></td></tr></tbody></table>
</div>
</div>

<p>访问对应的 local 地址：端口号</p>

<h3 id="docker-命令---entrypoint-和-cmd">Docker 命令 - ENTRYPOINT 和 CMD</h3>

<h4 id="entrypoint-和-cmd-是容器启动后要执行的命令">ENTRYPOINT 和 CMD 是容器启动后要执行的命令</h4>

<ul>
  <li>Entrypoint 就是 命令 + 第一个参数</li>
  <li>cmd 就是 后面的参数</li>
  <li>entrypoint 和 cmd 经常组合使用，</li>
  <li>很多时候 cmd 被设置为空； 也有很多时候，entrypoint 是空的，只用cmd</li>
  <li>从 base 镜像继承</li>
  <li>可以在 Dockerfile 中重写</li>
  <li>可以在 run 的时候被覆盖</li>
  <li>在每次容器启动的时候执行</li>
  <li>多个 Entrypoint的话，最后一个生效</li>
  <li>多个 CMD 的话，最后一个生效</li>
</ul>

<h4 id="例子-dockerfilesimple">例子: Dockerfile.simple</h4>

<pre><code class="language-dockerfile">FROM python
ENTRYPOINT ["python"]
CMD ["--version"]
# CMD ["-c", "print('hello world')"]
</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>docker build -t simple -f Dockerfile.simple .
docker inspect simple  <span class="c"># 可以看到image 定义的 entrypoint 和 cmd </span>
docker run --rm simple  <span class="c"># 可以看到版本信息</span>

</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="例子---dockerfileentry">例子 - Dockerfile.entry</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre><span class="nb">cd</span> ..
git clone https://github.com/pythonincontainers/entrypoint-cmd
<span class="nb">cd </span>entrypoint-cmd
<span class="c"># 查看 Dockerfile 文件 Dockerfile.entry</span>
<span class="c">#FROM python</span>
<span class="c">#RUN pip install psutil</span>
<span class="c">#WORKDIR /app/</span>
<span class="c">#COPY args.py /app/</span>
<span class="c">#ENTRYPOINT ["python"]</span>
<span class="c">#CMD ["args.py"]</span>

docker build -t entry -f Dockerfile.entry .
docker run --rm entry

<span class="c"># 执行的命令输出的就是 </span>
<span class="c">#This process PID is:  1</span>
<span class="c">#This process executable is:  /usr/local/bin/python3.9</span>
<span class="c">#This process sys.argv is:  ['args.py']</span>
<span class="c">#This process command line is:  ['python', 'args.py']</span>
<span class="c">#List of all processes in the current Container:</span>
<span class="c">#PID= 1  PPID= 0  CMDLINE= ['python', 'args.py']</span>

</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="例子---dockerfileparent">例子 - Dockerfile.parent</h4>

<ul>
  <li>先通过 Dockerfile.parent 创建一个parent 镜像，</li>
  <li>然后在用 Dockerfile.child 导入 parent 镜像继承 parent 的 Dockerfile 中的内容</li>
  <li>然后在通过 Dockerfile.child 创建一个容器，就可以使用 Dockerfile.parent 中定义的 Entrypoint 和 CMD 了</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></td><td class="code"><pre><span class="c"># Dockerfile.parent</span>
<span class="c"># FROM python</span>
<span class="c"># RUN pip install psutil</span>
<span class="c"># WORKDIR /app/</span>
<span class="c"># COPY args.py /app/</span>
<span class="c"># ENTRYPOINT ["python"]</span>
<span class="c"># CMD ["args.py","one"]</span>


<span class="c"># Dockerfile.child</span>
<span class="c"># FROM parent</span>
<span class="c"># RUN date</span>

docker build -t parent -f Dockerfile.parent .  <span class="c"># 创建 parent 镜像</span>
docker build -t child -f Dockerfile.child .  <span class="c"># 创建 child 镜像，继承自 parent</span>
docker inspect -f <span class="s2">"Entrypoint={{.Config.Entrypoint}} CMD={{.Config.Cmd}}"</span> child <span class="c"># 查看镜像中的配置</span>
<span class="c"># 输出</span>
<span class="c"># Entrypoint=[python] CMD=[args.py one]</span>

docker run --rm child
<span class="c"># 输出</span>
<span class="c">#This process PID is:  1</span>
<span class="c">#This process executable is:  /usr/local/bin/python3.9</span>
<span class="c">#This process sys.argv is:  ['args.py', 'one']</span>
<span class="c">#This process command line is:  ['python', 'args.py', 'one']</span>
<span class="c">#List of all processes in the current Container:</span>
<span class="c">#PID= 1  PPID= 0  CMDLINE= ['python', 'args.py', 'one']</span>

</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>Dockerfile.child 中可以直接继承或者复写 Dockerfile.parent 中定义的Entrypoint 和 CMD 的内容</li>
</ul>

<h4 id="docker-run-可以通过参数复写-entrypoint">docker run 可以通过参数复写 entrypoint</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>docker fun -it --rm --entrypoint<span class="o">=</span><span class="s2">""</span> child /bin/bash

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="dockerfile-的-arg-参数">Dockerfile 的 ARG 参数</h3>

<ul>
  <li>ARG 用于在 Dockerfile中定义变量，定义的变量可以重复使用。</li>
  <li>ARG 定义的值可以用于一下命令，除了 ENTRYPOINT 和 CMD
    <ul>
      <li>FROM</li>
      <li>RUN</li>
      <li>ENV</li>
      <li>COPY</li>
      <li>ADD</li>
      <li>EXPOSE</li>
      <li>LABEL</li>
      <li>STOPSIGNAL</li>
      <li>USER</li>
      <li>VOLUME</li>
      <li>WORKDIR</li>
    </ul>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre>git clone https://github.com/pythonincontainers/dockerfile-arg
<span class="nb">cd </span>dockerfile-arg/
<span class="c">#查看 Dockerfile.arg</span>
<span class="c"># ARG Python_Image_Name=python</span>
<span class="c"># ARG Python_Image_Tag=latest</span>
<span class="c"># FROM $Python_Image_Name:$Python_Image_Tag</span>
<span class="c"># ARG Flask_Ver=1.0.2</span>
<span class="c"># RUN pip install flask==$Flask_Ver</span>
<span class="c"># WORKDIR /app</span>
<span class="c"># COPY hello-v2.py .</span>
<span class="c"># CMD ["python","hello-v2.py"]</span>

<span class="c"># 创建image时覆盖 arg 参数</span>
docker build -t args -f Dockerfile.arg --build-arg <span class="nv">Flask_Ver</span><span class="o">=</span>1.0.0 .
docker run -it --rm -p 5000:5000
docker inspect args
</pre></td></tr></tbody></table>
</div>
</div>

<p>http://localhost:5000/test/yodas</p>

<p>查看定义过的 args</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>docker inspect args
docker history args
</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="用环境变量来控制-args">用环境变量来控制 args</h4>

<ul>
  <li>在 Dockerfile 中通过 args 定义 Env , 然后在 python 文件中通过 import os 来调用这些 env 环境变量</li>
  <li>Dockerfile 中， FROM 会导入基础镜像，有可能会覆盖掉 FROM之前定义过的 arg, 所以 FROM 之后要重新定义 args</li>
</ul>

<p>Dockerfile.env</p>

<pre><code class="language-dockerfile">ARG Python_Image_Name=python
ARG Python_Image_Tag=latest
FROM $Python_Image_Name:$Python_Image_Tag
ARG Flask_Ver=1.0.2
ARG Python_Image_Name=python
ARG Python_Image_Tag=latest
ENV PYTHON_IMAGE_NAME $Python_Image_Name
ENV PYTHON_IMAGE_TAG $Python_Image_Tag
ENV FLASK_VER $Flask_Ver
RUN pip install flask==$Flask_Ver
WORKDIR /app
COPY hello-v2.py .
CMD ["python","hello-v2.py"]
</code></pre>

<p>hello-v2.py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre></td><td class="code"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">import</span> <span class="nn">os</span>  <span class="c"># 导入 os</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">'Flask Hello world! Version 1</span><span class="se">\n</span><span class="s">'</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/test/&lt;username&gt;'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">username</span> <span class="o">==</span> <span class="s">""</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">'Testing hidden functionality ;)</span><span class="se">\n</span><span class="s">'</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">'Greetings Master '</span> <span class="o">+</span> <span class="n">username</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">image_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'PYTHON_IMAGE_NAME'</span><span class="p">]</span>  <span class="c"># 通过 os 调用 Dockerfile 中定义的环境变量</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">image_name</span> <span class="o">=</span> <span class="s">'unspecified'</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">image_tag</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'PYTHON_IMAGE_TAG'</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">image_tag</span> <span class="o">=</span> <span class="s">'unspecified'</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">flask_ver</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'FLASK_VER'</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">flask_ver</span> <span class="o">=</span> <span class="s">'unspecified'</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Base Image is "</span> <span class="o">+</span> <span class="n">image_name</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="n">image_tag</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Flask version installed is "</span><span class="o">+</span><span class="n">flask_ver</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'0.0.0.0'</span><span class="p">)</span>

</pre></td></tr></tbody></table>
</div>
</div>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>docker build -t args -f Dockerfile.env --build-arg <span class="nv">Python_Image_Name</span><span class="o">=</span>centos/python-36-centos7 .
docker run -it --rm -p 5000:5000 args

</pre></td></tr></tbody></table>
</div>
</div>

<p>http://localhost:5000</p>

<h4 id="用-args-为-label-打标签">用 ARGS 为 LABEL 打标签</h4>

<ul>
  <li>LABEL 的用处是让开发人员可以通过标签快速查找想要的镜像信息</li>
  <li>通过 Arg 为 Label 打标签可以更高效</li>
</ul>

<p>Dockerfile.label</p>

<pre><code class="language-dockerfile">ARG Python_Image_Name=python
ARG Python_Image_Tag=latest
FROM $Python_Image_Name:$Python_Image_Tag
ARG Flask_Ver=1.0.2
ARG Python_Image_Name=python
ARG Python_Image_Tag=latest
ENV PYTHON_IMAGE_NAME $Python_Image_Name
ENV PYTHON_IMAGE_TAG $Python_Image_Tag
ENV FLASK_VER $Flask_Ver
RUN pip install flask==$Flask_Ver
WORKDIR /app
COPY hello-v2.py .
CMD ["python","hello-v2.py"]
LABEL com.mycompany.image-name $Python_Image_Name
LABEL com.mycompany.image-tag $Python_Image_Tag
LABEL com.mycompany.python.flask-ver $Flask_Ver
LABEL com.mycompany.maintainer kris@mycompany.com
LABEL com.mycompany.source-repo dockerfile-ag

</code></pre>

<h3 id="创建可重用的python镜像">创建可重用的python镜像</h3>

<p>容器化的 python 应用需要配置的内容包括</p>

<ul>
  <li>配置文件</li>
  <li>环境变量</li>
  <li>命令行选项和参数</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre>git clone https://github.com/pythonincontainers/reusable
<span class="nb">cd </span>reusable
<span class="c"># 查看 Dockerfile.env</span>
<span class="c"># FROM python</span>
<span class="c"># WORKDIR /app</span>
<span class="c"># COPY config-reader.py /app/</span>
<span class="c"># ENV CONFIG_COLOR white</span>
<span class="c"># ENV CONFIG_SHAPE triangle</span>
<span class="c"># ENTRYPOINT ["python", "config-reader.py"]</span>
<span class="c"># CMD ["--env"]</span>

docker build -t env -f Dockerfile.env .
docker run -it --rm env  <span class="c"># 创建容器并使用定义的变量</span>
docker run -it --rm -e <span class="nv">CONFIG_SHAPE</span><span class="o">=</span>dot env  <span class="c"># 覆盖一个环境变量</span>



</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="用-defaultini-来运行-python-命令">用 default.ini 来运行 python 命令</h4>

<ul>
  <li>
    <p>好处是可以将开发用的环境参数写到 .ini 文件中， 方便环境变量</p>
  </li>
  <li>
    <p>命令语法  <code class="language-plaintext highlighter-rouge">python xxx.py --file default.ini</code></p>
  </li>
  <li>
    <p>方法是创建一个.ini 文件并配置， 然后通过 Dockerfile 把内容引入 image</p>
  </li>
</ul>

<pre><code class="language-dockerfile"># 查看 Dockerfile.file
FROM python
WORKDIR /app
COPY config-reader.py /app/
COPY configs/default.ini /app/
ENTRYPOINT ["python", "config-reader.py"]
CMD ["--file", "default.ini"]
</code></pre>

<p>deault.ini</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre>[DEFAULT]
color = grey
shape = line

[db_settings]
host = db
port = 3307
database = mydb
username = dbuser
password = dbpass
</pre></td></tr></tbody></table>
</div>
</div>

<p>创建镜像并运行容器</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><pre>docker build -t file -f Dockerfile.file .
docker run -it --rm file
<span class="c"># 输出</span>
<span class="c">#reading configuration from Config File  default.ini</span>
<span class="c">#"color" =  grey</span>
<span class="c">#"shape" =  line</span>
<span class="c">#Final configuration is: "color" =  grey , "shape" =  line</span>

<span class="c"># 开发环境中可以用本地环境的配置信息代替镜像中预定义的信息来使用，方便开发</span>
docker run -it --rm -v <span class="k">${</span><span class="nv">PWD</span><span class="k">}</span>/configs/blue_circle.ini:/app/default.ini file
<span class="c"># 输出</span>
<span class="c">#Reading configuration from Config File  default.ini</span>
<span class="c">#"color" =  blue</span>
<span class="c">#"shape" =  circle</span>
<span class="c">#Final configuration is: "color" =  blue , "shape" =  circle</span>

<span class="c"># 直接在 Dockerfile 中定义参数</span>
docker build -t args -f Dockerfile.args .
docker run -t --rm args
docker run -t --rm args --color <span class="s2">"ye4llow"</span> --shape <span class="s2">"banana"</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>###</p>

<h3 id="镜像创建-build-time-与-run-time">镜像创建 Build time 与 Run time</h3>

<p>Build 的流程</p>

<ul>
  <li>创建目录</li>
  <li>Copy 文件和目录到镜像中</li>
  <li>修改元数据</li>
  <li>安装 linux 包</li>
  <li>安装 python 类库</li>
  <li>定义启动命令</li>
</ul>

<p>获取实验代码</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>git clone https://github.com/pythonincontainers/buildtime-runtime
<span class="nb">cd </span>buildtime-runtime

</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="创建镜像---runtime">创建镜像 - runtime</h4>

<ul>
  <li>这样创建的镜像，每次 run 容器的时候才会去下载必要的包</li>
  <li>风险是也许几年后，这些包就不会被维护，无法下载了</li>
  <li>run 容器也需要耗费一定的时间</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre><span class="c"># 查看 Dockerfile.runtime</span>
<span class="c"># FROM python:3.7.3</span>
<span class="c"># WORKDIR /django-mysite</span>
<span class="c"># COPY . .</span>
<span class="c"># CMD ["/bin/bash", "run-server.sh"]</span>

<span class="c"># 查看 run-server.sh</span>
<span class="c"># #! /bin/bash</span>
<span class="c"># pip install -r requirements.txt</span>
<span class="c"># mkdir -p /data</span>
<span class="c"># python manage.py migrate</span>
<span class="c"># /bin/bash create-admin.sh</span>
<span class="c"># python manage.py runserver 0.0.0.0:8000</span>

docker build -t runtime -f Dockerfile.runtime .  <span class="c"># 创建镜像</span>
docker run -it --rm -p 8000:8000 runtime  <span class="c"># 创建容器</span>
<span class="c"># 在创建容器过程中会下载 Django， sqlight , 迁移数据， 配置管理员， 设置数据库，启动 django 服务</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>http://0.0.0.0:8000</p>

<p>http://localhost:8000/admin/login/</p>

<p>admin admin</p>

<p>创建 1 个问题和几个选项</p>

<p>访问 http://localhost:8000/polls/ 提交问卷</p>

<p>control + c 停掉容器</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="c"># 一旦删除容器后， 数据都没有了， 等重建容器的时候，需要再做一遍所有的初始化工作，比较耗时</span>
docker rm -f runtime
</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="创建镜像---buildtime">创建镜像 - buildtime</h4>

<ul>
  <li>通过 build time 创建镜像，可以节省创建容器的时间</li>
  <li>好处是需要下载的内容在 build 镜像的时候就下载好，整合到镜像中了</li>
</ul>

<pre><code class="language-dockerfile"># 查看 Dockerfile.buildtime
# Dockerfile 中就把之前 run-server.sh 中的工作做掉了
FROM python:3.7.3
WORKDIR /django-mysite
COPY . .
ARG DJANGO_VER=2.2.1
RUN pip install -r requirements.txt
RUN mkdir -p /data &amp;&amp; python manage.py migrate
RUN bash create-admin.sh
VOLUME /data  # 创建一个新的 volume ， mount 到 /data 目录， 防止数据丢失
CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]
</code></pre>

<p>创建镜像</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>docker build -t buildtime -f Dockerfile.buildtime . <span class="c"># build 会下载所需的内容，并进行数据库初始化等操作</span>
docker run -it --rm -v buildtime-vol:/data -p 8000:8000 buildtime <span class="c"># 我们没有创建过 buildtime-vol， 这里会自动帮我们创建</span>
<span class="c"># 容器创建速度会非常快</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>http://0.0.0.0:8000</p>

<p>http://localhost:8000/admin/login/</p>

<p>admin admin</p>

<p>创建 1 个问题和几个选项</p>

<p>访问 http://localhost:8000/polls/ 提交问卷</p>

<p>control + c 停掉容器</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="c"># 同样的命令重新创建容器， 数据都还在</span>
docker run -it --rm -v buildtime-vol:/data -p 8000:8000 buildtime 
</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="一个极端的例子">一个极端的例子</h4>

<p>用一行 CMD 来完成所有的配置</p>

<pre><code class="language-dockerfile">FROM python:3.7.3
CMD ["/bin/bash", "-c", "git clone https://github.com/pythonincontainers/buildtime-runtime; cd buildtime-runtime; source run-server.sh"]

</code></pre>

<h3 id="build-更小的镜像">Build 更小的镜像</h3>

<ul>
  <li>Python 基础镜像的内容包含了大量开发工具, 对于开发阶段比较有用，但是对于单纯的运行Python环境来说没有必要
    <ul>
      <li>300M+ 的系统类库</li>
      <li>600M+ 的工具在/usr/bin 下面 （C or C++）</li>
    </ul>
  </li>
  <li>保持镜像的小尺寸有很多好处</li>
  <li>省钱，省时间，省空间</li>
  <li>https://hub.docker.com/_/python 可以找到不同尺寸的 python 镜像， 包括了 slim 和 alpine</li>
</ul>

<p>获取演示代码</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>git clone https://github.com/pythonincontainers/smaller
<span class="nb">cd </span>smaller
</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="基于标准python-镜像-的-image-创建">基于标准Python 镜像 的 image 创建</h4>

<pre><code class="language-dockerfile">FROM python:3.7.3
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
CMD ["python","factors_flask.py"]
</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre>docker build -t factors_flask:standard -f Dockerfile.standard .
docker run -it --rm -p 5000:5000 factors_flask:standard
<span class="c"># 访问 http://localhost:5000/12</span>

<span class="c"># 查看镜像大小 - 940M</span>
docker images factors_flask
<span class="c"># REPOSITORY      TAG        IMAGE ID       CREATED         SIZE</span>
<span class="c"># factors_flask   standard   cc61aadd153a   3 minutes ago   940MB</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="基于-python-slim-版本的镜像创建">基于 Python Slim 版本的镜像创建</h4>

<pre><code class="language-dockerfile">FROM python:3.7.3-slim
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
CMD ["python","factors_flask.py"]

</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre>docker build -t factors_flask:slim -f Dockerfile.slim .
docker run -it --rm -p 5000:5000 factors_flask:slim
docker images factors_flask  <span class="c"># 154M</span>
<span class="c">#REPOSITORY      TAG        IMAGE ID       CREATED          SIZE</span>
<span class="c">#factors_flask   slim       adce144d1091   2 minutes ago    154MB</span>
<span class="c">#factors_flask   standard   cc61aadd153a   22 minutes ago   940MB</span>

</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="基于-python-alpione-的-python-镜像">基于 python alpione 的 python 镜像</h4>

<pre><code class="language-dockerfile">FROM python:3.7.3-alpine
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
CMD ["python","factors_flask.py"]

</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre>docker build -t factors_flask:alpine -f Dockerfile.alpine .
docker run -it --rm -p 5000:5000 factors_flask:alpine
docker images factors_flask  <span class="c"># -  98M</span>
<span class="c">#REPOSITORY      TAG        IMAGE ID       CREATED          SIZE</span>
<span class="c">#factors_flask   alpine     482863f47adb   25 minutes ago   98.2MB</span>
<span class="c">#factors_flask   slim       adce144d1091   31 minutes ago   154MB</span>
<span class="c">#factors_flask   standard   cc61aadd153a   52 minutes ago   940MB</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="image-build-的多个阶段">Image build 的多个阶段</h3>

<ul>
  <li>为了让代码运行的更快，并标尺 small size, 我们需要了解和优化镜像 build 的几个阶段</li>
  <li>cython.org 是一个Pythobn 的扩展， 可以将 python 代码转换成 C 代码的编译工具，能提高代码执行效率</li>
</ul>

<h4 id="用-factorpy-来计算">用 factor.py 来计算</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre>git clone https://github.com/pythonincontainers/multistage
<span class="nb">cd </span>multistage

<span class="c"># 查看 Dockerfile.cython-standard</span>
<span class="c"># FROM python:3.7.3</span>
<span class="c"># WORKDIR /app</span>
<span class="c"># COPY . .</span>
<span class="c"># RUN pip install cython==0.28.5</span>
<span class="c"># RUN python compile.py build_ext --inplace</span>
<span class="c"># RUN pip install -r requirements.txt</span>
<span class="c"># CMD ["python","factors_flask.py"]</span>

docker build -t factors_flask:cython-standard -f Dockerfile.cython-standard .
docker run -it --rm factors_flask:cython-standard bash
<span class="nb">exit
</span>docker run -it --rm -p 5000:5000 factors_flask:cython-standard
</pre></td></tr></tbody></table>
</div>
</div>

<p>访问</p>

<p>http://localhost:5000/123456789</p>

<p>用了 7 秒进行计算</p>

<h4 id="改成-factorpyx-计算">改成 factor.pyx 计算</h4>

<p>修改 compile.py 中的 factors.py 为 factors.pyx</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>docker build -t factors_flask:cython-optiumized -f Dockerfile.cython-standard .
docker run -it --rm -p 5000:5000 factors_flask:cython-optiumized

</pre></td></tr></tbody></table>
</div>
</div>

<p>访问</p>

<p>http://localhost:5000/123456789</p>

<p>用了 0.4 秒进行计算 ， 提高了将近 20 倍</p>

<p>镜像大小 940M</p>

<h4 id="用-multi-stage-方法创建镜像-镜像小速度快">用 multi stage 方法创建镜像, 镜像小，速度快</h4>

<ul>
  <li>原理是第一阶段先用全版本做一个 so 文件</li>
  <li>第二阶段用一个 mini 版本，利用第一阶段的 so 文件做最终的 image</li>
</ul>

<p>查看 Dockerfile.cython-multi</p>

<pre><code class="language-dockerfile"># 第一阶段
FROM python:3.7.3 as dev  # 使用标准版本作为 base image，起个别名 dev
WORKDIR /app
COPY . .
RUN pip install cython==0.28.5  # 安装cython 作为更快的编译器
RUN python compile.py build_ext --inplace  # 创建编译类库 .so 文件

# 第二阶段
FROM python:3.7.3-slim as prod   # 使用 slim 版本作为 base image, 起个别名 prod
WORKDIR /app
COPY factors_flask.py requirements.txt /app/  # 只拷贝必要的文件
COPY --from=dev /app/factors.cpython-37m-x86_64-linux-gnu.so /app  # 将第一阶段编译好的类库文件 .so文件靠过来
RUN pip install -r requirements.txt
CMD ["python","factors_flask.py"] 

</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre>docker build -t factor_flask:cython-multi -f Dockerfile.cython-multi .
docker run -it --rm -p 5000:5000 factor_flask:cython-multi

docker images

</pre></td></tr></tbody></table>
</div>
</div>

<p>访问</p>

<p>http://localhost:5000/123456789</p>

<p>用了 0.4 秒进行计算 ， 提高了将近 20 倍</p>

<p>镜像大小 154M, 缩小了大概 6 倍</p>

<h3 id="定制自己的-python-镜像">定制自己的 python 镜像</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre>git clone https://github.com/pythonincontainers/buildcustom
<span class="nb">cd </span>buildcustom

<span class="c"># 查看 Dockerfile.cython-flask-slim </span>

</pre></td></tr></tbody></table>
</div>
</div>

<pre><code class="language-dockerfile">FROM cython:3.7.3-full as dev
WORKDIR /app
COPY . .
RUN python compile.py build_ext --inplace  # 编译 python 类库到 .so 文件

FROM flask:1.0.3-slim as prod
WORKDIR /app
COPY factors_flask.py /app/ 
COPY --from=dev /app/factors.cpython-37m-x86_64-linux-gnu.so /app
ENV FLASK_APP=factors_flask.py  # 设置环境变量
</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre>
docker build -t factors_flask:cython-flask-slim -f Dockerfile.cython-flask-slim .
<span class="c"># 这里报错了</span>
<span class="c"># ERROR [internal] load metadata for docker.io/library/cython:3.7.3-full </span>
docker run -it --rm -p 5000:5000 factors_flask:cython-flask-slim

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="build-base-image-from-scratch-从头做一个基础镜像">Build base image from scratch 从头做一个基础镜像</h3>

<ul>
  <li>创建自己的基础镜像可以提供更便于自己开发团队进行开发的定制化镜像</li>
  <li>可以提供更安全的保证</li>
  <li><code class="language-plaintext highlighter-rouge">FROM scratch</code> 并不是导入 scratch, 而是引入一个空的镜像。</li>
  <li>分三个步骤
    <ol>
      <li>创建容器并对容器进行定制化</li>
      <li>将容器导出成一个.tar 压缩包</li>
      <li>通过 Dockerfile 将压缩包创建成一个镜像</li>
    </ol>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>git clone https://github.com/pythonincontainers/basescratch
<span class="nb">cd </span>basescratch

</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="dockerfiletestscratch-的例子">Dockerfile.testscratch 的例子</h4>

<pre><code class="language-dockerfile">FROM scratch  # 引入空镜像作为 base 
ADD rootfs.tar /  # 将文件系统的压缩包进行解压并 build，放到根目录，等于做了一个操作系统
ENTRYPOINT ["/usr/local/bin/python"] # 设置默认启动命令

</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></td><td class="code"><pre><span class="c"># 运行一个 python 容器， 会自动 pull 一个 python 的 slim 版本 镜像创建容器</span>
<span class="nb">cd </span>dev
docker run -it --name official3.7.3 python:3.7.3-slim bash  

<span class="c"># 进入容器， 做一些定制化工作</span>
<span class="c"># 安装 flask</span>
pip install <span class="nv">Flask</span><span class="o">==</span>1.0.3
<span class="c"># 删除所有没用的 linux shell ，减少没必要的文件，降低文件系统的体积</span>
rm -f /bin/bash /bin/dash /bin/sh /bin/rbash
<span class="nb">exit</span> <span class="c"># 退出容器</span>

<span class="c"># 将容器导出成一个压缩包</span>
docker <span class="nb">export</span> -o rootfs.tar official3.7.3
<span class="c"># export       a container's filesystem as a tar archive</span>
ls -lah <span class="c"># 查看文件大小  rootfs.tar 145M</span>
docker rm official3.7.3  <span class="c"># 不需要容器了， 删掉</span>

<span class="c"># 通过 Dockerfile 指定的 rootfs.tar 做一个新的镜像</span>
docker build -t mypython3.7:official -f Dockerfile.testscratch .
docker run -it --rm mypython3.7:official <span class="c"># 创建一个容器</span>

<span class="c"># 查看镜像的历史, 可以看到只有两层，都是通过 Dockerfile 创建时产生的</span>
<span class="c">#  history     Show the history of an image</span>
docker <span class="nb">history </span>mypython3.7:official

</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="用-debootstrap-创建一个全新的镜像">用 debootstrap 创建一个全新的镜像</h4>

<ul>
  <li><em>debootstrap</em>是debian/ubuntu下的一个工具,用来构建一套基本的系统(根文件系统)。生成的目录符合Linux文件系统标准(FHS),即包含了/boot、/etc、/bin、/usr等等目录</li>
  <li>只能在 Debian-based system 上进行安装</li>
  <li>可以利用 debootstrap 制作一个 mini 的文件系统，用于定制化我们的镜像</li>
  <li>用 debootstrap 制作文件系统的步骤
    <ol>
      <li>获取 ubuntu 系统</li>
      <li>安装 debootstrap linux 包</li>
      <li>执行 debootstrap 去 创建 Ubuntu 目录</li>
      <li>ubuntu 文件系统准备就绪</li>
      <li>按需修改 ubuntu 目录</li>
      <li>使用 chroot 安装或删除 Linux 包</li>
      <li>检查确认文件系统， 打 tar 包</li>
      <li>通过 rootfs.tar 创建镜像</li>
    </ol>
  </li>
</ul>

<p>下面是下载 ubuntu Xinial 版本后对操作系统的初始化脚本</p>

<p>Install-xenial-buildd.sh</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre>apt update
apt install -y debootstrap
<span class="nb">export </span><span class="nv">MY_ROOT</span><span class="o">=</span>/data/root
mkdir -p <span class="nv">$MY_ROOT</span>
debootstrap --variant<span class="o">=</span>buildd xenial <span class="nv">$MY_ROOT</span> http://archive.ubuntu.com/ubuntu/
mount --bind /dev <span class="nv">$MY_ROOT</span>/dev
mount --bind /dev/pts <span class="nv">$MY_ROOT</span>/dev/pts
mount --bind /sys <span class="nv">$MY_ROOT</span>/sys
mount --bind /proc <span class="nv">$MY_ROOT</span>/proc
cp /etc/hosts <span class="nv">$MY_ROOT</span>/etc/hosts
cp /proc/mounts <span class="nv">$MY_ROOT</span>/etc/mtab
cp /etc/resolv.conf <span class="nv">$MY_ROOT</span>/etc/resolv.conf
cp /host/install-python3.7.sh <span class="nv">$MY_ROOT</span>/tmp
cp /host/packages_to_purge.txt <span class="nv">$MY_ROOT</span>/tmp
chroot <span class="nv">$MY_ROOT</span> /bin/sh /tmp/install-python3.7.sh  <span class="c"># 引出下一个安装脚本</span>
mkdir -p /host/build
cp <span class="nv">$MY_ROOT</span>/rootfs.tar.gz /host/build
</pre></td></tr></tbody></table>
</div>
</div>

<p>install-python3.7.sh</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></td><td class="code"><pre>apt-get update
<span class="c"># Install 'software-properties-common' to get add-apt-repository</span>
apt-get install -y software-properties-common build-essential
<span class="c"># Install latest Python repository for Ubuntu</span>
add-apt-repository ppa:deadsnakes/ppa -y
apt-get update
<span class="c"># Install Python 3.7 and its Libraries plus 'curl' to pull PIP installation script</span>
apt-get install -y python3.7 python3.7-dev curl
<span class="c"># Add 'python' name to 'python3.7' binary</span>
ln /usr/bin/python3.7 /usr/bin/python
<span class="c"># Pull PIP installation script</span>
curl <span class="s2">"https://bootstrap.pypa.io/get-pip.py"</span> -o <span class="s2">"/tmp/get-pip.py"</span>
<span class="c"># Install PIP, download specific versions of modules</span>
python /tmp/get-pip.py <span class="nv">pip</span><span class="o">==</span>19.1.1 <span class="nv">setuptools</span><span class="o">==</span>41.0.1 <span class="nv">wheel</span><span class="o">==</span>0.33.4
rm /tmp/get-pip.py
<span class="c"># Purge and remove Ubuntu Packages not needed in Python Development Image, 'curl' for example</span>
apt-get remove --auto-remove --purge -y --allow-remove-essential <span class="k">$(</span>cat /tmp/packages_to_purge.txt<span class="k">)</span>
<span class="c"># Clean APT caches</span>
apt-get clean
rm -rf /tmp/<span class="k">*</span>
<span class="c"># Create a full system Tar ball</span>
tar -cpzf rootfs.tar.gz --exclude<span class="o">=</span>/rootfs.tar.gz --one-file-system /

</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="创建基础镜像所需的-tar-包-然后将包导入到-docker-镜像中">创建基础镜像所需的 tar 包， 然后将包导入到 docker 镜像中</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre>git clone https://github.com/pythonincontainers/basescratch
<span class="nb">cd </span>basescratch/dev


<span class="c"># 构建基础镜像所需要的 tar.gz 包</span>
<span class="c"># -t 是让当前目录和容器的/host 目录共享</span>
<span class="c"># --privileged  Give extended privileges to this container</span>

docker run -it --rm -v <span class="k">${</span><span class="nv">PWD</span><span class="k">}</span>:/host --privileged ubuntu:16.04 /bin/sh /host/install-xenial-buildd.sh
<span class="c"># 结果是创建一个名字叫 rootfs.tar.gz 的文件</span>

<span class="c"># 通过 tar.gz 创建文件系统镜像</span>
docker import --change <span class="s1">'ENV PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'</span> --change <span class="s2">"CMD /usr/bin/python"</span> build/rootfs.tar.gz mypython3.7:import
<span class="c">#  import   the contents from a tarball to create a filesystem image</span>
<span class="c"># --change Apply Dockerfile instruction to the created image</span>

<span class="c"># 查看镜像</span>
docker images 
<span class="c"># 看到如下镜像， 说明创建成功</span>
<span class="c"># mypython3.7                          import                                                  87e7a85c73fc   52 seconds ago   391MB</span>
docker inspect mypython3.7:import

</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="还可以用-dockerfile-把-targz-做成镜像">还可以用 Dockerfile 把 tar.gz 做成镜像</h4>

<p>Dockerfile.basescratch</p>

<pre><code class="language-dockerfile">FROM scratch
ADD build/rootfs.tar.gz /
ENV HOME=/root
CMD ["/bin/bash"]
</code></pre>

<p>构建开发用镜像</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>docker build -t mypython3.7:dev-xenial -f Dockerfile.basescratch .

</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="构建一个生产的镜像">构建一个生产的镜像</h4>

<ul>
  <li>唯一区别就是 install-xenial-minbase.sh 中 debootstrap 中用的版本是一个 更小的版本， 没有开发需要的一些类库</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="nb">cd</span> ../prod
docker run -it --rm -v <span class="k">${</span><span class="nv">PWD</span><span class="k">}</span>:/host --privileged ubuntu:16.04 /bin/sh /host/install-xenial-minbase.sh
docker import --change <span class="s1">'ENV PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'</span> --change <span class="s2">"CMD /usr/bin/python"</span> build/rootfs.tar.gz mypython3.7:import

docker build -t mypython3.7:prod-xenial -f Dockerfile.basescratch .

<span class="c"># 查看上面做的三个镜像</span>
docker images
<span class="c"># REPOSITORY                           TAG                                                     IMAGE ID       CREATED          SIZE</span>
<span class="c"># mypython3.7                          prod-xenial                                             f53df66eb76b   31 seconds ago   100MB</span>
<span class="c"># mypython3.7                          dev-xenial                                              d25da53e05f8   9 minutes ago    391MB</span>
<span class="c"># mypython3.7                          import                                                  87e7a85c73fc   11 hours ago     391MB</span>

</pre></td></tr></tbody></table>
</div>
</div>

<p>在通过 Cython 将刚才做的镜像优化成C 编译的镜像</p>

<p>查看 Dockerfile.cython-multi</p>

<pre><code class="language-dockerfile">FROM mypython3.7:dev-xenial as dev  # 先用开发版本的镜像生成一个 so 类库
WORKDIR /app
COPY . .
RUN pip install cython==0.28.5
RUN python compile.py build_ext --inplace  # 编译 c 版本的类库

FROM mypython3.7:prod-xenial as prod  # 使用刚刚创建的生产部版本的镜像作为 base image
WORKDIR /app
COPY factors_flask.py requirements.txt /app/
COPY --from=dev /app/factors.cpython-37m-x86_64-linux-gnu.so /app # 将 编译后的类库拷贝过来
RUN pip install -r requirements.txt
CMD ["python","factors_flask.py"]

</code></pre>

<p><code class="language-plaintext highlighter-rouge">.dockerignore</code> 防止我们拷贝不必要的文件到镜像中</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre>.git
.dockerignore
Dockerfile*
dev
prod
</pre></td></tr></tbody></table>
</div>
</div>

<p>构造最终的镜像</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="nb">cd</span> ..
docker build -t factors_flask:cython-custom -f Dockerfile.cython-multi .
docker run -it --rm -p 5000:5000 factors_flask:cython-custom
</pre></td></tr></tbody></table>
</div>
</div>

<p>访问 http://localhost:5000/12345678</p>


            </div>

            <!-- Rating -->
            
            <div class="rating mb-4 d-flex align-items-center">
                <strong class="mr-1">Rating:</strong> <div class="rating-holder">
<div class="c-rating c-rating--regular" data-rating-value="4.5">
  <button>1</button>
  <button>2</button>
  <button>3</button>
  <button>4</button>
  <button>5</button>
</div>
</div>
            </div>
            

            <!-- Post Date -->
            <p>
            <small>
                <span class="post-date"><time class="post-date" datetime="2021-07-26">26 Jul 2021</time></span>           
                
                </small>
            </p>

            <!-- Post Categories -->
            <div class="after-post-cats">
                <ul class="tags mb-4">
                    
                    
                    <li>
                        <a class="smoothscroll" href="/categories#Docker">Docker</a>
                    </li>
                    
                    <li>
                        <a class="smoothscroll" href="/categories#Python">Python</a>
                    </li>
                    
                </ul>
            </div>
            <!-- End Categories -->

            <!-- Post Tags -->
            <div class="after-post-tags">
                <ul class="tags">
                    
                    
                </ul>
            </div>
            <!-- End Tags -->

            <!-- Prev/Next -->
            <div class="row PageNavigation d-flex justify-content-between font-weight-bold">
            
            <a class="prev d-block col-md-6" href="//NLP-with-Python/"> &laquo; Natural Language Processing with Python</a>
            
            
            <a class="next d-block col-md-6 text-lg-right" href="//Python-in-Container-02/">Python in Container Part Two &raquo; </a>
            
            <div class="clearfix"></div>
            </div>
            <!-- End Categories -->

        </div>
        <!-- End Post -->

    </div>
</div>
<!-- End Article
================================================== -->

<!-- Begin Comments
================================================== -->

    <div class="container">
        <div id="comments" class="row justify-content-center mb-5">
            <div class="col-md-8">
                <section class="disqus">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'demowebsite'; 
        var disqus_developer = 0;
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = window.location.protocol + '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>

            </div>
        </div>
    </div>

<!--End Comments
================================================== -->

<!-- Review with LD-JSON, adapt it for your needs if you like, but make sure you test the generated HTML source code first: 
https://search.google.com/structured-data/testing-tool/u/0/
================================================== -->

<script type="application/ld+json">
{
  "@context": "http://schema.org/",
  "@type": "Review",
  "itemReviewed": {
    "@type": "Thing",
    "name": "Python in Container Part One"
  },
  "author": {
    "@type": "Person",
    "name": "Dalong"
  },
  "datePublished": "2021-07-26",
  "reviewRating": {
    "@type": "Rating",
    "ratingValue": "4.5",
    "bestRating": "5"
  }
}
</script>

</div>


    
</div>

<!-- Categories Jumbotron
================================================== -->
<div class="jumbotron fortags">
	<div class="d-md-flex h-100">
		<div class="col-md-4 transpdark align-self-center text-center h-100">
            <div class="d-md-flex align-items-center justify-content-center h-100">
                <h2 class="d-md-block align-self-center py-1 font-weight-light">Explore <span class="d-none d-md-inline">→</span></h2>
            </div>
		</div>
		<div class="col-md-8 p-5 align-self-center text-center">
            
            
                
                    <a class="mt-1 mb-1" href="/categories#Linux">Linux (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Python">Python (16)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Mysql">Mysql (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Redis">Redis (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#MongoDB">MongoDB (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Flask">Flask (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Django">Django (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#DjangoRest">DjangoRest (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Numpy">Numpy (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Panda">Panda (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Sklearn">Sklearn (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Jupyter">Jupyter (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#OpenCV">OpenCV (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#AI">AI (3)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Tensorflow">Tensorflow (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Microservice">Microservice (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Docker">Docker (3)</a>
                
                    <a class="mt-1 mb-1" href="/categories#NLP">NLP (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#AWS">AWS (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Architecture">Architecture (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Agile">Agile (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Scrum">Scrum (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#MLPS">MLPS (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#PIPL">PIPL (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Metaverse">Metaverse (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#ChatGPT">ChatGPT (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#OpenAI">OpenAI (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#LLM">LLM (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Azure">Azure (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Data-Science">Data Science (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#ITIL">ITIL (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Jekyll">Jekyll (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Github">Github (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Liquid">Liquid (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Markdown">Markdown (1)</a>
                
            
            
		</div>
	</div>
</div>

<!-- Begin Footer
================================================== -->
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                Copyright © 2023 Dalong's personal blog 
            </div>
            <div class="col-md-6 col-sm-6 text-center text-lg-right">    
                <a target="_blank" href="#">Designed</a> by Dalong.work
            </div>
        </div>
    </div>
</footer>
<!-- End Footer
================================================== -->

</div> <!-- /.site-content -->

<!-- Scripts
================================================== -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>

<script src="/assets/js/mediumish.js"></script>



<script src="/assets/js/ie10-viewport-bug-workaround.js"></script> 


<script id="dsq-count-scr" src="//demowebsite.disqus.com/count.js"></script>


</body>
</html>
