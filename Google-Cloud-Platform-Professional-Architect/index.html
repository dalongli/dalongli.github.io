<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<link rel="icon" href="/assets/images/logo.png">

<title>Prepare for Google CLoud Platform Professional Architect Certification | Dalong's personal blog</title>

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Prepare for Google CLoud Platform Professional Architect Certification | Dalong’s personal blog</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Prepare for Google CLoud Platform Professional Architect Certification" />
<meta name="author" content="Dalong" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="我一直以来都是谷歌的忠实粉丝, 从 08 年开始就开始使用谷歌的各种产品和服务. 因为项目需要, 我花了 2 个多月的时间筹备谷歌专业认证架构师的认证并一次性通过了考试. 这里我把一些学习心得总结了下来跟大家一起分享. 如果你也在准备这门考试, 看这篇文章就足够了." />
<meta property="og:description" content="我一直以来都是谷歌的忠实粉丝, 从 08 年开始就开始使用谷歌的各种产品和服务. 因为项目需要, 我花了 2 个多月的时间筹备谷歌专业认证架构师的认证并一次性通过了考试. 这里我把一些学习心得总结了下来跟大家一起分享. 如果你也在准备这门考试, 看这篇文章就足够了." />
<link rel="canonical" href="http://localhost:4000/Google-Cloud-Platform-Professional-Architect/" />
<meta property="og:url" content="http://localhost:4000/Google-Cloud-Platform-Professional-Architect/" />
<meta property="og:site_name" content="Dalong’s personal blog" />
<meta property="og:image" content="http://localhost:4000/assets/images/GCPArchitect.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-02-23T00:00:00+08:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Prepare for Google CLoud Platform Professional Architect Certification","dateModified":"2023-02-23T00:00:00+08:00","datePublished":"2023-02-23T00:00:00+08:00","description":"我一直以来都是谷歌的忠实粉丝, 从 08 年开始就开始使用谷歌的各种产品和服务. 因为项目需要, 我花了 2 个多月的时间筹备谷歌专业认证架构师的认证并一次性通过了考试. 这里我把一些学习心得总结了下来跟大家一起分享. 如果你也在准备这门考试, 看这篇文章就足够了.","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/images/logo.png"},"name":"Dalong"},"image":"http://localhost:4000/assets/images/GCPArchitect.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Google-Cloud-Platform-Professional-Architect/"},"url":"http://localhost:4000/Google-Cloud-Platform-Professional-Architect/","author":{"@type":"Person","name":"Dalong"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    
<link href="/assets/css/screen.css" rel="stylesheet">

<link href="/assets/css/main.css" rel="stylesheet">

<script src="/assets/js/jquery.min.js"></script>

</head>




<body class="layout-post">
	<!-- defer loading of font and font awesome -->
	<noscript id="deferred-styles">
		<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
        <link rel="preconnect" href="https://fonts.googleapis.com"> 
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
        <link href="https://fonts.googleapis.com/css2?family=Carter+One&display=swap" rel="stylesheet">
    </noscript>


<!-- Begin Menu Navigation
================================================== -->
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">

    <div class="container pr-0">

    <!-- Begin Logo -->
    <a class="navbar-brand" href="/">
    <img src="/assets/images/logo.png" alt="Dalong's personal blog">
    </a>
    <!-- End Logo -->

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarMediumish">

        <!-- Begin Menu -->

            <ul class="navbar-nav ml-auto">

                
                <li class="nav-item">
                
                <a class="nav-link" href="/index.html">Blog</a>
                </li>

                <li class="nav-item">
                <a class="nav-link" href="/about">About</a>
                </li>

<!-- 以后再加上相关链接

                <li class="nav-item">
                <a target="_blank" class="nav-link" href="https://bootstrapstarter.com/bootstrap-templates/template-mediumish-bootstrap-jekyll/"> Docs</a>
                </li>

                <li class="nav-item">
                <a target="_blank" class="nav-link" href="https://www.wowthemes.net/themes/mediumish-wordpress/"><i class="fab fa-wordpress-simple"></i> WP Version</a>
                </li>

                <li class="nav-item">
                <a target="_blank" class="nav-link" href="https://www.wowthemes.net/themes/mediumish-ghost/"><i class="fab fa-snapchat-ghost"></i> Ghost Version</a>
                </li>
-->
                <li class="nav-item">
                <a target="_blank" class="nav-link" href="https://github.com/dalongli"><i class="fab fa-github"></i> Fork on Github</a>
                </li>

                <script src="/assets/js/lunr.js"></script>


<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>


<form class="bd-search" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
    <input type="text" class="form-control text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Type and enter..."/>
</form>

<div id="lunrsearchresults">
    <ul></ul>
</div>

<script src="/assets/js/lunrsearchengine.js"></script>

            </ul>

        <!-- End Menu -->

    </div>

    </div>
</nav>
<!-- End Navigation
================================================== -->

<div class="site-content">

<div class="container">

<!-- Site Title
================================================== -->
<div class="mainheading">
    <h1 class="sitetitle">Dalong's personal blog</h1>
    <p class="lead">
        Record the bits and pieces of the technology big bang.
    </p>
</div>

<!-- Content
================================================== -->
<div class="main-content">
    <!-- Begin Article
================================================== -->
<div class="container">
    <div class="row">

        <!-- Post Share -->
        <div class="col-md-2 pl-0">
            <div class="share sticky-top sticky-top-offset">
    <p>
        Share
    </p>
    <ul>
        <li class="ml-1 mr-1">
            <a target="_blank" href="https://twitter.com/intent/tweet?text=Prepare for Google CLoud Platform Professional Architect Certification&url=http://localhost:4000/Google-Cloud-Platform-Professional-Architect/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                <i class="fab fa-twitter"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://facebook.com/sharer.php?u=http://localhost:4000/Google-Cloud-Platform-Professional-Architect/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=435');return false;">
                <i class="fab fa-facebook-f"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/Google-Cloud-Platform-Professional-Architect/" onclick="window.open(this.href, 'width=550,height=435');return false;">
                <i class="fab fa-linkedin-in"></i>
            </a>
        </li>

    </ul>
    
    <div class="sep">
    </div>
    <ul>
        <li>
        <a class="small smoothscroll" href="#disqus_thread"></a>
        </li>
    </ul>
    
</div>

        </div>

        <!-- Post -->
        

        <div class="col-md-9 flex-first flex-md-unordered">
            <div class="mainheading">

                <!-- Author Box -->
                
                <div class="row post-top-meta">
                    <div class="col-xs-12 col-md-3 col-lg-2 text-center text-md-left mb-4 mb-md-0">
                        
                        <img class="author-thumb" src="/assets/images/avatar_dl.png" alt="Dalong">
                        
                    </div>
                    <div class="col-xs-12 col-md-9 col-lg-10 text-center text-md-left">
                        <a target="_blank" class="link-dark" href="https://dalongli.github.io/about">Dalong</a><a target="_blank" href="https://dalongli.github.io." class="btn follow">Follow</a>
                        <span class="author-description">A profesional technical consultant and blogger.</span>
                    </div>
                </div>
                

                <!-- Post Title -->
                <h1 class="posttitle">Prepare for Google CLoud Platform Professional Architect Certification</h1>

            </div>

            <!-- Adsense if enabled from _config.yml (change your pub id and slot) -->
            
            <!-- End Adsense -->

            <!-- Post Featured Image -->
            

            
            <img class="featured-image img-fluid" src="/assets/images/GCPArchitect.jpg" alt="Prepare for Google CLoud Platform Professional Architect Certification">
            

            
            <!-- End Featured Image -->

            <!-- Post Content -->
            <div class="article-post">
                <!-- Toc if any -->
                
                    
                    <div class="toc mt-4 mb-4 lead">
                        <h3 class="font-weight-bold">Summary</h3>
                        <ul>
  <li><a href="#google-cloud-platform-professional-architect-certification">Google CLoud Platform Professional Architect Certification</a>
    <ul>
      <li><a href="#考试准备">考试准备</a></li>
      <li><a href="#gcp-服务">GCP 服务</a>
        <ul>
          <li><a href="#compute">Compute</a>
            <ul>
              <li><a href="#compute-engine---gce">Compute Engine - GCE</a></li>
              <li><a href="#google-kubernetes-engine---gke">Google Kubernetes Engine - GKE</a></li>
              <li><a href="#cloud-functions">Cloud Functions</a></li>
              <li><a href="#google-cloud-run">Google Cloud Run</a></li>
              <li><a href="#gce-gke-gae-function-cloud-run-区别">GCE, GKE, GAE, Function, Cloud RUN 区别</a></li>
              <li><a href="#容器所在的服务选择流程图">容器所在的服务选择流程图</a></li>
            </ul>
          </li>
          <li><a href="#storage">Storage</a>
            <ul>
              <li><a href="#persistent-disks-pd">Persistent Disks (PD)</a>
                <ul>
                  <li><a href="#local-ssds-ssd">Local SSDs (SSD)</a></li>
                </ul>
              </li>
              <li><a href="#filestore">Filestore</a></li>
              <li><a href="#machine-images">Machine Images</a></li>
              <li><a href="#google-cloud-storage">Google Cloud Storage</a></li>
            </ul>
          </li>
          <li><a href="#database">Database</a>
            <ul>
              <li><a href="#cloud-sql">Cloud SQL</a></li>
              <li><a href="#cloud-spanner">Cloud Spanner</a></li>
              <li><a href="#cloud-firestore">Cloud FireStore</a></li>
              <li><a href="#cloud-bigtable">Cloud BigTable</a></li>
              <li><a href="#memorystore">MemoryStore</a>
                <ul>
                  <li><a href="#memcached">Memcached</a></li>
                  <li><a href="#redis">Redis</a></li>
                </ul>
              </li>
              <li><a href="#dataproc">Dataproc</a></li>
              <li><a href="#pubsub-消息队列-异步数据通信">Pub/Sub 消息队列 异步数据通信</a></li>
              <li><a href="#dataflow">Dataflow</a></li>
              <li><a href="#数据的生命周期">数据的生命周期</a></li>
            </ul>
          </li>
          <li><a href="#ai--ml">AI &amp; ML</a>
            <ul>
              <li><a href="#预制-ml-api">预制 ML API</a></li>
              <li><a href="#automl">AutoML</a></li>
              <li><a href="#vertex-ai">Vertex AI</a></li>
              <li><a href="#bigquery-ml">BigQuery ML</a></li>
            </ul>
          </li>
          <li><a href="#networking">Networking</a>
            <ul>
              <li><a href="#network-tier">Network Tier</a></li>
              <li><a href="#vpc">VPC</a></li>
              <li><a href="#serverless-vpc-access">Serverless VPC Access</a></li>
              <li><a href="#vpc-peering-vpc-network-peering">VPC Peering (VPC Network Peering)</a></li>
              <li><a href="#carrier-peering">Carrier Peering</a></li>
              <li><a href="#cloud-router">Cloud Router</a></li>
              <li><a href="#direct-peering">Direct Peering</a></li>
              <li><a href="#cloud-nat-cloud-nat-gateway">Cloud NAT (Cloud NAT Gateway)</a></li>
              <li><a href="#vpn">VPN</a></li>
              <li><a href="#cloud-interconnect">Cloud Interconnect</a></li>
              <li><a href="#cloud-dns">Cloud DNS</a></li>
              <li><a href="#cloud-cdn">Cloud CDN</a></li>
              <li><a href="#media-cdn">Media CDN</a></li>
              <li><a href="#load-balancing-load-balancer">Load Balancing (Load Balancer)</a></li>
              <li><a href="#service-directory">Service Directory</a></li>
              <li><a href="#eventarc">Eventarc</a></li>
            </ul>
          </li>
          <li><a href="#devops-cicd-and-sre">DevOps CICD and SRE</a>
            <ul>
              <li><a href="#cicd">CICD</a></li>
              <li><a href="#infrastructure-as-code">Infrastructure as Code</a></li>
              <li><a href="#sre">SRE</a></li>
              <li><a href="#marketplace-cloud-launcher">Marketplace (Cloud Launcher)</a></li>
              <li><a href="#release-management">Release Management</a></li>
            </ul>
          </li>
          <li><a href="#identify-and-security">Identify and Security</a>
            <ul>
              <li><a href="#container-analysis">Container Analysis</a></li>
              <li><a href="#artifact-registry">Artifact Registry</a></li>
              <li><a href="#kms">KMS</a></li>
              <li><a href="#iam-service-account-服务账号-acl">IAM, Service Account (服务账号), ACL</a></li>
              <li><a href="#iam-organization-billing-account-id-manager">IAM, Organization, Billing Account, ID manager</a></li>
              <li><a href="#identity-aware-proxy-iap">Identity Aware Proxy (IAP)</a></li>
              <li><a href="#identity-platform">Identity Platform</a></li>
              <li><a href="#cloud-armor">Cloud Armor</a></li>
              <li><a href="#secret-manager">Secret Manager</a></li>
              <li><a href="#security-command-center">Security Command Center</a></li>
              <li><a href="#network-intelligence-center">Network Intelligence Center</a></li>
            </ul>
          </li>
          <li><a href="#operations-and-monitoring">Operations and Monitoring</a>
            <ul>
              <li><a href="#cloud-monitoring">Cloud Monitoring</a></li>
              <li><a href="#opentelemetry">OpenTelemetry</a></li>
              <li><a href="#cloud-logging">Cloud Logging</a></li>
              <li><a href="#access-transparency-log-访问透明日志">Access Transparency Log (访问透明日志)</a></li>
              <li><a href="#cloud-audit-logs-审计日志">Cloud Audit Logs (审计日志)</a></li>
              <li><a href="#stackdrive-log">Stackdrive log</a></li>
              <li><a href="#cloud-trace">Cloud Trace</a></li>
              <li><a href="#cloud-debugger">Cloud Debugger</a></li>
              <li><a href="#cloud-profiler">Cloud Profiler</a></li>
              <li><a href="#error-reporing">Error Reporing</a></li>
              <li><a href="#os-patch-management">OS Patch Management</a></li>
              <li><a href="#cloud-operations-for-gke">Cloud Operations for GKE</a></li>
              <li><a href="#场景">场景</a></li>
            </ul>
          </li>
          <li><a href="#complaiance-and-regulations-合规">Complaiance and Regulations 合规</a></li>
          <li><a href="#migration-to-gcp-云迁移和整合">Migration to GCP 云迁移和整合</a>
            <ul>
              <li><a href="#云迁移">云迁移</a></li>
              <li><a href="#迁移大量数据的计算">迁移大量数据的计算</a></li>
              <li><a href="#cloud-scheduler">Cloud Scheduler</a></li>
              <li><a href="#cloud-emulators">Cloud Emulators</a></li>
              <li><a href="#managed-service-for-microsoft-active-directory">Managed Service for Microsoft Active Directory</a></li>
              <li><a href="#pricing-calculator">Pricing Calculator</a></li>
            </ul>
          </li>
          <li><a href="#hybrid-and-multi-cloud">Hybrid and Multi-cloud</a>
            <ul>
              <li><a href="#anthos">Anthos</a></li>
            </ul>
          </li>
          <li><a href="#api">API</a>
            <ul>
              <li><a href="#api-management-tools">API Management Tools</a>
                <ul>
                  <li><a href="#cloud-endpoint">Cloud Endpoint</a></li>
                  <li><a href="#api-gateway">API Gateway</a></li>
                </ul>
              </li>
              <li><a href="#apigee-edge">Apigee (Edge)</a></li>
              <li><a href="#transcoder-api">Transcoder API</a></li>
              <li><a href="#video-intelligence-api">Video Intelligence API</a></li>
            </ul>
          </li>
          <li><a href="#game">Game</a>
            <ul>
              <li><a href="#game-server">Game Server</a></li>
            </ul>
          </li>
          <li><a href="#好的架构设计">好的架构设计</a></li>
          <li><a href="#架构师要知道的东西">架构师要知道的东西</a></li>
          <li><a href="#谷歌云-architecture-framework">谷歌云 Architecture Framework</a></li>
          <li><a href="#managed-service--serverless-无服务">Managed service / Serverless 无服务</a></li>
          <li><a href="#workesapce">Workesapce</a></li>
        </ul>
      </li>
      <li><a href="#命令行工具---cloud-shell-gcloud">命令行工具 - Cloud Shell (GCloud)</a></li>
    </ul>
  </li>
</ul>
                    </div>
                
                <!-- End Toc -->
                <p>我一直以来都是谷歌的忠实粉丝, 从 08 年开始就开始使用谷歌的各种产品和服务. 因为项目需要, 我花了 2 个多月的时间筹备谷歌专业认证架构师的认证并一次性通过了考试. 这里我把一些学习心得总结了下来跟大家一起分享. 如果你也在准备这门考试, 看这篇文章就足够了.</p>

<h1 id="google-cloud-platform-professional-architect-certification">Google CLoud Platform Professional Architect Certification</h1>

<p>[TOC]</p>

<h2 id="考试准备">考试准备</h2>
<ul>
  <li>考试名称: GCP - PCA</li>
  <li>200 美金</li>
  <li>120分钟(2 小时)</li>
  <li>50 - 60 道题, 65 道 (答对 70% 算及格)
    <ul>
      <li>单选题, 4 选 1</li>
      <li>多选题, 5 选 2</li>
      <li>考试里面有大概10-12题案例分析题，这些案例都摘自于Google官网上面的案例分析，所以请你一定要提早熟悉这些案例，了解一下这些案例中想要通过云服务达到的业务目标和技术目标是什么</li>
    </ul>
  </li>
  <li>考完马上知道结果</li>
  <li>考试技巧
    <ul>
      <li>如果答案的文字少, 先扫一眼答案</li>
      <li>读完整的题目</li>
      <li>注意看 “you want to”</li>
      <li>识别和记录问题的关键部分
        <ul>
          <li>比如:
            <ul>
              <li>题目希望 Most cost-effective way</li>
              <li>那么就应该优先考虑 regional 而不是 multi-regional</li>
              <li>题目如果说希望 HA, 那么就应该是 multi-regional</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>排除法</li>
      <li>不确定的, 先打个flag, 提交前再review 一下</li>
    </ul>
  </li>
  <li>第一次没通过, 14 天后再考, 第二次没通过 60 天后再考, 还没通过 365 天后再考</li>
  <li><a href="https://www.webassessor.com/wa.do?page=CANDIDATE&amp;tabs=10">考试网址</a></li>
  <li>重新schedule 需要提前 3 天 (72 小时)</li>
  <li>提前15 分钟进入网页</li>
  <li>考试考试按钮会在预约时间的前 10 分钟出现</li>
  <li>考官可能会因为当时的忙碌情况, 迟到 15-20 分钟</li>
  <li><a href="https://kryterion.my.site.com/support/s/article/How-to-Prepare-for-an-Online-Exam-Pre-check?language=en_US">考前准备</a>, 包括, 准备好身份证, 护照 , 桌面要整齐, 不能有双屏幕等.</li>
  <li>关掉所有无关软件</li>
  <li>用chrome 浏览器进入 考试网址</li>
</ul>

<h2 id="gcp-服务">GCP 服务</h2>

<h3 id="compute">Compute</h3>

<h4 id="compute-engine---gce">Compute Engine - GCE</h4>

<ul>
  <li>GCP 的 VM的服务</li>
  <li>按秒计费, 虚机release 掉了就不计费了</li>
  <li>VM 就是一个虚机, 也称作实例
    <ul>
      <li>VM 只能属于某一个 zone</li>
      <li>可以跨 zone 迁移 VM
        <ul>
          <li>用命令 <code class="language-plaintext highlighter-rouge">gcloud compute instances move my-instance --zone us- central1-a --destination-zone us-central1-b</code> 进行迁移</li>
          <li>如下情况, vm 无法跨zone 移动
            <ul>
              <li>Instances that are part of a MIG</li>
              <li>Instances attached with local SSDs</li>
              <li>Instances in TERMINATED status</li>
            </ul>
          </li>
          <li>跨 Region 迁移 vm 只能通过 手动方式
            <ul>
              <li>
                <ol>
                  <li>为 vm 的 persistent disk 创建一个快照 snapshot , 把 snapshot 拷贝到另一个 region (的一个zone)
                    <ul>
                      <li><code class="language-plaintext highlighter-rouge">gcloud compute disks snapshot my-disk-a --snapshot-names my-pd-snapshot --zone ZONE</code></li>
                    </ul>
                  </li>
                </ol>
              </li>
              <li>
                <ol>
                  <li>用快照 创建 persistent disk
                    <ul>
                      <li><code class="language-plaintext highlighter-rouge">gcloud compute disks create my-disk-b --source-snapshot my-pd-snapshot --zone ZONE</code></li>
                    </ul>
                  </li>
                </ol>
              </li>
              <li>
                <ol>
                  <li>在新的region (的一个zone)创建一个 instance , 然后 attach 上 persistent disk</li>
                </ol>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>创建GCE的前置条件
    <ol>
      <li>Project</li>
      <li>Billing Account</li>
      <li>Compute Engines Admin APIs should be enabled</li>
    </ol>
  </li>
  <li>GCE Machine Family机器家族 有三种, 每种里面有有不同的机器类型
    <ul>
      <li>General Purpose (E2, N2, N2D, N1)</li>
      <li>Memory Optimized (M2, M1)</li>
      <li>Compute Optimized (C2)</li>
      <li>GPU
        <ul>
          <li>图形计算或者数学计算, AI/ML 会用到</li>
          <li>很贵</li>
          <li>不是所有机器类型都支持</li>
          <li>需要再 VM 上安装 GPU Libraries 软件
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-08-084918.jpg" alt="" /></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>GCE Machine Type机器类型
    <ul>
      <li><code class="language-plaintext highlighter-rouge">e2-standard-2</code> 例子
        <ul>
          <li>e2 表示family 名字</li>
          <li>standard 表示性能(workload )</li>
          <li>2 表示vCPU个数,</li>
          <li>vCPU个数越大的机器类型, 内存,网络, 磁盘的大小也会更大</li>
          <li>实例停止后, 可以修改及其类型</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Image
    <ul>
      <li>用来放各种类型的操作系统镜像
        <ul>
          <li>可以是public的(google 或 开源组织, 或第三方社区)</li>
          <li>也可以是 custom 的(用户自建的)
            <ul>
              <li>创建custom image 的主要目的是把一个已经安装和配置了很多内容的实例做成定制的镜像, 以后再创建这个镜像的实例的时候, 无需重新安装配置, 大大减少实例第一次安装启动时间.</li>
              <li>custom image 可以通过以下内容创建
                <ul>
                  <li>vm实例</li>
                  <li>a disk</li>
                  <li>a snapshot</li>
                  <li>另一个image</li>
                  <li>一个文件</li>
                </ul>
              </li>
              <li>比 startup script 好用</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>通过 Image 生成 Instance 的操作系统, 存在 disk上</li>
    </ul>
  </li>
  <li>disk
    <ul>
      <li>image 会安装操作系统到磁盘</li>
      <li>可以被单独用来做成 custom image, 让 instance template 用</li>
    </ul>
  </li>
  <li>把 VM 拷贝到另一个 project 的方法
    <ol>
      <li>给 VM 的 boot disk创建一个 snapshot</li>
      <li>通过 snapshot 创建一个 image</li>
      <li>把 image 分享到其他 project</li>
      <li>通过 image 创建新的 VM</li>
    </ol>
  </li>
  <li>IP 地址
    <ul>
      <li>一个instance 可以有一个external IP(可选), 和一个internal IP (必须有)</li>
      <li>external IP 是临时的, 实例停了, external IP 就丢了</li>
      <li>static IP 是单独申请的(VPC 管理界面里面) , 创建后可以attach 到一个虚机上, 就替换掉了原来的external IP
        <ul>
          <li>static IP 单独收费, 不attach 更贵,</li>
          <li>虚机删了, static IP 还在, 要单独删掉</li>
          <li>static IP 可以从一个虚机换到两一个虚机上</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Startup script
    <ul>
      <li>将脚本写到 startup script 中, 可以让虚机第一次启动的时候就把我们需要执行的ssh命令做好, 比如安装apache2并启动</li>
      <li>脚本一般是安装操作系统补丁或者安装软件</li>
      <li>也可以编辑一个存在的实例的startup script</li>
      <li>startup script 的一个例子: 部署新的应用版本到 compute engine
        <div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre><span class="c"># Setup logging agent</span>
curl -sSO https://dl.google.com/cloudagents/install-logging-agent.sh
sudo bash install-logging-agent.sh
<span class="c"># Install GIT</span>
apt-get update
apt-get install -yq git
<span class="c"># Clone Repo</span>
git clone https://github.com/in28minutes/your-app.git /opt/app
<span class="c"># Build and Run app</span>
//...
</pre></td></tr></tbody></table>
</div>
        </div>
      </li>
    </ul>
  </li>
  <li>troubleshootting  vm 启动失败的步骤
    <ul>
      <li>
        <ol>
          <li>看看 Quota 是否有报错.
            <ul>
              <li>比如实例个数限制</li>
            </ul>
          </li>
        </ol>
      </li>
      <li>
        <ol>
          <li>检查boot disk 是否满了
            <ul>
              <li>超过了 95% 可能就启动不起来了</li>
            </ul>
          </li>
        </ol>
      </li>
      <li>
        <ol>
          <li>检查串行端口输出 Serial port output
            <ul>
              <li>每个 vm 有4 个 串行端口</li>
              <li>OS, BIOS 和其他系统级别的服务都往 串行端口写数据</li>
              <li>可以通过 Cloud console, gcloud 命令, Compute Engine API 访问 串行端口</li>
              <li>可以把串行端口的信息输出到 cloud logging 中, 方便查询
                <ul>
                  <li>Serial console logs</li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>
      </li>
      <li>
        <ol>
          <li>检查 file system 是否除了问题
            <ul>
              <li>把boot disk 挂载到其他虚机上试试 是否可以正常启动.</li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
  <li>shutdown script
    <ul>
      <li>在 vm stop, restart, terminate 之前执行的命令脚本.
        <ul>
          <li>比如脚本内容是 清除或者导出日志</li>
        </ul>
      </li>
      <li>任何 VM 都可以用</li>
      <li>和 startup script 很像
        <ul>
          <li>Linux 系统 中是 root 用户来执行脚本</li>
          <li>Windows 系统是 System account 执行脚本</li>
          <li>作为 metadata 来存储
            <ul>
              <li>创建 VM 的时候在 startup script 下面的metadata 那里设置 shutdown script
                <ul>
                  <li><code class="language-plaintext highlighter-rouge">-metadata-from-file shutdown-script=script.sh</code></li>
                </ul>
              </li>
              <li>也可以把脚本放在 cloud storage 中, 然后在 metadata 中设置key valuae时指向存贮的bucket
                <ul>
                  <li><code class="language-plaintext highlighter-rouge">-metadata shutdown-script-url=gs://bucket-in-cloud-storage/file</code></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>例外, 不会执行 shutdown script 的情况
        <ul>
          <li>如果 vm 是 硬重置(比如断电), hard reset(instances.reset)</li>
          <li>如果 vm 是 preemptible 实例(临时用的那种便宜的), 且过了 grace period , 就不能执行了.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Instance template
    <ul>
      <li>把常用配置虚机的参数放到 instance template 中, 省去每次创建虚机都要在console 选一遍的麻烦</li>
      <li>包括机器家族, 机器类型, 镜像选择, startup 脚本等</li>
      <li>一旦创建不能更新</li>
      <li>Instance template 配合 rolling update 可以快速给 MIG 部署新版本, 也可以快速给 MIG 降版本</li>
    </ul>
  </li>
  <li>GCE 的使用场景
    <ul>
      <li>客户希望用独占的服务器(or BYOL)硬件来运行实例 (公司合规, 证书, 管理等需要)
        <ul>
          <li>方案: Sole tenant nodes
            <ul>
              <li>一个物理机, 专门给你用的, 上面有 VMs</li>
              <li>创建 VM 实例, 基于 node name 来给每个node 做 node affinity labels. 确保每个客户有自己专属的 host.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>客户有1000个 vm ,需要能够自动给OS 打补丁, OS 版本管理, OS 安装软件管理
        <ul>
          <li>方案: VM manager</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>ssh 进虚机的方法
    <ul>
      <li>option1: GCP console 中的 ssh 界面直接登录 vm
        <ul>
          <li>compute engine 自动创建了 sshk key pair</li>
        </ul>
      </li>
      <li>option2: Gcloud 命令
        <ul>
          <li>用命令 <code class="language-plaintext highlighter-rouge">gcloud compute ssh</code></li>
          <li>compute engine VM  自动创建了 sshk key pair 和用户名</li>
        </ul>
      </li>
      <li>option3: Customized ssh key (用户自建的ssh key 登录vm)
        <ul>
          <li>madadata managed 和 OS login 都可以用</li>
          <li>上传自己的key 到 VM 的 metadata 中</li>
        </ul>
      </li>
      <li>可以设置 project 禁止某些instance 使用 ssh key
        <ul>
          <li><code class="language-plaintext highlighter-rouge">gcloud compute instances add-metadata [INSTANCE_NAME] --metadata block-project-ssh-keys=TRUE</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>自建 ssh key 连接GCE 的虚机的方法
    <ul>
      <li>两种方法</li>
      <li>
        <ol>
          <li>Meta managed ssh key (Mac 的 ssh 可以用)
```bash
ssh-keygen -t rsa -f ~/.ssh/gc_rsa -C dalongco  //会生成叫做 gc-rsa 的一对公钥和私钥
cd ~/.ssh 
cat gc_rsa.pub   // 这里把输出的公钥内容复制, 黏贴到GCE 的 VM虚机的 metadata 中, 方法是编辑一下VM, 找到SSH 那里, 新建一条, 把这个黏贴进去
chmod 400 gc_rsa   // 修改私钥的可执行权限
ssh -i gc_rsa dalongco@34.125.210.83   //尝试登录</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187</pre></td><td class="code"><pre>  - 2. OS Login 的方法
      - 这个方法不需要自己生成  SSK key
      - 可以在需要多个用户访问项目或者实例的时候使用
      - 方法: 
        - 在 instance 中 的 metadata 中开启 OS login, 让 linux 操作系统中的用户直接访问 instance. 
          - 可以用命令 `gcloud compute project-info/instances add-metadata --metadata enable-oslogin=TRUE`
        - 也可以把 Linux OS 中的已有的  AD 和 LDAP account 导入到google cloud 中
        - 需要有 roles/compute.osLogin or roles/compute.osAdminLogin 权限
  - Windows 的实例, 用户可以用 用户名密码登录
    - 用户名和密码在 console 中 或者 gcloud 命令生成 
      - `gcloud compute reset-windows-password`


##### Instance Group 
- 把多个VM 当做一个实体进行统一管理
- 一个 MIG 只能在一个regional , 但MIG 中的 VMs 可以跨zones 
- 两种IG
  - MIG - managed instance group
    - 用一个instance template 创建的 IG 叫 MIG
    - 可以进行 auto scaling, auto healing 和 管理版本升级(release managemeng)
    - Auto scaling
      - 可以维持固定个数的实例, 如果有一个挂了, 会自动创建另一个一样的实例
      - 可以用 Load balance 分布流量
      - 跨zone 的
      - 可设置最多和最少实例个数
      - 可以根据设定指标自动增减实例个数
        - CPU 使用率
        - LB 的流量负载
        - Stack Driver (一个 google 的监控软件)
      - cool down period
        - 为了防止过于频繁的增减实例, 通过cool down 来设置每次实例变化后要冷静的时间
      - scale in control 
        - 防止实例掉的太猛
        - 比如, 5 分钟内不能掉 10% 或 3 个实例  
      
    - Health check
      - 可以检测实例的健康
      - auto healing
        - 设置个时间段, 让实例启动一会, 应用跑起来了再进行第一次健康检查, 否则以为实例挂了
      - 确保 firewall rule 正常配置了, LB 可以 对 MIG/VM 进行 health check

    - 版本升级 - Release manage 
      - rolling update - 滚动升级
        - 通过给 MIG 原来的 instance template 增加一个新的instance template 来升级实例
        - 给同一个MIG下面的实例升级, 不会有downtime.
        - 升级是可以设置成按批更换, 按百分比或者是个数
        - 可以设置几个几个更新(max surge), 最少保留几个活的实例(max unavailable)
        - Rolling Update for MIG 有两种模式
          - Proactive Update Mode 主动模式
            - 如果希望自动部署更新, 可以选择主动模式
            - 适合关键更新
          - Opportunistic Update Mode 机会模式
            - 如果怕自动更新破坏力太大, 可以选用机会模式
            - 应用的更新需要人工的启动, 并选择哪些实例要被更新, 或新的实例被创建
            - GCE 不会主动的选择用机会模式来更新实例. 
            - 适合非关键更新
      - rolling restart/replace - 滚动重启/替换
        - 滚动重启可以设置是否都重启,还是几个几个重启
        - 滚动替换是用同一个 instance template 生成新的实例来替换现有实例
          - 比如改了 startup script 内容
          - 可以设置几个几个换(max surge), 最少保留几个活的实例(max unavailable)
      - Canary Deployment - 金丝雀部署
        - 对指定的一部分用户进行升级, 其他的不动
        - Deploys a release to a subset of users
  - UMIG - unmanaged instance group
    - IG 下面是不同类型的VM, 或者是无法进行 Horizontal scaling 的应用
    - 不能进行 auto scalling, auto healing 和 管理版本升级
    - 场景: Lift and Shift of on-prem workload that need a load balancer to serve trafic
      - Lift and Shift - 通常指用于将本地资产在不重构的情况下, 迁移到云环境上云方式. 这种方式不会对原有(单体)应用进行微服务化改造, 一般是直接迁移到 云的 VM 环境. 
      - OP 应用接收  TCP请求, 不支持 Horizontal scaling. 需要访问文件系统(file system), 可接受 downtime. 迁移到 GCP 的方案?
        - network LB  + UMIG with active and standby in different zones + regional PD 
           1.   因为是 TCP, 所以 network LB 有更好的performance
           2.   因为不能 HS , 所以 UMIG with active/standby 更合适
           3.   因为 file system, 所以 regional PD 更合适

##### bastion host 堡垒机
- bastion host 是一个特殊功能的 VM 
- 提供用户从 GCP 外部 SSH 到堡垒机, 然后在堡垒机上再对 堡垒机所在的 VPC 的服务进行访问.  
- 在不暴露 VPC 资源的情况下,允许用户从外部访问 GCP 资源
- 使用流程
   1. 在 VPC 中建立一个堡垒机 VM
   1. 给 堡垒机配一个 public IP
   2. 用 SSH 连接到 堡垒机, 再在堡垒机上 SSH 连接到其他 VM
   3. 工作完成了, 把堡垒机关掉


#### Google App Engine - GAE
- GAE 是谷歌提供的 Serverless PaaS
  - Google 负责管理 hardware 和 network infra
- App Engine 是完全托管式无服务器平台，可用于大规模开发和托管 Web 应用。您可以选择多种主流的语言、库和框架来开发应用，然后让 App Engine 为您预配服务器并根据需求扩缩应用实例数量。
- App Engine 和 GKE 的区别
  - App Engine 是基于容器的
  - GKE 是基于 K8s 的
- 支持 Go, Java, .Net, Node.js, PHP, Ruby, python
- 适合web 应用部署
- 按用量付费
  - 如果没有用量, 每天的费用可以降到 0
- 自动的 LB 和 Auto scalling
- 使用前需要先开启 Kubernetes Engine API 
- 需要手动用 gcloud shell 在命令行中部署服务, 创建版本, 分配流量
- 提供端到端的应用管理
  - 代码上传
  - 应用部署
  - 应用版本管理
    - 基于版本的流量分配管理
      - 三种配置
        - 按 IP
        - 按 Cookie
        - 随机 random
  - 应用实例管理
  - 提供应用连接到其他谷歌云服务
- 和 Compute Engine 相比, APP Enginede 
  - 不需要自己管理底层
  - 但是会缺少一些灵活度
- 两种 App engine 环境
  - 两种类型的区别
  - ![](http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-08-062026.jpg)
  - Standard 标准型
    - 应用实例跑在预先配置好的开发语言的沙箱/容器环境中
      - 应用需要遵守沙箱预设的约束条件
      - 只支持部分开发语言 Java Python、PHP Go、Node.js 和 Ruby 
    - V2 比 V1 支持更多的开发语言 ,但也只是特定的语言
    - 无法 ssh 访问底层进程和磁盘
    - 标准型包含了
      - Persistent Storage(可以 query , sorting, transaction)
      - Autoscaling
      - LB
      - Sub/pub
      - Scheduler
      - 其他 API
    - 使用的三个步骤
      - 本地开发
      - 部署到 App Engine
      - App Engine 为应用提供沙箱的安全服务
  - Flexible 灵活型
    - 应用实例跑在Docker 容器中
      - 容器可以是自己提供的容器, 更加灵活
    - 容器跑在虚机上
      - 可以定制化 容器的 Image 和 Docker file
      - 可以定制化VM的OS
      - 应用可以写到本地磁盘上(local disk)
    - 支持任何开发语言
    - 可以 ssh 访问底层的进程和磁盘
    - 可以安装 third-party binaries.
- App Engine 的分层
  - 从上到下
    - application
    - Service
    - Version
    - Instance
  - 备注
    - 一个项目对应一个应用
    - 一个应用可以有多个服务
    - 一个服务可以理解成一个微服务
    - 一个服务可以有多个版本
      - 每个版本对应了不同的代码和配置
      - 多个版本可以共享流量分配
    - 一个版本可以有多个实例, 也可以没有实例. 没有实例的版本也可以运行
      - 实例是由系统自动分配给版本的


- gcloud shell 在命令行中部署服务, 创建版本, 分配流量
  - 步骤:
    1. 将python 的两个服务的代码目录传到 gcloud editor中 我自己的home目录中
    2. 在 gcloud terminal 中进入其中一个目录

```bash
cd default-service 
gcloud app deploy     # 部署这个目录为一个服务
gcloud app services list  
gcloud app versions list  # 已经产生了默认的第一个版本
gcloud app instances list  # 已经产生了自动创建的第一个实例
gcloud app deploy --version=v2  # 修改了代码重新部署. 可以指定版本号, 如果不指定, 默认会有一个新的版本. 默认部署了新的版本, 当前服务就会用最新版本对外服务(接收流量)
gcloud app versions list  
gcloud app browse   # 查看当前的服务的浏览器地址
gcloud app browse --version 20210215t072907  # 查看指定版本服务的浏览器地址
gcloud app deploy --version=v3 --no-promote  # 部署新的版本, 但是不提供对外服务
gcloud app browse --version v3  
watch curl https://melodic-furnace-304906.uc.r.appspot.com/  # 监控网页内容变化, 每秒重新刷新页面
gcloud app services set-traffic --splits=v3=.5,v2=.5 --split-by=random   # 设置不同版本的分流, 分流规则是 random. 
 
cd ../my-first-service/  # 部署另一个服务
gcloud app deploy
gcloud app browse --service=my-first-service
 
gcloud app services list 
gcloud app regions list
</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>GAE 命令总结
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Migrate Traffic</code> 这个参数是用来回滚到之前的版本的</li>
    </ul>
  </li>
</ul>

<h4 id="google-kubernetes-engine---gke">Google Kubernetes Engine - GKE</h4>
<ul>
  <li>谷歌云管理的 K8S 服务</li>
  <li>是 CaaS
    <ul>
      <li>容器的操作系统使用的是基于分享的内核层
        <ul>
          <li>Containers use a shared base operating system stored in a shared kernel layer.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>底层是 Compute Engine (VM 实例)</li>
  <li>GKE 中的 K8s 是自动更新的, 我们不需要管</li>
  <li>比起 App Engine, 更适合复杂的微服务架构, 更灵活</li>
  <li>有自己的 OS - Container-Optimized OS</li>
  <li>GKE 的硬件层级
    <ul>
      <li>硬件的管理用 <code class="language-plaintext highlighter-rouge">gcloud</code> 命令</li>
      <li>从上到下分为几个层级
        <ul>
          <li>Cluster
            <ul>
              <li>是物理概念, 一个集群. 需要先创建集群, 才能部署容器应用</li>
              <li>创建了 Cluster , 默认就会创建一个 Node Pool</li>
              <li>cluster 包含了很多 Compute engine 实例
                <ul>
                  <li>A group of machines where Kubernetes can schedule workloads.</li>
                </ul>
              </li>
              <li>分为 Master Nodes 和 work Nodes
                <ul>
                  <li>Master nodes 管理cluster</li>
                  <li>work nodes 运行workload in pods</li>
                </ul>
              </li>
              <li>Cluster type
                <ul>
                  <li>Single Zone</li>
                  <li>Multi zone</li>
                  <li>reginal</li>
                  <li>private</li>
                  <li>alpha</li>
                </ul>
              </li>
              <li>默认, GEK  cluster 上的nodes 是 有 public IP 地址的. 但是好的practice 是创建一个 private cluster , 让所有的 nodes 只有内网  IP. 外面可以接一个 HTTPS LB 或者 Network LB. 外面再配一个 Cloud NAT 访问外网</li>
            </ul>
          </li>
          <li>Node Pool
            <ul>
              <li>集群中全都具有相同配置的一组节点</li>
              <li>Node Pool 中默认会创建 3 个 Nodes</li>
              <li>可以为 Cluster 增加更多的 Node Pool</li>
              <li>应用场景
                <ul>
                  <li>当我们需要部署一个第三方的, 安全性未知的应用, 最好部署单独的 node pool</li>
                  <li>对于 GPU 有特殊需求的应用, 单独部署一个 node pool</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Node
            <ul>
              <li>集群中的一个工作机器, 可以是一个 VM 或一个实例.</li>
              <li>分为 Master Nodes 和 work Nodes
                <ul>
                  <li>Master nodes 管理cluster
                    <ul>
                      <li>API Server 提供 nodes 之间的通信和对外通信</li>
                      <li>Scheduler 提供 pods 的 替换</li>
                      <li>etcd 是一个分布式存储记录集群状态</li>
                    </ul>
                  </li>
                  <li>work nodes 运行workload in pods
                    <ul>
                      <li>kubelet 是运行在 work notes上跟 master notes 通信的</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>GKE 的软件层级
    <ul>
      <li>软件的管理用 <code class="language-plaintext highlighter-rouge">kubectl</code> 命令</li>
      <li>Deoloyment
        <ul>
          <li>deployment 管理 Pods</li>
          <li>deoployment 代表了一个微服务和微服务的所有release</li>
          <li>默认一个deployment 有一个 instance 对应
            <ul>
              <li>每个instance 都有一个 pod 来运行部署的应用</li>
              <li>刷新页面, 就可以看到两个instance 提供的服务</li>
            </ul>
          </li>
          <li>可以通过在 Console 中编辑 Yaml 来修改 workload</li>
          <li>Replica set (版本) ReplicaSets
            <ul>
              <li>确保 deplyoment 有指定的pods 个数可以运行指定的微服务的某个版本
                <ul>
                  <li>当一个pod 挂了, 马上会创建一个新的</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Service
        <ul>
          <li>expose deployment</li>
          <li>可以理解成 Microservices, 是包含了若干个 Pod</li>
          <li>可以通过在 Console 中编辑 Yaml 来修改 service</li>
          <li>有三种类型的 Service
            <ul>
              <li>Cluster IP
                <ul>
                  <li>只能在集群内部访问的 IP</li>
                </ul>
              </li>
              <li>LoadBalancer
                <ul>
                  <li>可以对外服务, 每个微服务可以有一个 LB</li>
                </ul>
              </li>
              <li>Nodeport,
                <ul>
                  <li>将一个静态端口提供给每个Node’s IP .</li>
                  <li>如果不想给每个微服务都配一个 LB, 就用这个</li>
                  <li>NodePort服务是将外部流量直接发送给您的服务的最原始方式。 顾名思义，NodePort在所有节点（VM）上打开一个特定端口，并且发送到该端口的任何流量都将转发到该服务。</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Service DNS
            <ul>
              <li>让GKE 中的微服务通过内网进行互相访问
                <ol>
                  <li>为每个微服务在 GKE cluster 中创建 Deployment,</li>
                  <li>使用 Service 暴露 deployment</li>
                  <li>通过 Service DNS,  Cluster 中的每个微服务可以和其他微服务进行通信</li>
                </ol>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Ingress
        <ul>
          <li>Ingress是k8s的标准对象，Ingress对象本身只是定义了一系列的流量路由规则，类似nginx.conf配置</li>
          <li>Ingress controller是负载均衡器的实体，由各个厂商独立实现，通过读取ingress的规则进行流量路由。</li>
          <li>提供 LB 和 SSL 终端</li>
          <li>在使用 NodePort的时候, 可以使用 Ingress</li>
        </ul>
      </li>
      <li>Pod
        <ul>
          <li>Pod是 K8S 的最小对象, 包含一个或多个容器，例如Docker 容器
            <ul>
              <li>Pod 里面是容器</li>
            </ul>
          </li>
          <li>pod 部署在worker node 里面</li>
          <li>每个 Pod 有一个临时 IP 地址</li>
          <li>Pod 内的多个容器共享 IP地址, 网络, 磁盘, 端口, volumes.</li>
        </ul>
      </li>
      <li>Docker
        <ul>
          <li>运行应用的独立容器环境</li>
        </ul>
      </li>
      <li>Docker Image
        <ul>
          <li>创建Docker 内容的镜像</li>
          <li>Docker File
            <ul>
              <li>保存了创建一个镜像的命令</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Container Registry
        <ul>
          <li>存放 Docker Image Repository 镜像仓库</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<pre><code class="language-dockerfile">FROM node:8.16.1-alpine     # 基础镜像
WORKDIR /app                # 镜像创建的 Docker 时 的工作目录
COPY . /app                 # 将本地目录的内容拷贝到工作目录
RUN npm install             # 运行一个命令
EXPOSE 5000                 # 暴露一个端口
CMD node index.js           # 启动 Docker 时执行一个命令
</code></pre>

<ul>
  <li>StatefulSet ,是一个 GKE的 一组稳定的, 保持状态的, 有稳定的域名 (hostname) 的 Pods集合. 不管是否会被 redeployment 或重启, 都会保持状态.
    <ul>
      <li>一些场景:
        <ul>
          <li>GKE 中一组 Redis pods 组成的 statefulSet</li>
          <li>GKE 中一组 Cassandra sharding Pods 组成的 statefulSet</li>
          <li>GKE 中一组 MongoDB read replicas 组成的 statefulSet</li>
        </ul>
      </li>
      <li><img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-22-092321.jpg" alt="" /></li>
    </ul>
  </li>
  <li>GKE 的 autoscaling
    <ul>
      <li>GKE Cluster 既支持 Node 的 伸缩(GKE Cluster Autoscaler), 也支持 Pod 的伸缩 (Horizontal Pod Autoscaler)</li>
      <li>在 deployment 中开启
        <ul>
          <li>开启 GKE cluster 的 autoscaling 选项</li>
          <li>开启 horizontal Pod autoscaling 选项
            <ul>
              <li>一旦开启 Horizontal Pod autoscaling, pod 个数会随着流量的大小而变化</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>sidecar container
    <ul>
      <li>Sidecar containers let you run two tightly coupled containers together. In this article, you’ll learn when and how to use sidecar containers, as well as best practices for using them.</li>
      <li>案例
        <ul>
          <li>php 应用提供上传照片功能, C 应用负责压缩照片, 两个应用用 sidecar container 进行捆绑提高效率.</li>
          <li>日志记录应用和日志分析应用捆绑</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Cloud Operations for GKE
    <ol>
      <li>You can view a cluster’s key metrics, such as CPU utilization, memory utilization, and the number of open incidents.</li>
      <li>You can view clusters by their infrastructure, workloads, or services.</li>
      <li>You can inspect namespaces, nodes, workloads, services, pods, and containers.</li>
      <li>For pods and containers, you can view metrics as a function of time and view log entries.</li>
      <li>注意: Cloud Operation 只能服务于在 GCP 上的 GKE cluster 的监控,  GCP之外的服务无法监控; 如果需要多云混合云的监控, <a href="https://cloud.google.com/stackdriver/docs/managed-prometheus">Google Cloud Managed Service for Prometheus</a> 更合适</li>
    </ol>
  </li>
  <li>Istio
    <ol>
      <li>Istio 是个基于 K8s 的 开源 Service Mesh 扩展.
        <ol>
          <li>提供统一的微服务 连接, 管理和安全服务.</li>
          <li>提供服务间的流量管理, 比如断掉某个服务的流量(模拟这个服务挂了 - Faul Injection)</li>
          <li>不需要修改微服务代码</li>
        </ol>
      </li>
      <li>Istio 提供
        <ol>
          <li>HTTP、gRPC、WebSocket、MongoDB 和 TCP 流量的自动负载平衡。</li>
          <li>通过丰富的路由规则、重试、故障转移和故障注入对流量行为进行精细控制。 支持访问控制、速率限制和配额的可配置策略层和 API。</li>
          <li>集群内所有流量（包括集群入口和出口）的自动指标、日志和跟踪。 通过基于身份的强身份验证和授权，保护群集中的服务到服务通信。</li>
          <li>GKE 上的 Istio 是一个工具，可以在您的 GKE 集群中自动安装和升级 Istio。当您升级 GKE 时，该附加组件会自动升级到最新的 GKE 支持的 Istio 版本。这使您可以轻松地管理 Istio 的安装和升级，作为 GKE 集群生命周期的一部分。</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>使用 GKE 的场景
    <ul>
      <li>优化 GKE 并且降低成本
        <ul>
          <li>方案:
            <ul>
              <li>尝试使用临时的 VM, 选合适的region, 用 committed discount</li>
              <li>使用 E2, 不要用 N1</li>
              <li>必要的话使用 多个 node pool</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>需要一个完整高效的 auto scaling 的 GKE
        <ul>
          <li>方案:
            <ul>
              <li>配置 HPA, horizontal pod autoscaler
                <ul>
                  <li><code class="language-plaintext highlighter-rouge">kubectl autoscale deployment</code></li>
                </ul>
              </li>
              <li>配置 cluster autoscaler for node pools
                <ul>
                  <li><code class="language-plaintext highlighter-rouge">gcloud container cluster update --enable-autoscaling</code></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>需要再 GKE 中运行不可信的第三方代码
        <ul>
          <li>方案:
            <ul>
              <li>通过 GKE Sandbox 创建新的 node pool , 把代码部署上来</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>希望 GKE 中的 cluster 只进行内网通信
        <ul>
          <li>方案:
            <ul>
              <li>服务类型选择 ClusterIP</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>发现 pod 一直是 Panding 状态
        <ul>
          <li>可能是 Pod 不能被正常 schedule 到Node 上</li>
        </ul>
      </li>
      <li>发现 pod 一直是 Waiting 状态
        <ul>
          <li>可能是 镜像 pull 不下来</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>CI/CD 安全
    <ul>
      <li>Binary authorization (可以去本文的Binary authorization专门章节看)</li>
    </ul>
  </li>
  <li>Standard GKE 的创建过程
    <ul>
      <li>创建一个新的项目</li>
      <li>先开启 GKE 的 API</li>
      <li>创建一个 Cluster (这里选Standard 版本)</li>
      <li>Login to Cloud Shell</li>
    </ul>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></td><td class="code"><pre>gcloud config <span class="nb">set </span>project my-kubernetes-project-372302   <span class="c"># switch 到新的项目</span>
gcloud container clusters get-credentials my-cluster --zone us-central1-c --project my-kubernetes-project-372302  <span class="c"># 获取连接到 Kubernetes Cluster 的认证, 获取后就可以用k8s命令了</span>
kubectl create deployment hello-world-rest-api --image<span class="o">=</span>in28min/hello-world-rest-api:0.0.1.RELEASE  <span class="c"># 用 K8s 的命令创建一个github 的镜像生成的 deployment  </span>
kubectl get deployment  <span class="c"># 查看deployment情况</span>
kubectl expose deployment hello-world-rest-api --type<span class="o">=</span>LoadBalancer --port<span class="o">=</span>8080  <span class="c"># 将 workload 暴露成 Service, 给外部用户. </span>
kubectl scale deployment hello-world-rest-api --replicas<span class="o">=</span>2  <span class="c"># 为 deployment 增加一个 pod (默认只有一个, 这里增加了1 个, 是replica set)</span>
kubectl get deployment  
watch curl http://34.29.41.99:8080/hello-world  <span class="c"># 查看LB 下不同实例返回的结果</span>
kubectl get pods  <span class="c"># 查看pods </span>

gcloud container clusters resize my-cluster --node-pool default-pool --num-nodes 5 --zone us-central1-c  <span class="c"># 增加 Node 的个数到 5 个</span>

kubectl autoscale deployment hello-world-rest-api --max<span class="o">=</span>4 --cpu-percent<span class="o">=</span>70  <span class="c"># 设置auto scaling , 最大pod 个数增加为 4 个, 检测 CPU 时用率</span>
kubectl get hpa  <span class="c"># Horizential Pods Autoscaling</span>
kubectl create configmap hello-world-config --from-literal<span class="o">=</span><span class="nv">RDS_DB_NAME</span><span class="o">=</span>todos  <span class="c"># 增加配置参数</span>
kubectl get configmap
kubectl describe configmap hello-world-config <span class="c"># </span>
kubectl create secret generic hello-world-secrets-1 --from-literal<span class="o">=</span><span class="nv">RDS_PASSWORD</span><span class="o">=</span>dummytodos <span class="c"># 创建密码</span>
kubectl get secret
kubectl describe secret hello-world-secrets-1


kubectl apply -f deployment.yaml   <span class="c"># 应用 yaml 的配置(当修改了 Yaml 文件后应这个命令) </span>
gcloud container node-pools create POOL_NAME --cluster CLUSTER_NAME  <span class="c"># 创建一个新的 Node pool</span>
gcloud container node-pools list --zone<span class="o">=</span>us-central1-c --cluster<span class="o">=</span>my-cluster  
kubectl get pods -o wide   <span class="c"># 查看pods 的完整信息列表, 包含了外部 IP 地址</span>
 
kubectl <span class="nb">set </span>image deployment hello-world-rest-api hello-world-rest-api<span class="o">=</span>in28min/hello-world-rest-api:0.0.2.RELEASE  <span class="c">## 为服务创建一个新的release(版本 0.0.2) </span>
kubectl get services  
kubectl get replicasets  
kubectl get pods
kubectl delete pod hello-world-rest-api-58dc9d7fcc-8pv7r   
 
kubectl scale deployment hello-world-rest-api --replicas<span class="o">=</span>1  
kubectl get replicasets  
gcloud projects list
 
kubectl delete service hello-world-rest-api  <span class="c"># 删除服务</span>
kubectl delete deployment hello-world-rest-api  <span class="c"># 删除deployment / workstream</span>
gcloud container clusters delete my-cluster --zone us-central1-c  <span class="c"># 删除 custer 集群</span>
gcloud projects delete my-kubernetes-project-372302  <span class="c"># 删除项目</span>
</pre></td></tr></tbody></table>
</div>
</div>
<ul>
  <li>命令强调
    <ul>
      <li>nodes pool 大小调整用 resize 参数</li>
      <li>nodes 的 autoscaling 的 最大最小nodes 限制使用 update 参数.</li>
    </ul>
  </li>
  <li>yaml 文件的例子 - deployment
    <ul>
      <li>修改后用<code class="language-plaintext highlighter-rouge">kubectl apply -f deployment.yaml</code> 来应用更新
        <div class="language-yaml highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><pre><span class="s">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="s">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="s">metadata</span><span class="pi">:</span>
<span class="s">labels</span><span class="pi">:</span>
    <span class="s">app</span><span class="pi">:</span> <span class="s">hello-world-rest-api</span>
<span class="s">name</span><span class="pi">:</span> <span class="s">hello-world-rest-api</span>
<span class="s">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="s">spec</span><span class="pi">:</span>
<span class="s">replicas</span><span class="pi">:</span> <span class="s">3</span>
<span class="s">selector</span><span class="pi">:</span>
    <span class="s">matchLabels</span><span class="pi">:</span>
        <span class="s">app</span><span class="pi">:</span> <span class="s">hello-world-rest-api</span>
<span class="s">template</span><span class="pi">:</span>
    <span class="s">metadata</span><span class="pi">:</span>
        <span class="s">labels</span><span class="pi">:</span>
            <span class="s">app</span><span class="pi">:</span> <span class="s">hello-world-rest-api</span>
    <span class="s">spec</span><span class="pi">:</span>
        <span class="s">containers</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">image</span><span class="pi">:</span> <span class="s1">'</span><span class="s">in28min/hello-world-rest-api:0.0.3.RELEASE'</span>
              <span class="s">name</span><span class="pi">:</span> <span class="s">hello-world-rest-api</span>
</pre></td></tr></tbody></table>
</div>
        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="cloud-functions">Cloud Functions</h4>
<ul>
  <li>需要先开启 Cloud Funciton API, Google Pub/Sub API, Cloud Logging API , Cloud Build API, Cloud Storage API, Cloud firestore API, Eventarc API.</li>
  <li>事件驱动型 Serverless 平台, 不需要关心底层架构, autoscaling .</li>
  <li>用户选择 Cloud Function 的原因:
    <ul>
      <li>应用程序包含事件驱动代码, 用户不想为其配置其他计算资源</li>
      <li>Cloud Function 可以无缝的 scaling</li>
    </ul>
  </li>
  <li>Cloud Functions 对代码的部署方式施加了更多限制（显然易见，您需要将其打包为一个函数）</li>
  <li>Cloud Function v2 在后台其实是运行在 Cloud Run 上面的
    <ul>
      <li>当创建了一个新的 Cloud Function, 也可以在 Cloud Run 看到对应的服务</li>
    </ul>
  </li>
  <li>适合被动被调用, 短时间计算的逻辑, 不适合长期运行的应用</li>
  <li>计费
    <ul>
      <li>按调用时间, 请求次数, 内存 cpu 消耗情况计费</li>
    </ul>
  </li>
  <li>超时
    <ul>
      <li>默认function 执行 1 分钟就会自动停掉. 最大可以设置超时时间为 60 分钟</li>
      <li>function v1 最大9 分钟, v2 是 60 分钟</li>
    </ul>
  </li>
  <li>触发场景例子
    <ul>
      <li>文件上传到 Cloud Storage</li>
      <li>Error log 写到了 Cloud Logging</li>
      <li>一条消息传到了 Cloud Pub/Sub (消息队列)</li>
      <li>一个 Http/Https 的网页或 Rest API 被调用</li>
      <li>Firebase</li>
      <li>Cloud Firestore</li>
      <li>Stack driver logging</li>
    </ul>
  </li>
  <li>怎么让两个 Cloud Function 的一个调用另一个?
    <ol>
      <li>给 function B “request authentication”</li>
      <li>创建一个 service account, 并关联到 function a 上</li>
      <li>为 service accoutn 赋予 访问 function b 的权限</li>
      <li>在 function a 中创建一个 ID token , 当a 调用 b 的时候, 把这个 token pass 过去.</li>
    </ol>
  </li>
  <li>支持语言
    <ul>
      <li>.net</li>
      <li>java</li>
      <li>php</li>
      <li>python</li>
      <li>go</li>
      <li>ruby</li>
      <li>node.js</li>
    </ul>
  </li>
  <li>V1 和 V2 的区别
    <ul>
      <li>V2是基于Cloud Run and Eventarc</li>
      <li>V2 增强了
        <ul>
          <li>Longer Request timeout: Up to 60 分钟
            <ul>
              <li>V1 9分钟</li>
            </ul>
          </li>
          <li>Larger instance sizes: Up to 16GiB RAM with 4 vCPU
            <ul>
              <li>V1 8G 2vCPU</li>
            </ul>
          </li>
          <li>Concurrency: Upto 1000 concurrent requests per function instance
            <ul>
              <li>V1 一个并发
                <ul>
                  <li>V1 默认是一个funciton 处理一个请求, 如果第二个请求来了, autoscaler 会创建第二个function 来处理第二个请求, 但这时个cold start(冷创建, 有个创建过程)</li>
                  <li>解决方法是设置最少的默认function 实例个数, 或者用 V2</li>
                </ul>
              </li>
              <li>V2 虽然支持1000并发, 但我们要自己负责代码的并发可以被安全的执行.</li>
            </ul>
          </li>
          <li>Multiple Function Revisions and Traffic splitting supported
            <ul>
              <li>V1 不支持</li>
            </ul>
          </li>
          <li>Support for 90+ event types - enabled by Eventarc
            <ul>
              <li>V1 支持 7 个</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>HTTP 请求 Node.js 的function 样例
    <div class="language-javascript highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="kr">const</span> <span class="nx">escapeHtml</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'escape-html'</span><span class="p">);</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">helloHttp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="err">`</span><span class="nx">Hello</span> <span class="nx">$</span><span class="p">{</span><span class="nx">escapeHtml</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">name</span> <span class="o">||</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">name</span> <span class="o">||</span> <span class="s1">'World'</span><span class="p">)}</span><span class="o">!</span><span class="err">`</span><span class="p">);</span>
<span class="p">};</span>
</pre></td></tr></tbody></table>
</div>
    </div>
  </li>
  <li>命令行操作 function
    <ul>
      <li><code class="language-plaintext highlighter-rouge">gcloud functions deploy [NAME]</code></li>
      <li>参数
        <ul>
          <li>–gen2 第二代</li>
          <li>–runtime 指定语言</li>
          <li>–timeout 超时时间</li>
          <li>–max-instances, –min-instances  最大, 最小实例个数</li>
          <li>–source 指定源代码</li>
          <li>–trigger-bucket 触发方式</li>
          <li>–serve-all-traffic-latest-revision 指定服务的版本</li>
          <li>–docker-registry, –docker-repository 存放镜像位置</li>
          <li>–service-account  设置服务账号</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>function 的最佳实践
    <ul>
      <li>为了避免cold start, 设置 min 最小实例个数 (成本会相应升高)</li>
      <li>为了加快实例启动时间, 尽量减少function 的依赖关系</li>
      <li>设置max 最大实例数, 可以避免异常的超大流量带来的额外费用</li>
    </ul>
  </li>
  <li>用Cloud Endpints (或 APIgee 或 API gateway) 给 function 设置版本, 方便用户可以访问不同的版本的function
    <ul>
      <li>用 V2 的 function, 可以在不同版本间分配流量, 可以rollback 到之前的版本</li>
      <li>用 Secret Manager 管理 API 的  Key</li>
      <li>为每个 function 设置不同的 service account, 让function 之间调用可以更安全
        <ul>
          <li>Grant roles/cloudfunctions.invoker role to invoke a cloud function</li>
        </ul>
      </li>
      <li>通过 npm, pip 等包管理工具来管理 function 的依赖</li>
    </ul>
  </li>
</ul>

<h4 id="google-cloud-run">Google Cloud Run</h4>
<ul>
  <li>和 function 很像, 但是支持所有的开发语言, 有更长的超时时间, 可以同时接受更多的请求数.</li>
  <li>就是无服务版本的 GKE, 用 GKE 的用户建议迁到这个 Cloud Run</li>
  <li>也是 serverless</li>
  <li>基于 Knative 构建， 是 Google 最新的 Serverless 产品。</li>
  <li>方便在不同的云上迁移, 因为是基于容器的</li>
  <li><strong>使您可以将代码打包在无状态容器中，然后通过 HTTP 请求(Web, pub/sub)调用它</strong></li>
  <li>开发者用 Cloud Run 的三步流程
    <ul>
      <li>write code</li>
      <li>build and package app in container</li>
      <li>deploy to cloud run
        <ul>
          <li>Cloud Run 只能deploy 放在 Artifact Registry 中的 Image</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>三种无服务(App Engine, Cluod Function, Cloud Run)的选择
    <ul>
      <li>如果您已经将代码打包在 Docker 容器中或正在 Google Cloud 中运行 Kubernetes 集群，请针对您的 Serverless 工作负载考虑使用 Cloud Run 或 Knative。</li>
      <li>对于运行响应实时事件的代码，或在不使用容器的情况下处理请求，请使用 Cloud Functions。
        <ul>
          <li>Cloud Function 在后台其实是运行在 Cloud Run 上面的</li>
        </ul>
      </li>
      <li>如果您需要在一个地方放置多个函数并且只想部署整个应用程序，请使用 App Engine。</li>
    </ul>
  </li>
  <li>集成了诸多 GCP 的服务
    <ul>
      <li>Cloud Code</li>
      <li>Cloud Build</li>
      <li>Cloud Monitoring</li>
      <li>Cloud Logging</li>
    </ul>
  </li>
  <li>CI/CI 安全
    <ul>
      <li>Binary authorization (可以去专门章节看)</li>
    </ul>
  </li>
  <li>Pricing
    <ul>
      <li>两种收费模式
        <ul>
          <li>仅在请求处理期间分配 CPU
            <ul>
              <li>没有请求就不分配 CPU , 就不用付费</li>
              <li>前 n 次请求免费, 超量收费</li>
            </ul>
          </li>
          <li>始终分配 CPU
            <ul>
              <li>没请求也分配 CPU</li>
              <li>前 n 次请求免费, 超量收费</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Anthos
    <ul>
      <li>是一个集成环境, 可以让 K8s 在任何地方运行
        <ul>
          <li>私有机房/on premise</li>
          <li>公有云(AWS, Azure, 等)</li>
          <li>Cloud Run 可以运行在 anthos 上</li>
          <li>相当于 OpenShift</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>场景
    <ul>
      <li>如果有容器应用, 但是觉得管理麻烦, 就用 Cloud Run</li>
      <li>如果觉得到处(on-premise, 公有云)管理 K8S 太麻烦, 就用 Cloud Run for Anthos</li>
    </ul>
  </li>
  <li>命令行对 Cloud run 创建, 查看, 切换流量
    <div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>gcloud run deploy SERVICE-NAME --image IMAGE-URL --revision-suffix v1  
gcloud run revisions list
gcloud run services update-traffic myservice --to-revisions<span class="o">=</span><span class="nv">v2</span><span class="o">=</span>10,v1<span class="o">=</span>90
</pre></td></tr></tbody></table>
</div>
    </div>
  </li>
</ul>

<h4 id="gce-gke-gae-function-cloud-run-区别">GCE, GKE, GAE, Function, Cloud RUN 区别</h4>
<ul>
  <li>GCE 是 VM</li>
  <li>GKE 是 K8s 协调平台, 管容器</li>
  <li>GAE 是 无服务的, 预设场景的, 支持多语言的开发环境, 比如弄个web 网站</li>
  <li>Function 无服务的, 支持多语言的, 提供事件响应的一段函数, 有运行时间限制</li>
  <li>Cloud Run 是无服务的 GKE, Function 的底层就是这个.</li>
</ul>

<h4 id="容器所在的服务选择流程图">容器所在的服务选择流程图</h4>

<p><img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-20-100446.jpg" alt="" /></p>

<h3 id="storage">Storage</h3>
<ul>
  <li>块存储和文件存储</li>
  <li>Block Storage 块存储
    <ul>
      <li>我们电脑的硬盘就是块存储</li>
      <li>块存储 和 VM 是多对一(含一对一)的关系
        <ul>
          <li>read only 的 block storage 可以 attach 到多个 VM 上</li>
        </ul>
      </li>
      <li>两种使用方法
        <ul>
          <li>DAS
            <ul>
              <li>direct attached storage, 直连</li>
            </ul>
          </li>
          <li>SAN, Storage Area Network
            <ul>
              <li>连到一个磁盘池, 有更高的网络连接</li>
              <li>用在数据库场景</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Google 提供的两种块存储
        <ul>
          <li>Persistent Disks</li>
          <li>Local SSDs (SSD)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>File Storage 文件存储
    <ul>
      <li>Filestore 是google</li>
    </ul>
  </li>
  <li>SAN 和 NAS 的区别
    <ul>
      <li>Storage Area Network 是块存储, 存储结构化数据, 比如数据库. 所以和 PD 相关连</li>
      <li>NAS 是文件存储, 往往存储视频和图片. 既可以和 PD 关联, 也可以和 Cloud Storage 关联.
        <h4 id="persistent-disks-pd">Persistent Disks (PD)</h4>
      </li>
    </ul>
  </li>
  <li>是网络块存储</li>
  <li>持久性更好
    <ul>
      <li>可以使用regional PD, 在 2 个zone 都有磁盘, 但会产生 2x 的价格</li>
      <li>也可以使用 zonal PD 价格更便宜, 一般是给数据库用比较合适</li>
    </ul>
  </li>
  <li>可以随意增加 Size , 而不用停机
    <ul>
      <li>Step I: Resize the Disk</li>
      <li>Step II: Take a snapshot (Just for backup in case things go wrong!)</li>
      <li>Step III: Resize the file system and partitions</li>
    </ul>
  </li>
  <li>可以为 VM attache 新的 PD 不用停机
    <ul>
      <li>三个步骤:
        <ul>
          <li>A: Attach Disk to running or stopped VM</li>
          <li>B: Format the disk</li>
          <li>C: Mount the disk</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>单独的生命周期, 不和 VM 生命周期绑定
    <ul>
      <li>可以detach and attach 给另一个 VM</li>
    </ul>
  </li>
  <li>可以 regional, Regional PD 复制磁盘到同一个region 的另一个zone.</li>
  <li>提升性能的方法
    <ul>
      <li>增加 PD size</li>
      <li>增加 PD 的个数</li>
    </ul>
  </li>
  <li><strong>Snapshot</strong>
    <ul>
      <li>快照是从 PD 定期生成的一个磁盘映像(很快, 是增量的). 镜像可以生成 PD (慢, 因为要多个镜像才能生成完整的 PD)
        <ul>
          <li>如果需要频繁的把镜像还原成 disk, 可以考虑把镜像创建成image, image 生成disk 很快.</li>
        </ul>
      </li>
      <li>可以schedule snapshot 生成的计划</li>
      <li>可以设置snapshot 创建多久后被自动删除
        <ul>
          <li>镜像被删除, 其实只是删除了其他镜像不需要的数据, 不用担心.</li>
        </ul>
      </li>
      <li>snapshot 可以跨region, 跨项目</li>
      <li>新的snapshot 是增量的, 只对最新变化的内容做快照
        <ul>
          <li>第一个snapshot 是全量</li>
          <li>后面的snapshot 是针对第一个snapshot 的变化而生成的增量 snapshot</li>
          <li>如果多个快照(比如 4 个), 中间两个被删掉了
            <ul>
              <li>删除的快照会被标记为已删除</li>
              <li>如果被删除的快照没有被其他快照依赖它, 直接删除</li>
              <li>如果被删除的快照 有其他快照依赖它
                <ol>
                  <li>所有快照上的被依赖的数据会被拷贝到后一个快照上 (第四个)</li>
                  <li>所有快照上的不被依赖的数据会被删除.</li>
                  <li>后一个快照将不再依赖这个被标记删除的快照, 而是依赖被删除的快照的前一个快照(第一个).</li>
                  <li><img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-13-152031.jpg" alt="" /></li>
                </ol>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>如果要删除快照上的数据, 就要删除所有快照</li>
      <li>建议
        <ul>
          <li>在流量低谷时做快照</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>PD 也分三种类型
    <ul>
      <li>Standard PD
        <ul>
          <li>HDD 机械硬盘</li>
          <li>性能一般, 最便宜</li>
        </ul>
      </li>
      <li>Balanced PD
        <ul>
          <li>SSD 固态硬盘</li>
          <li>性能好, 价格适中</li>
        </ul>
      </li>
      <li>SSD PD
        <ul>
          <li>SSD 固态硬盘</li>
          <li>性能最好, 价格最贵</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>可以通过 <code class="language-plaintext highlighter-rouge">resize2fs</code> 命令来给VM 的 PD 扩容 (只能增,不能减)
    <ul>
      <li>场景, 给正在运行的 VM 上的 数据库的 PD 扩容磁盘
        <ul>
          <li>先扩磁盘, 再扩文件系统和分区</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="local-ssds-ssd">Local SSDs (SSD)</h5>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre>  - 本地块存储
  - 物理 attache 到 VM 上
  - 提供临时的数据存储服务
  - 和 VM 有共同的生命周期
    - 不能 detach and attach 给另一个 VM
    - 和 VM 一样是 zonal
  - 提供更高的 IOPS 和 低延迟
    - SSD size 越大, vCPU 越多, 性能越好
    - 10 - 100 倍于 PD
  - 只有部分 machine type 支持 Local SSD
  - 支持 SCSI 和 NVMe 接口
    - Choose NVMe-enabled and multi-queue SCSI images for best performance
  - 不支持 Snapshot
</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="filestore">Filestore</h4>
<ul>
  <li>File Storage 文件存储
    <ul>
      <li>Box 就算文件存储</li>
      <li>一般用于媒体文件</li>
    </ul>
  </li>
  <li>是 Google 提供的高性能文件存储服务</li>
  <li>需要先开启 Filestore API</li>
  <li>创建时是创建了一个Filestore instance , 这个 instance 是一个google 管理的网络文件系统(NFS), 可以被 GCE, GKE 进行连接和使用</li>
  <li>创建后会生成一个NFS mount 点 <code class="language-plaintext highlighter-rouge">10.88.42.58:/dalongShare</code> 供计算服务进行mount</li>
  <li>支持 NFS v3 protocol</li>
  <li>up to 320TB , 16GB/s, 480k IOPS</li>
  <li>支持 HDD 和 SSD</li>
  <li>场景</li>
  <li>文件共享, 流媒体, 内容管理, 应用对 POSIX 文件系统高速的读写
    <ul>
      <li>Cloud Filestore is POSIX complaint.</li>
    </ul>
  </li>
  <li>NAS (Network attached storage)</li>
  <li>POSIX
    <ul>
      <li>POSIX: Portable Operating System Interface of Unix.，可移植操作系统接口</li>
      <li>目的是提高应用程序在不同操作系统之间的可移植性</li>
      <li>技巧: 提到 POSIX 就是 Filestore</li>
    </ul>
  </li>
</ul>

<h4 id="machine-images">Machine Images</h4>
<ul>
  <li>给一个 VM 做完整的 image</li>
  <li>是类似 Images, 但是支持多个磁盘attache 到 VM 时, 给VM instance 做镜像
    <ul>
      <li>Custom Image 一般只是给boot 磁盘做一个 Image, 包含了 OS 和已经安装的软件</li>
      <li>Macine Image 是给  VM 做一个完整的Image</li>
    </ul>
  </li>
  <li>一个 Machine Image 包含了
    <ul>
      <li>configuration</li>
      <li>metadata</li>
      <li>permissiions</li>
      <li>data from one or more disks</li>
    </ul>
  </li>
  <li>场景
    <ul>
      <li>磁盘备份, 实例clone 和 复制</li>
    </ul>
  </li>
  <li>
    <p><a href="https://cloud.google.com/compute/docs/machine-images">Macine Image 和 Snapshot, Custom Image, Instance Template 的对比</a></p>
  </li>
  <li>Global, Regional and Zonal Resources 比较
    <ul>
      <li>Global
        <ul>
          <li>Images</li>
          <li>Snapshots</li>
          <li>Instance templates (Unless you use zonal resources in your templates)</li>
        </ul>
      </li>
      <li>Regional
        <ul>
          <li>Regional managed instance groups</li>
          <li>Regional persistent disks</li>
        </ul>
      </li>
      <li>Zonal
        <ul>
          <li>Zonal managed instance groups</li>
          <li>Instances</li>
          <li>Persistent disks
            <ul>
              <li>You can attach a disk only to instances in the same zone as the disk</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="google-cloud-storage">Google Cloud Storage</h4>
<ul>
  <li>谷歌提供的对象存储是 <strong>Cloud Storage</strong>, 相当于 AWS 的 S3</li>
  <li>题目如果说到了 data lake (数据湖), 往往是 Cloud Storage</li>
  <li>对象存储在bucket 中, 需要先创建bucket, 再上传对象
    <ul>
      <li>bucket 名字需要全球唯一, 3-36 个字符 (小写字母,数字,下划线,中划线,点)</li>
      <li>bucket 名字不能包含 <code class="language-plaintext highlighter-rouge">goog</code></li>
      <li>bucket 要属于某个project</li>
      <li>bucket 中的对象个数不受限制</li>
      <li>对象上传不支持 partial upload (分块上传)</li>
      <li>单个对象最大 5T</li>
      <li>每个对象有一个unique key</li>
    </ul>
  </li>
  <li>无服务, autoscaling, 无限扩容</li>
  <li>提供 Rest API , 命令行(gsutil) 进行访问</li>
  <li>对象储存(object storage)的分类
    <ul>
      <li>Standard Storage
        <ul>
          <li>随存随取, hot data</li>
        </ul>
      </li>
      <li>Nearline Storage
        <ul>
          <li>30 天取一次, once per month</li>
        </ul>
      </li>
      <li>Coldline Storage
        <ul>
          <li>60/90 天读一次</li>
        </ul>
      </li>
      <li>Archive Storage
        <ul>
          <li>1 年读一次</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>可以跨region
    <ul>
      <li>99.95 for multi-region (不含 archive)</li>
      <li>99.99 for single-region (不含 archive)</li>
    </ul>
  </li>
  <li>版本 version
    <ul>
      <li>防止数据被误删除或者误修改</li>
      <li>bucket level 随时开关</li>
      <li>和 duration 功能有冲突, 只能二选一</li>
    </ul>
  </li>
  <li>Lifecycle 管理
    <ul>
      <li>可以把对象按照计划改变分类(standard -&gt; newrline -&gt; coldline -&gt; artchive)
        <ul>
          <li>和设置多个条件组合</li>
        </ul>
      </li>
      <li>可以设置多久后删掉
        <ul>
          <li>要写一个 JSON 格式的 lifecycle management rule (配置多久删掉什么object) , 并用 gsutil 命令 把他 push 到bucket 中生效</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Bucket lock
    <ul>
      <li>如果企业对数据的合规性有要求, 可以通过 lock 来锁定设置的规则.</li>
      <li>data retention policy 被锁定, 确保数据可以保留我们希望的时间, 规则不会被删除. 保存时间不但能被缩短, 但可以延长.</li>
      <li>retention policy 负责数据保留多久, retention lock 负责在保留期间内数据不会被改动(包括删除).</li>
      <li>lifecycle policy 是多久可以把一个 object 挪到另一个 bucket level 或删掉. 只有过了 retention policy 的约定时间的 object 才会被 lifecycle policy 删除.</li>
    </ul>
  </li>
  <li>Encryption 加密
    <ul>
      <li>默认用 server-side 加密
        <ul>
          <li>server side 加密分为
            <ul>
              <li>Google-managed
                <ul>
                  <li>默认的, 不需要配置, google 创建key, 管理 key, 对对象进行加密</li>
                </ul>
              </li>
              <li>Customer-managed
                <ul>
                  <li>google 创建key, Cloud KMS 管理key, 客户通过key 对数据进行加密解密</li>
                </ul>
              </li>
              <li>Customer-supplied
                <ul>
                  <li>客户自己的key, 在服务端对数据进行加密解密</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>client side encryption
            <ul>
              <li>客户在上传前就完成了数据加密, 客户收到收据后自己解密, 和google 一点关系没有.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>对象的 metadata
    <ul>
      <li>每个对象存储好后都会有 metadata</li>
      <li>是 key pair 数据</li>
      <li>metadata 分为
        <ul>
          <li>Fixed-key metadata
            <ul>
              <li>key 固定的, 不能改, 但value 可以随便改</li>
              <li>比如: Cache-Control, Content-Disposition, Content-Type</li>
            </ul>
          </li>
          <li>Custom metadata
            <ul>
              <li>key 和 value 都是自己创建的, 随便定义随便增删改</li>
            </ul>
          </li>
          <li>Non-editable metadata
            <ul>
              <li>google 预定义好的 metadata, 只能看, 不能删改</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>数据迁移
    <ul>
      <li>如果想把数据迁移到 object storage, 有几种方法
        <ul>
          <li>gsuitl or API or console
            <ul>
              <li>适用于一次性的, 数据量较少(小于 1T )的迁移</li>
              <li>适用于从 on premise 到 object storage 的迁移, 或 bucket 之间的迁移</li>
              <li>成本低</li>
            </ul>
          </li>
          <li>Storage Transfer Service
            <ul>
              <li>使用与大规模数据迁移 (1-20T)</li>
              <li>是适用于从  on premise, aws, azure, google cloud迁移到 object storage</li>
              <li>可提供可重复的增量迁移.</li>
              <li>有容错机制, 从哪里失败了, 还可以继续.</li>
              <li>稳定</li>
            </ul>
          </li>
          <li>Transfer Appliance
            <ul>
              <li>相当于 AWS 的 snow 系列硬件</li>
              <li>适合 20T 以上的迁移, 适合带宽低, 时间久的场景</li>
              <li>先预定硬件, 到货了把数据拷贝到硬件上, 然后寄回给google. google 工程师帮你把数据拷贝到 bucket 中</li>
              <li>快, 量大</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>gsutil 命令行</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><pre>gsutil mb gs://BKT_NAME <span class="c"># (Create Cloud Storage bucket)</span>
gsutil ls -a gs://BKT_NAME <span class="c">#  (List current and non-current object versions) </span>
gsutil cp gs://SRC_BKT/SRC_OBJ gs://DESTN_BKT/NAME_COPY <span class="c"># (Copy objects) # -o 'GSUtil:encryption_key=ENCRYPTION_KEY' - Encrypt Object gsutil mv (Rename/Move objects)</span>
gsutil mv gs://BKT_NAME/OLD_OBJ_NAME gs://BKT_NAME/NEW_OBJ_NAME
gsutil mv gs://OLD_BUCKET_NAME/OLD_OBJECT_NAME gs://NEW_BKT_NAME/NEW_OBJ_NAME
gsutil rewrite -s STORAGE_CLASS gs://BKT_NAME/OBJ_PATH <span class="c"># (Ex: Change Storage Class for objects) # gsutil cp : Upload and Download Objects</span>
gsutil cp LOCAL_LOCATION gs://DESTINATION_BKT_NAME/ <span class="c"># (Upload)</span>
gsutil cp gs://BKT_NAME/OBJ_PATH LOCAL_LOCATION <span class="c"># (Download)</span>

gsutil versioning <span class="nb">set </span>on/off gs://BKT_NAME <span class="c"># (Enable/Disable Versioning)</span>
gsutil uniformbucketlevelaccess <span class="nb">set </span>on/off gs://BKT_NAME
gsutil acl ch <span class="c"># (Set Access Permissions for Specific Objects)</span>
gsutil acl ch -u AllUsers:R gs://BKT_NAME/OBJ_PATH <span class="c"># (Make specific object public)</span>
gsutil acl ch -u john.doe@example.com:WRITE gs://BKT_NAME/OBJ_PATH <span class="c"># Permissions - READ (R), WRITE (W), OWNER (O) # Scope - User, allAuthenticatedUsers, allUsers(-u), Group (-g), Project (-p) etc</span>
gsutil acl <span class="nb">set </span>JSON_FILE gs://BKT_NAME
gsutil iam ch MBR_TYPE:MBR_NAME:IAM_ROLE gs://BKT_NAME <span class="c"># (Setup IAM role)</span>
gsutil iam ch user:me@myemail.com:objectCreator gs://BKT_NAME
gsutil iam ch allUsers:objectViewer gs://BKT_NAME <span class="c"># (make the entire bucket readable)</span>
gsutil signurl -d 10m YOUR_KEY gs://BUCKET_NAME/OBJECT_PATH <span class="c"># (Signed URL for temporary access)</span>

</pre></td></tr></tbody></table>
</div>
</div>
<ul>
  <li>额外的几个命令
    <ol>
      <li>通过 <code class="language-plaintext highlighter-rouge">gsutil -m</code>命令 拷贝文件  (-m 是多线程上传)</li>
      <li>通过 <code class="language-plaintext highlighter-rouge">gsutil hash -c FILENAME</code> 来计算所有 on-premise 文件的 CRC32C 的 哈希值</li>
      <li>通过 <code class="language-plaintext highlighter-rouge">gsutil ls -L gs://[YOUR_BUCKET_NAME]</code> 来获取所有上传到 backet 中的文件的 哈希值</li>
    </ol>
  </li>
  <li>最佳实践
    <ul>
      <li>数据存到离用户近的region</li>
      <li>数据读取率不要变化太快, 要逐步提升读写量</li>
      <li>遇到报错, 逐渐放缓读取频率</li>
      <li>bucket 和 object 名字不要用敏感信息, 不要用序数, 不要用时间戳
        <ul>
          <li>具有顺序名称的对象是连续存储的，因此它们可能会访问同一后端服务器。发生这种情况时，吞吐量会受到限制。</li>
          <li>可以用哈希值,</li>
        </ul>
      </li>
      <li>Cloud Storage FUSE 可以让bucket 像目录一样在linux 系统中被管理</li>
      <li>尽量合并和压缩小文件成为大文件, 可以节省网络带宽, 节省bucket 的存储空间.</li>
      <li>如果是用命令上传文件, 可以用 -m 多线程上传, 加快速度.</li>
    </ul>
  </li>
  <li>场景
    <ul>
      <li>数据 30 天后就不会被访问了, 但要保存 4 年满足合规.
        <ul>
          <li>方案: 用standard -&gt; archive -&gt; 4 年后删掉</li>
        </ul>
      </li>
      <li>需要把 2T 数据从 AWS 转到 google cloud
        <ul>
          <li>方案: Cloud Storage Tansfer Service</li>
        </ul>
      </li>
      <li>客户需要管理他们的 Key
        <ul>
          <li>方案: Customer-managed key</li>
        </ul>
      </li>
      <li>由于合规原因, 对象创建后两年内不能修改
        <ul>
          <li>方案: 配置 并 lock retention policy</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Signed URL
    <ul>
      <li>看 <strong>IAM, Service Account (服务账号), ACL</strong>  这章</li>
    </ul>
  </li>
  <li>静态网站
    <ul>
      <li>看 <strong>IAM, Service Account (服务账号), ACL</strong>  这章</li>
    </ul>
  </li>
</ul>

<h3 id="database">Database</h3>
<ul>
  <li>数据库的决策树
    <ul>
      <li><img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-13-085842.jpg" alt="" /></li>
    </ul>
  </li>
  <li>场景:
    <ul>
      <li>初创公司, schema 不确定,还在进化中
        <ul>
          <li>FireStore</li>
        </ul>
      </li>
      <li>No SQL 数据库, 存储量不大
        <ul>
          <li>FireStore</li>
        </ul>
      </li>
      <li>Transctional Global Database, 确定的schema, 需要处理大量数据
        <ul>
          <li>Spanner</li>
        </ul>
      </li>
      <li>Cache Data for web app
        <ul>
          <li>MemoryStore</li>
        </ul>
      </li>
      <li>Huge data from IOT
        <ul>
          <li>BigTable</li>
        </ul>
      </li>
      <li>Huge data with time series
        <ul>
          <li>BugTable</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>几个概念
    <ul>
      <li>Availability - 就是多少个 9
        <ul>
          <li>99.99% 是一个月 4 分半宕机, 99.999% 是有 26 秒宕机</li>
          <li>增加 standby 数据库, multi-zones, multi-regions</li>
        </ul>
      </li>
      <li>Durability - 持久性, 就是保证多久不丢数据文件
        <ul>
          <li>99.999999999% 表示 1000 万年保存 100万个文件, 丢了一个文件.</li>
          <li>增加 standby, snapshots, transaction logs, replicas, multi-zones, multi-regions</li>
        </ul>
      </li>
      <li>RTO - 最快宕机回复时间 (最大可接受的宕机时间)</li>
      <li>RPO - 回复后, 恢复到事故前的几个小时 (最大可接受的丢失数据时长)</li>
      <li>几种数据库恢复机制和 RTO, RPO 关系
        <ul>
          <li>Hot Standby
            <ul>
              <li>一个数据库挂了, 另一个可以马上自动切换过来</li>
              <li>RPO 1m, RTO 5m</li>
            </ul>
          </li>
          <li>Warm Standby
            <ul>
              <li>一个数据库挂了, 另一个需要有最minimum 的infra, 可以快速补充上来</li>
              <li>RPO 1m, RTO 15m</li>
            </ul>
          </li>
          <li>Snapshot and transaction logs
            <ul>
              <li>一个数据库挂了, 要用 snapshot 和 log 恢复</li>
              <li>RPO 1m, RTO few hours</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Consistency - 保持一致性, 一般说的是master 和 replica 之间数据同步的实时性
        <ul>
          <li>分为几种
            <ul>
              <li>Strong Consistency
                <ul>
                  <li>实时将数据同步到所有的 replica</li>
                  <li>如果 replica 太多, 同步的速度会降低</li>
                </ul>
              </li>
              <li>Eventual consistency
                <ul>
                  <li>异步将数据传递给 replica</li>
                  <li>所有replica 都完成同步可能要花好几秒钟, 而且有可能从每个replica 获取的结果不太一样</li>
                </ul>
              </li>
              <li>Read-after-Write consistency
                <ul>
                  <li>写入后马上就可以读到写入的数据,</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>数据库类型
    <ul>
      <li>RDB
        <ul>
          <li>提前定义了 Schema</li>
          <li>OLTP 和 OLAP 使用关系型数据库
            <ul>
              <li>OLTP DB
                <ul>
                  <li>Online Transaction Processing</li>
                  <li>use row storage</li>
                  <li>适合 很多用户运行 small transactions</li>
                  <li>场景: ERP, CRM, E-Commerce, Banking app</li>
                  <li>Google 提供的无服务OLTP RDB 数据库</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>几种数据存储的比较
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-08-023618.jpg" alt="" />
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-10-093009.jpg" alt="" />
    <h4 id="cloud-sql">Cloud SQL</h4>
  </li>
  <li>支持 Mysql, PostgreSQL, SQL Server</li>
  <li>如果上限不超过64 processor core, 30个 TB存储, 400G Ram 可以考虑</li>
  <li>Replica 可以跨Region</li>
  <li>99.95% 的 HA 保障</li>
  <li>带一个 network firewall</li>
  <li>功能
    <ul>
      <li>自动加密
        <ul>
          <li>存在数据库中的数据被自动加密</li>
        </ul>
      </li>
      <li>HA
        <ul>
          <li>通过创建 HA Configuration</li>
          <li>有 primary 和 Secondary(standby) 两个实例, 部署在两个不同的zone
            <ul>
              <li>primary 的变化会同步到 secondary</li>
              <li>primary 挂了, 流量会auto failover 到 secondaryt instance
                <ul>
                  <li>就算primary 恢复了, failover 不会自动切换回 primary</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>最好用 Cloud SQL Proxy 接收来自app 的请求</li>
          <li>Cloud SQL 只能横向扩展读, 不能横向扩展写
            <ul>
              <li>最好把写的内容分成不同的小 Cloud SQL instance, 单独部署</li>
              <li>不能有两个 Master 一起写</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Read replica
        <ul>
          <li>支持自动 replica</li>
          <li>解决read workload</li>
          <li>不解决 HA 的问题</li>
          <li>创建 Read Replica 的前置条件
            <ul>
              <li>开启 automatic backup
                <ul>
                  <li>启动了 auto backup 会自动开启 Binary Logging</li>
                </ul>
              </li>
              <li>至少有一个 backup 已经完成</li>
            </ul>
          </li>
          <li>如果replica 有 延迟 (lag), 可以对数据库进行 sharding (分成小块, 横向扩展)
            <ul>
              <li>Sharding. Sharding makes horizontal scaling possible by partitioning the database into smaller, more manageable parts (shards), then deploying the parts across a cluster of machines.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>自动增加容量 (automatic storage increase feature)</li>
      <li>支持 DMS 数据库迁移</li>
      <li>导入和导出
        <ul>
          <li>可以导出单个数据库或者表</li>
          <li>导出会比较耗时, 导出太大的数据库会影响数据库性能
            <ul>
              <li>可以用 Serverless export 工具导出, 效果会好一点</li>
              <li>把导入导出的内容分成小块来批处理, 效果会好很多</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>自动备份
        <ul>
          <li>实例被删了, 备份也会被删掉</li>
          <li>备份只能把实例整体进行备份, 不能只备份某个数据库或者表</li>
          <li>实例成本包含了 7 个 backup</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>最佳实践</li>
  <li>Cloud SQL 的 灾难恢复 Dister Recovery 方案
    <ol>
      <li>运行 Cloud SQL 的 HA Mode (一个 Primary instance, 一个 standby instance, 前面一个 对外的 IP)</li>
      <li>定期bakup 数据, 可以在发生灾难之后, 快速创建一个新的数据库实例</li>
      <li>创建 cross region read replica. 在发生地区灾难之后, 从另一个地区快速恢复. 
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-12-032729.jpg" alt="" />
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-12-032749.jpg" alt="" /></li>
    </ol>
  </li>
  <li>使用场景
    <ul>
      <li>迁移本地的mysql, postgresql, sql server 上云</li>
      <li>为简单关系数据库降低运维成本</li>
    </ul>
  </li>
</ul>

<h4 id="cloud-spanner">Cloud Spanner</h4>
<ul>
  <li>可无限 scale
    <ul>
      <li>要开启 autoscalling</li>
    </ul>
  </li>
  <li>上限 几个 PB</li>
  <li>99.999% 的 HA 保证 (5 个 9)</li>
  <li>multi-regional 支持更好
    <ul>
      <li>可以有多个master</li>
    </ul>
  </li>
  <li>很贵</li>
  <li>Google Cloud Spanner 的底层是一种分布式的关系型数据库引擎，它是基于 Google 自己的设计和开发的。</li>
  <li>选择 Cloud Spanner 的理由
    <ul>
      <li>需要global scale</li>
      <li>需要 5 个 9 的HA</li>
      <li>需要无限扩展的容量</li>
      <li>可横向扩展写</li>
      <li>任务急, 不差钱</li>
    </ul>
  </li>
  <li>场景
    <ul>
      <li>内置高可用</li>
      <li>关系性数据库, 需要第二个 index</li>
      <li>强大的 global consistency</li>
      <li>每秒大量的 Input/output</li>
    </ul>
  </li>
</ul>

<h4 id="cloud-firestore">Cloud FireStore</h4>
<ul>
  <li>NO-Sql DB (Document DB)</li>
  <li>Flexible schema, 每个表是一个collection, 每条数据是一个document, 每个document 可能有不同的字段
    <ul>
      <li>Collection 和 Document 可以互相嵌套 (Document 里面可以有 collection, collection 中可以再有 document)</li>
    </ul>
  </li>
  <li>适合小公司刚启动业务, 有些schema 不清楚的场景</li>
  <li>比 RDB 来说, 更加scalability 和 high-performance</li>
  <li>自动的 multi-region data replication</li>
  <li>付费
    <ul>
      <li>每个月 1G 的免费额度</li>
      <li>read, write, delete 都要付费</li>
      <li>存的数据的大小</li>
      <li>带宽使用的大小</li>
      <li>每天的免费用量是
        <ul>
          <li>5 万个document read</li>
          <li>2万个 document write</li>
          <li>2万个 delete</li>
          <li>1G 存</li>
          <li>超过这些用量才会收费</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Google 提供的  No-SQL DB
    <ul>
      <li>老版本叫做 DataStore</li>
      <li>适合 0-few TB</li>
      <li>无服务</li>
      <li>支持离线模式</li>
      <li>支持一个表中有多个 index
        <ul>
          <li>创建 key 的时候不要用序数, 或者时间戳, 可以用 <code class="language-plaintext highlighter-rouge">allocateIds()</code> 这个函数创建 ID 作为 Key</li>
          <li>只用经常用到的query 中需要查询的字段才用来创建index</li>
          <li>如果经常有一些 ad hoc 的请求, 建议使用 Bigtable</li>
        </ul>
      </li>
      <li>不支持 join or agreegate (sum or count) 操作</li>
      <li>提供客户端的类库
        <ul>
          <li>web, ios, android and etc.</li>
        </ul>
      </li>
      <li>两种模式
        <ul>
          <li>DataStore mode
            <ul>
              <li>在 Datastore 模式 中的数据对象称为实体(entities)</li>
              <li>Each entity in a Datastore mode database has a key</li>
              <li>key 和 identifier 关联, identifier 可以是 key 的名字或者一个数字</li>
            </ul>
          </li>
          <li>Native mode</li>
        </ul>
      </li>
      <li>导出
        <ul>
          <li>通过 gcloud 命令</li>
          <li>不能通过console 导出</li>
        </ul>
      </li>
      <li>适用例子:
        <ul>
          <li>User profile</li>
          <li>让用户将自己的照片存到 Cloud Storage, 然后将照片的meta data 放到 Firestore 中</li>
          <li>product catalogs</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h4 id="cloud-bigtable">Cloud BigTable</h4>
  </li>
  <li>不是无服务, 需要自己创建 instance</li>
  <li>Bigtable 的底层数据库引擎是 Google 自行开发的分布式存储系统，名为 Colossus。</li>
  <li>适合大于 10 TB 的情景 , PB 级别支持没问题</li>
  <li>很多 Google 核心应用都是用 BigTable
    <ul>
      <li>Google搜索</li>
      <li>Analytics（分析）</li>
      <li>Google 地图</li>
      <li>Gmail</li>
    </ul>
  </li>
  <li>可以和其他 GCP/开源大数据 的 batch/stream 服务集成,  包括
    <ul>
      <li>Dataflow</li>
      <li>Spark streaming</li>
      <li>Stom</li>
      <li>Hadoop Map/Reduce</li>
    </ul>
  </li>
  <li>通过 多个cluster 和 nodes 来提供 HA 和 横向扩展
    <ul>
      <li>cluster 可以 跨 region 和 zone</li>
      <li>自动的 sharding data 到多个cluster 的 nodes 中的多个表中</li>
      <li>创建两个 cluster 可以实现replication
        <ul>
          <li>可以提高 HA,  durability, 自动 failover, 把数据放到离客户更近的地方</li>
          <li>要配置一个 application profile 来设置replication</li>
          <li>每个 change 都会自动的被 replica 到不同的 cluster 的nodes 中</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>支持 SSD 和 HDD
    <ul>
      <li>一般用 SSD 比较好</li>
      <li>不怕延迟的数据, 对读的速度不敏感的场景, 可以用 HDD</li>
    </ul>
  </li>
  <li>适配 HBase API
    <ul>
      <li>和 HBase 用同样的 API</li>
      <li>允许 on-premise HBase 和 BigTable 整合</li>
    </ul>
  </li>
  <li>通过 HBase 命令, 或者 java 命令来导出数据
    <ul>
      <li>gcloud 和 console 都不能导出数据</li>
    </ul>
  </li>
  <li>一个表只能有一个 index
    <ul>
      <li>每行(row)数据通过一个 row key 进行index</li>
      <li>创建 row key 的时候不要用序数, 或者时间戳,</li>
    </ul>
  </li>
  <li>不支持多行的 transactions , 只支持单行</li>
  <li>使用前
    <ul>
      <li>要做压力测试</li>
      <li>用 <code class="language-plaintext highlighter-rouge">Key Visualizer tool</code> 分析数据库使用情况</li>
    </ul>
  </li>
  <li>适用例子:
    <ul>
      <li>IOT Stream 数据</li>
      <li>Time Series 数据</li>
      <li>Graph Data (图形数据)</li>
      <li>real time 分析数据</li>
      <li>股票数据/财务数据</li>
    </ul>
  </li>
</ul>

<h4 id="memorystore">MemoryStore</h4>
<ul>
  <li>In Memory DB</li>
  <li>内存数据库, 更快的读取速度</li>
  <li>减少读取关系数据库或者后端服务的实践</li>
  <li>适合更新不频繁的数据, 用户可以接受数据并不是实时更新的</li>
  <li>最大 300G</li>
  <li>HA, failover, patching and monitoring</li>
  <li>Google 提供的 in memory DB</li>
  <li>无服务</li>
  <li>底层是 Redis 和 MemCache
    <h5 id="memcached">Memcached</h5>
  </li>
  <li>场景: 数据库读数据后被缓存, 用户登录session, web应用的静态配置 比较合适
    <ul>
      <li>Cache 在 web 和 DB 之间</li>
      <li>减少数据库压力</li>
    </ul>
  </li>
  <li>一旦缓存数据丢失, 如果有访问, 就会从后端重新重新读取后再缓存</li>
  <li>两种服务级别
    <ul>
      <li>Shared Memcached (免费)</li>
      <li>Dedicated memcache (\(\))
        <ul>
          <li>为应用提供固定的cache 缓存空间大小</li>
          <li>每 G 每小时 $0.06
            <h5 id="redis">Redis</h5>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>场景: 游戏排名等</li>
  <li>支持数据持久化(persistence)和高可用(HA)</li>
  <li>可以被以下服务读取缓存
    <ul>
      <li>Compute Engine</li>
      <li>App Engine</li>
      <li>GKE</li>
      <li>Cloud Function</li>
    </ul>
  </li>
  <li>创建并连接 Cloud SQL (mysql)
    <ul>
      <li>要先启动 Cloud SQL Admin API
```bash</li>
    </ul>
  </li>
</ul>

<p>gcloud config set project my-nlp-project-68654
gcloud sql connect dalong-cloud-sql-mysql-db –user=root –quiet # 下面是连接上了mysql 的命令, todos 是在console 中创建的一个 databse
use todos
create table user (id integer, username varchar(30) );
describe user;
insert into user values (1, ‘Ranga’);
select * from user;</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117</pre></td><td class="code"><pre>
### Data Analytics

#### BigQuery
- 可以保存数据, PB 的 scale 能力的分布式数据仓库
- 可以处理 near real time 数据的分析, 内嵌 ML 功能
- OLAP 关系型DB
  - 可以用 SQL 查询
- Online Analytics Processing
- use columnar storage
- 适合 对大数据(PB 级)进行分析
- 场景: 数据仓库, BI, 分析报告应用, 分析几年之前的数据 
- Google 提供的无服务 OLAP RDB 数据库
- dataset
  - Bigquery 中的 dataset 是用来存储表和视图的容器，它们主要用于组织和管理大量的表和视图
- 数据安全
  - BigQuery 默认会加密数据 at rest. 但如果客户需要自己加密数据, 也可以用customer-managed encryption keys(CMEK), key 保存在 KMS 中
- role 
  - BigQuery jobUser/user role on billing project (job User role 是用来在 BigQuery 中执行 query 的)
  - BigQuery dataViewer role on projects that contain the data (dataView role 是用来查看(不能update) 底层数据的 )

#### BigQuery 
- PB 的 scale 能力的分布式数据仓库
- 是 OLAP
- BigQuery 的层级 Data Set &gt; Table &gt; Partitions
- 适合复杂的 Query 数据查询.
  - 如果是简单的数据查询 (查两个字段这种), 建议用 BigTable (NoSql)
- BigQuery 的存储有两种
  - 标准
  - Long-term storage
    - 相当于 Cloud Storage 的 Nearline, 就是访问量很少(90 天无人问津)
    - 成本低
- 是关系型数据库, 用 SQL 查询
  - 查询方式
    - Cloud Console
    - bq 命令行工具
    - BigQuery Rest API
    - HYBase API (基于 Java, .Net, Python)
- 费用
  - 两部分
    - BigQuery 根据 scan (扫描) 了多少数据来付费的, 可能会很贵
    - BigQuery 还通过存储在 BigQuery 上的数据量付费
  - 查前先算要花多少钱
    - 1. 先用 Console 或者 `bq --dry-run` 命令 查一下要查询的数据的数据量
    - 2. 用 Pricing Calculatyor 来算一下这些数据量要花多少钱
  - 省钱的方法
    - Partitioning 分割
      - 把一个表分成几个表 (比如按日期/时间戳分割)
      - 每个partition的 schema 不变
      - partition 可以设置过期(删除)
      - 注意, 不要分的太小 (小于1G)
    - Clustering 分类(排序)
      - 把一些字段提前排好序, 就不用额外的 scan 所有的行了. 
    - 定期删除(过期)数据
      - 可以分别在 Data Set , Table, Partitions 级别设置过期
        - Data Set 设置 default table expiration (default_table_expiration_days) 
        - Table 设置  expiration time (expiration_timestamp) , 比如 100 天过期
        - partitioned tables 设置 partition expiration (partition_expiration_days)  
- 上游 - 导入数据
  - 导入方式
    - Batch 批量导入 - 免费
      - 支持 Cloud Storage 和 本地文件
      - 可以用 BigQuery Transfer Service
      - 需要先用 Cloud Dataflow 和 Cloud Dataproc 处理数据
    - Streaming 实时流导入 - 贵
      - 支持 Cloud pub/sub, Streaming Insert
      - 需要先用 Cloud Dataflow 和 Cloud Dataproc 处理数据
      - 要去重(de-deulicate), 需要增加一个 `insertId` 到每一条stream insert中
      - Streaming 有 Quota (吞吐量)限制 insert 的数量
        - 每秒每 project 100M(带 insertId) - 每秒每project 1G(不带 insertId) 
        - 换算成每秒的insert 条数 (带 insertId) , 100k - 500k (欧洲地区) 条.
        - 如果要每秒上百万条的需求, 就别用BigQuery 了, 用 BigTalbe (NoSql DB)
    - Federation 直接用Query 读 GCP 其他服务的数据
      - 支持 CloudStorage, Cloud SQL, BigTable, Google Drive
    - DataTransferService 从第三方转换数据到 BigQuery
      - 支持 Google Ads, Cloud Storage, Amazon S3, Amazon RedShift
  - 支持的格式: CSV, JSON, Avro, Parquet, ORC, Datastore backup
- 下游 - 导出
  - 支持的格式: CSV, JSON (Gzip 压缩), Avro
- 自动的数据失效(过期)
- 实时读取外部数据
  - Cloud Storage, Cloud Sql , Bigtable, Google Drive
- BigQuery 最佳实践
  - 查之前先 评估 Query (评估数据量, 评估价格)
  - 尽量用 Partitioning 和 Clustering
  - 尽量避免 Streaming insert, 用批量导入代替
    - 如果使用, 尽量使用 insertId 来去重
  - 尽量设置 数据的过期时间, 没用的数据尽早删了
  - 适合复杂的 Query 数据查询.
    - 如果是简单的数据查询 (查两个字段这种), 建议用 BigTable (NoSql)
  - 可以通过 audit log 来优化 BigQuery 的查询
    - 把 audit log stream 到 BigQuery


- Partitioning and Clustering BigQuery Tables - 语法
```sql
CREATE TABLE `my_data_set.questions_partitioned_and_clustered`
...
...
PARTITIONED BY
    DATE(created_date)
    CLUSTER BY category
...
OPTIONS (
  expiration_timestamp=TIMESTAMP "2025-01-01 00:00:00 UTC",
  partition_expiration_days=7
)

CREATE SCHEMA mydataset
OPTIONS(
  default_table_expiration_days=3.75
  )
ALTER TABLE mydataset.mytable
SET OPTIONS (
  expiration_timestamp=TIMESTAMP "2025-01-01 00:00:00 UTC",
  partition_expiration_days=7
)
</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="dataproc">Dataproc</h4>
<ul>
  <li>GCP 提供的 的 Spark 和 Hadoop, Flink, Presto 和 30+ 服务</li>
  <li>是数据湖 Data Lake 的现代化方案,</li>
  <li>当需要进行批量数据处理, 比如处理ML 和 AI 的数据.
    <ul>
      <li>支持复杂的批处理</li>
    </ul>
  </li>
  <li>Cloud Dataproc 是个数据处理平台</li>
  <li>只能导出配置, 不能导出数据</li>
  <li>基于 standard VMs 或者 Preemptible(临时) VMs
    <ul>
      <li>standard worker instance 有点浪费了, preemptible 最省钱且完美适配 hadoop 迁移到 dataproc</li>
    </ul>
  </li>
  <li>支持 Spark, Pyspark, SparkR, Hive, SparkSQL, Pig, Hadoop</li>
  <li>提供多个 Cluster 模式
    <ul>
      <li>Single Node</li>
      <li>Standard</li>
      <li>High Availability (3个 masters)</li>
    </ul>
  </li>
  <li>场景
    <ul>
      <li>需要迁移hadoop 和 spark clusters 到云上</li>
    </ul>
  </li>
  <li>代替方案
    <ul>
      <li>BigQuery</li>
    </ul>
  </li>
</ul>

<h4 id="pubsub-消息队列-异步数据通信">Pub/Sub 消息队列 异步数据通信</h4>
<ul>
  <li>Google 提供的异步数据通信服务是 Pub/Sub</li>
  <li>pubsub 是无服务</li>
  <li>Pub/Sub 包含了AWS SQS 和 SNS 两种服务的所有功能</li>
  <li>publisher 和 subscriber 是 多对多关系</li>
  <li>工作原理
    <ul>
      <li>Publisher
        <ul>
          <li>发送https 消息到 pubsub.googleapis.com 的 topic</li>
          <li>每个消息会到每个 subscription 那里</li>
        </ul>
      </li>
      <li>Subscriber
        <ul>
          <li>提供两种订阅方式
            <ul>
              <li>pull
                <ul>
                  <li>订阅者主动来取(pull)数据</li>
                  <li>Subscriber makes HTTPS requests to pubsub.googleapis.com</li>
                  <li>对应 AWS SNS</li>
                </ul>
              </li>
              <li>push
                <ul>
                  <li>订阅者提供一个web hook endpoint 地址, 消息到了pub/sub之后, 会把数据推到web hook endpoint</li>
                  <li>对应 AWS SQS</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Subscriber 发送 acknowledgement 给 pub/sub
            <ul>
              <li>message(s) 从 subscriptions 的 message queue 中被删掉</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>创建过程
    <ul>
      <li>
        <ol>
          <li>创建Topic</li>
        </ol>
      </li>
      <li>
        <ol>
          <li>创建subscription(s)
            <ul>
              <li>每个订阅默认都能从publisher 哪里收到所有的, 同样的信息</li>
              <li>订阅者可以通过filter 接收自己感兴趣的消息, 其他消息被过滤掉</li>
              <li>发布者和订阅者可以设置按照 order 进行发送和接收信息</li>
              <li>订阅者可以设置每个消息只接受一次 (去重)</li>
              <li>订阅者可以发送 acknowledge 给 pub/sub , 告诉它自己已经收到了消息, 可以在 message queue 中 把这个消息删掉了
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-01-15-052236.jpg" alt="" /></li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
  <li>pub/sub 的publis batching 批处理选项
    <ol>
      <li>pub/sub 默认是开启 message batching 功能的, subscriber 会一次性接收所有的未读数据.</li>
      <li>应用一次读取过多的数据, 花费大量时间处理, 可能就会没时间处理下一批数据, 产生timeout.</li>
      <li>最佳实践是关闭 message batching 功能, 然后通过 autoscaling 增加 subscriber 的数量来并行处理消息</li>
    </ol>
  </li>
  <li>pub/sub 与 autoscaling
    <ul>
      <li>用 pub/sub的 subscription/num_undelivered_messages 这个 metric 来作为 autoscaling 的伸缩条件, 如果超过一定的数量, 就可以增加处理消息的 VM 或者  GKE cluster 的 pode 数量
        <ul>
          <li>不能用  subscription/push_request_latencies 这个 metric, 因为这个只是来定义多久pub/sub发一个message 到 distination, 不能用来作为 autoscaling 的依据.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>pub/sub FIFO
    <ul>
      <li>先进先出</li>
      <li>进入到 pub/sub 的数据是按顺序进来的, 出去也是按顺序出去的</li>
    </ul>
  </li>
  <li>去重 Deduplication / exactly-once
    <ul>
      <li>pub/sub 是会 delivery message 最少一次的, 所以无法避免 duplicate</li>
      <li>Dataflow 可以提供去重功能 - Dataflow exactly-once processing</li>
      <li>或者通过定制开发应用去重</li>
    </ul>
  </li>
  <li>pub/sub 的好处
    <ul>
      <li>解耦 Decoupling
        <ul>
          <li>一个大应用做成多个小应用, 应用之间用pub/sub 通信</li>
          <li>publisher 不需要知道谁是订阅者</li>
        </ul>
      </li>
      <li>高可用 Availability
        <ul>
          <li>订阅者挂了, publisher 也不用担心, 可以继续发信息</li>
        </ul>
      </li>
      <li>可伸缩 Scalability
        <ul>
          <li>订阅者可以快速扩展以消费大量的消息</li>
        </ul>
      </li>
      <li>持久性 Durability
        <ul>
          <li>信息会存在 pubsub 中, 就算订阅者挂了也没关系</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>适合场景
    <ul>
      <li>事件型应用
        <ul>
          <li>比如有文件上传到了 bucket, 就发送信息到pubsub, 再转到 Bigquery 进行分析</li>
        </ul>
      </li>
      <li>streaming 流分析类型
        <ul>
          <li>比如 IOT 的sensor 数据一直发送到pubsub, 再转到 Bigquery 进行分析</li>
        </ul>
      </li>
      <li>将应用从 synchronous 改成 asynchronous workflow
        <ul>
          <li>代替方案
            <ul>
              <li>RabitMQ, Apache Kafka</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>创建 pubsub 的命令</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre>gcloud config <span class="nb">set </span>project glowing-furnace-304608   <span class="c"># 转到项目</span>
gcloud pubsub topics create topic-from-gcloud      <span class="c"># 创建 Topic</span>
gcloud pubsub subscriptions create subscription-gcloud-1 --topic<span class="o">=</span>topic-from-gcloud  <span class="c"># 创建订阅1</span>
gcloud pubsub subscriptions create subscription-gcloud-2 --topic<span class="o">=</span>topic-from-gcloud  <span class="c"># 创建订阅2</span>
gcloud pubsub subscriptions pull subscription-gcloud-2  <span class="c"># 从订阅 2 订阅消息(pull 方式)</span>
gcloud pubsub subscriptions pull subscription-gcloud-1  <span class="c"># 从订阅 1 订阅消息(pull 方式)</span>
gcloud pubsub topics publish topic-from-gcloud --message<span class="o">=</span><span class="s2">"My First Message"</span>  <span class="c"># 向 topic 发布一个新的消息  </span>
gcloud pubsub topics publish topic-from-gcloud --message<span class="o">=</span><span class="s2">"My Second Message"</span> <span class="c"># 向 topic 发布一个新的消息  </span>
gcloud pubsub topics publish topic-from-gcloud --message<span class="o">=</span><span class="s2">"My Third Message"</span>  <span class="c"># 向 topic 发布一个新的消息  </span>
gcloud pubsub subscriptions pull subscription-gcloud-1 --auto-ack  <span class="c"># 从订阅 1 订阅消息(pull 方式) , 获取消息后自动给 acknolodge 反馈</span>
gcloud pubsub subscriptions pull subscription-gcloud-2 --auto-ack  <span class="c"># 从订阅 2 订阅消息(pull 方式) , 获取消息后自动给 acknolodge 反馈</span>
gcloud pubsub topics list  <span class="c"># 查看 topic list</span>
gcloud pubsub topics delete topic-from-gcloud  <span class="c"># 删除 topic</span>
gcloud pubsub topics list-subscriptions my-first-topic  <span class="c"># </span>
</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="dataflow">Dataflow</h4>
<ul>
  <li>是谷歌提供的 数据流服务</li>
  <li>可以创建 batch/streaming 的 data pipeline (ETL - Extract Transfer and Load)
    <ul>
      <li>Batch: Cloud Storage -&gt; Dataflow -&gt; BigQuery</li>
      <li>Streaming: Pub/sub -&gt; Dataflow -&gt; BigQuery</li>
    </ul>
  </li>
  <li>是无服务</li>
  <li>基于 Apache Beam</li>
  <li>使用了 pre-build 的模板</li>
  <li>可能会用到 pub/sub</li>
  <li>模板的几个例子
    <ul>
      <li>Pub/Sub &gt; Dataflow &gt; BigQuery (Streaming)</li>
      <li>Pub/Sub &gt; Dataflow &gt; Cloud Storage (Streaming - files)</li>
      <li>Cloud Storage &gt; Dataflow &gt; Bigtable/CloudSpanner/Datastore/BigQuery (Batch - Load data into databases)</li>
      <li>Bulk compress files in Cloud Storage (Batch)</li>
      <li>Convert file formats between Avro, Parquet &amp; csv (Batch)</li>
      <li>IOT Core -&gt; Pub/Sub &gt; Dataflow &gt; BigQuery -&gt; (Vertex AI, AutoML, BigQuery ML)</li>
    </ul>
  </li>
  <li>场景
    <ul>
      <li>实时诈骗检测 (fraud detection)</li>
      <li>sensor 数据处理</li>
      <li>日志数据处理</li>
      <li>批量数据处理 (数据读取, 数据格式转换)</li>
    </ul>
  </li>
</ul>

<h4 id="数据的生命周期">数据的生命周期</h4>
<ul>
  <li>数据生命周期分四个阶段
    <ul>
      <li>Ingest 注入</li>
      <li>Store 存储</li>
      <li>Process &amp; Analysis 处理和分析</li>
      <li>Explore &amp; Visualize 发现和展现</li>
    </ul>
  </li>
  <li>每个阶段都会用到不同的服务</li>
  <li>Ingest 注入
    <ul>
      <li>流
        <ul>
          <li>Pub/sub</li>
        </ul>
      </li>
      <li>批量
        <ul>
          <li>Storage Transfer Service</li>
          <li>BigQuery Transfer Service</li>
          <li>Transfer Appliance</li>
          <li>gsutil</li>
        </ul>
      </li>
      <li>数据库迁移
        <ul>
          <li>Database Migration Service</li>
          <li>Dataflow</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Store 存储
    <ul>
      <li>对象存储
        <ul>
          <li>Cloud Storage</li>
        </ul>
      </li>
      <li>关系数据库
        <ul>
          <li>Cloud SQL
            <ul>
              <li>mysql, postgresql, sql server</li>
              <li>regional</li>
            </ul>
          </li>
          <li>Cloud Spanner
            <ul>
              <li>HA</li>
              <li>Global scale</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>No SQL
        <ul>
          <li>Firestore</li>
          <li>Bigtable
            <ul>
              <li>petabyte scale</li>
              <li>single row transactions</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>数据仓库
        <ul>
          <li>BigQuery</li>
        </ul>
      </li>
      <li>定制数据库
        <ul>
          <li>自己把自己的数据库安装到 VM 上</li>
          <li>在 marketplace 上可以找到开源镜像</li>
          <li>mongoDB , Cassandra 等</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Process &amp; Analysis 处理和分析
    <ul>
      <li>数据清洗和转换
        <ul>
          <li>DataPrep</li>
          <li>Cloud Data Loss Prevention (DLP) API
            <ul>
              <li>数据检查服务, 对Cloud Storage, BigQuery, Cloud Logging, and Datastore 上的敏感数据(PII 等)进行扫描, 检查和分类, 把查询到的结果保存到 Data Catalog 中. 需要时可以查找 data catalog 并删除所有 PII , PCI DSS 等敏感信息.</li>
              <li>GCP 的数据 , on-prem 的数据都可以检查.</li>
            </ul>
          </li>
          <li>Dataflow
            <ul>
              <li>ETL pipeline</li>
            </ul>
          </li>
          <li>Dataproc
            <ul>
              <li>迁移 Spark 和 Hadoop 到google</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Explore &amp; Visualize 发现和展现
    <ul>
      <li>数据仓库
        <ul>
          <li>BigQuery</li>
        </ul>
      </li>
      <li>机器学习
        <ul>
          <li>ML - Pre build models</li>
          <li>ML - Custom models</li>
        </ul>
      </li>
      <li>科学计算和画图
        <ul>
          <li>Cloud Datalab
            <ul>
              <li>Jupyter Notebook 的代替</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>实时图表
        <ul>
          <li>Cloud Data Studio
            <ul>
              <li>把 Cloud SQL, BigQuery 内的数据实时展现出来</li>
            </ul>
          </li>
          <li>Cloud Data Catalog
            <ul>
              <li>是数据分类目录, 记录通过 Data Loss Prevension 扫描过的数据的扫描结果, 比如 PII 信息等.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>大数据, 流, IOT 数据处理用到的数据服务
    <ul>
      <li>IoT Core
        <ul>
          <li>获取 sensor 数据, 发到 pub/sub</li>
        </ul>
      </li>
      <li>pub/sub
        <ul>
          <li>实时数据导入</li>
          <li>流数据处理的起点</li>
        </ul>
      </li>
      <li>Cloud Storage
        <ul>
          <li>批量数据处理, 先把数据放这里</li>
          <li>成本低</li>
          <li>存放时间长</li>
        </ul>
      </li>
      <li>Dataflow
        <ul>
          <li>ETL</li>
          <li>可以是pub/sub的下游</li>
        </ul>
      </li>
      <li>BigQuery
        <ul>
          <li>数据仓库</li>
          <li>不管是批量还是实时的数据处理, 最后数据都放这里</li>
          <li>适合需要进行复杂数据分析的数据</li>
        </ul>
      </li>
      <li>Data Studio
        <ul>
          <li>数据展示</li>
        </ul>
      </li>
      <li>Dataproc
        <ul>
          <li>大数据处理, hadoop, spark功能</li>
        </ul>
      </li>
      <li>Dataprep
        <ul>
          <li>数据清洗和准备</li>
        </ul>
      </li>
      <li>Datalab
        <ul>
          <li>数据计算和绘图</li>
          <li>可以用 Tensorflow, numpy 等类库</li>
        </ul>
      </li>
      <li>Cloud Composer
        <ul>
          <li>Managed workflow orchestration service</li>
          <li>Create pipelines across clouds and on-premises data centers</li>
        </ul>
      </li>
      <li>BigTable
        <ul>
          <li>存储大规模 IoT 数据更合适</li>
          <li>适合时间序列的数据</li>
        </ul>
      </li>
      <li>DataStore
        <ul>
          <li>存储 IoT 数据更合适
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-01-18-020105.jpg" alt="" /></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="ai--ml">AI &amp; ML</h3>

<ul>
  <li>google 的机器学习服务分为几种
    <h4 id="预制-ml-api">预制 ML API</h4>
  </li>
  <li>不需要使用者有 ML 知识, 直接就能用</li>
  <li>google 训练数据, google 的模型</li>
  <li>包括了
    <ul>
      <li>Vision API</li>
      <li>Video API</li>
      <li>Chat API</li>
      <li>Natural Language API</li>
      <li>Speech-to-Text API</li>
      <li>Text-to- Speech API</li>
      <li>Translation API</li>
      <li>…
        <h4 id="automl">AutoML</h4>
      </li>
    </ul>
  </li>
  <li>低代码的 AI 方案</li>
  <li>谷歌训练的数据, 我们自己的模型</li>
  <li>我们在谷歌已经训练好的模型基础上定制我们自己的 ML 模型</li>
  <li>创建用户自定义的 AI 模型</li>
  <li>不需要懂太多 ML 知识
    <h4 id="vertex-ai">Vertex AI</h4>
  </li>
  <li>我们自己的数据, 我们自己的模型</li>
  <li>managed ML platform</li>
  <li>custom ML models</li>
  <li>可以运行Tensorflow</li>
  <li>以前可能叫 api platform</li>
</ul>

<h4 id="bigquery-ml">BigQuery ML</h4>
<ul>
  <li>把 ML 和 SQL 进行整合</li>
</ul>

<h3 id="networking">Networking</h3>

<h4 id="network-tier">Network Tier</h4>
<p>Google Cloud Platform offers two different network tiers which differ both on price and performance.</p>

<ul>
  <li>Google Premium Tier Network
    <ul>
      <li>配置良好、低延迟、高度可靠的全球网络</li>
      <li>支持 Global HTTPS LB
        <ul>
          <li>支持  across regions and overflow or fail over to other regions.</li>
        </ul>
      </li>
      <li>IPv4 or IPv6 Virtual IP</li>
      <li>更贵</li>
    </ul>
  </li>
  <li>Google Standard Tier Network
    <ul>
      <li>支持 regional 的 LB</li>
      <li>不支持跨区域的 failover</li>
      <li>便宜</li>
    </ul>
  </li>
  <li>例题:
    <ul>
      <li>Which of these networking tiers is recommended if you want to use Global HTTPS Load Balancing?
        <ul>
          <li>Premium network tier
            <ul>
              <li>premium 是高级的意思, 支持 Global HTTPS LB ,</li>
              <li>标准的(Standard network tier) 不支持 global HTTPS LB</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="vpc">VPC</h4>
<ul>
  <li>Google 提供一个内部网络来保护我们的资源, 数据, 以及和内部外部的沟通</li>
  <li>VPC 是 global resource, 是跨 region 和 zone 的
    <ul>
      <li>region
        <ul>
          <li>一个地区, 比如 us-east1</li>
        </ul>
      </li>
      <li>zone
        <ul>
          <li>一个数据中心, 比如 us-east1-a</li>
        </ul>
      </li>
      <li>Route Table
        <ul>
          <li>VPC 有一个 default routing table
            <ul>
              <li>build-in 的</li>
              <li>没有管理和视图界面</li>
              <li>用于 把 traffic 从一个 vm  forward 到另一个 vm</li>
              <li>不需要 external IP 地址</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Private Google Access
    <ul>
      <li>相当于 AWS 的 VPC Endpoint.</li>
      <li>提供一个私有连接, 让这个subnet中的服务(VM, Bigquery and etc) 通过内网 IP 地址访问 google 的服务, 比如 youtubve, Gmap,  (省钱)
        <ul>
          <li>如果用了 VPN tunnel, 也可以让 on-prem 用 private IP 互相访问</li>
        </ul>
      </li>
      <li><img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-24-091201.jpg" alt="" /></li>
    </ul>
  </li>
  <li>每个项目有一个default VPC
    <ul>
      <li>default VPC (auto mode vpc)中为所有region 都默认创建了一个 subnet.</li>
    </ul>
  </li>
  <li>VPC 有两种模式
    <ul>
      <li>Auto Mode VPC
        <ul>
          <li>为所有region 都默认创建了一个 subnet.</li>
          <li>default vpc 就是 auto mode</li>
        </ul>
      </li>
      <li>Custom Mode VPC
        <ul>
          <li>要手动创建 subnet , CIDR 以及 VPC Fire Rule</li>
          <li>生产环境建议使用 custom mode</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>subnet
    <ul>
      <li>vpc 可以包含多个 subnet</li>
      <li>subnet 是 只能属于某一个region 的, regional resource.</li>
      <li>subnet 是 跨zone 的, 比如这个subnet 在us-central1, 它就在任何一个 us-central1 的zone 可用.</li>
      <li>subnet 下面的实例可以是某一个zone 的</li>
      <li>每个subnet 有一个 CIDR range (IP 地址段)
        <ul>
          <li>32 表示 1 个 IP</li>
          <li>26 表示 64 个 IP (2的(32-26)的 6 次方)</li>
          <li>…</li>
        </ul>
      </li>
      <li>Flow logs 开启的话, 可以通过 flow log 查看subnet 的网络访问日志.</li>
      <li>subnet 分为 public subnet 和 private subnet
        <ul>
          <li>public subnet 中的资源可以被外网访问(也可以访问外网), 可以访问private subnet</li>
          <li>private subnet 中的资源不能被外网访问(但可以访问外网)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Firewall Rule
    <ul>
      <li>Firewall 是 Google 管理的 build-in 服务</li>
      <li>为进出 VPC 设置流量限制
        <ul>
          <li>每条 rule 对应一个 VPC</li>
          <li>每条 rule 可以设置成 ingress rule 或者 egress rule</li>
          <li>每条 rule 可以设置成 allow 或者 deny</li>
          <li>每条 rule 的影响范围可以是
            <ul>
              <li>all instance</li>
              <li>指定 tag 的资源</li>
              <li>指定 service account 的资源</li>
            </ul>
          </li>
          <li>每条 rule 有一个 Priority, 0 - 65535, 数字越大优先级越低</li>
          <li>可以设置 protocol(TCP/UDP/Others) 和 port</li>
        </ul>
      </li>
      <li>默认的 rule 是
        <ul>
          <li>允许所有 egress</li>
          <li>不允许所有的 ingress</li>
          <li>可以设置不同 priority 的  rule 进行覆盖, 数字越小优先级越高</li>
        </ul>
      </li>
      <li>默认的 VPC 有 4 条 rule
        <ul>
          <li>Allow incoming traffic from VM instances in same network (default-allow-internal)
            <ul>
              <li>允许同一个网络的  VM访问</li>
            </ul>
          </li>
          <li>Allow Incoming TCP traffic on port 22 (SSH) default-allow-ssh
            <ul>
              <li>允许 ssh 访问</li>
            </ul>
          </li>
          <li>Allow Incoming TCP traffic on port 3389 (RDP) default-allow-rdp
            <ul>
              <li>允许远程桌面访问</li>
            </ul>
          </li>
          <li>Allow Incoming ICMP from any source on the network default-allow-icmp
            <ul>
              <li>允许 Ping 通不通</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Firewall Rule 最佳实践
        <ul>
          <li>尽量使用 tag (给资源打标签) 来被 firewall rule 进行允许外部流量访问</li>
          <li>尽量只允许 LB 访问 instance, 不要外网直接访问</li>
          <li>删掉 0.0.0.0/0 这种地址段, 太宽了</li>
          <li>地址段只允许特定的小范围地址段</li>
          <li>允许 LB 的健康检查访问实例/MIG</li>
          <li>如果不想让所有实例都默认可以 egress 访问外网
            <ul>
              <li>先建立一个low priority (比如 65000)的 egress rule 把所有访问都 deny</li>
              <li>再建立一个high priority (比如 1000)的 egress rule 指定哪些资源可以通过什么端口来访问 外网</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Firewall Insights (防火墙洞察)
        <ul>
          <li>需要先开启 Firewall Rule Logging</li>
          <li>可以通过 logging 查看这些 firewall rule 的使用效率. 方便理解, 提升安全, 优化配置</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Shared VPC
    <ul>
      <li>同一个组织(organization) 有多个 project 希望可以通过内网 IP 互相通信</li>
      <li>需要先创建组织</li>
      <li>可以在一个Org 中的一个 Host Project 中创建一个 shared VPC, 把需要共享的应用跑在里面, 然后让org 下面的其他project 中的服务通过内网 IP访问. 
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-07-160108.jpg" alt="" /></li>
    </ul>
  </li>
  <li>VPC Service Control
    <ul>
      <li>Google managed 网络功能, 降低数据外泄(exfiltration)风险, 保护VPC 内数据隐私, 提供独立的访问控制</li>
      <li>提供如下功能:
        <ul>
          <li>控制 VPC 网络可以访问哪些谷歌服务</li>
          <li>multi-tenant, 保证不会泄露 (exfiltration)</li>
          <li>敏感信息只能被经过认证的网络访问</li>
          <li>限制资源访问 IP 地址, identity, 客户设备</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="serverless-vpc-access">Serverless VPC Access</h4>
<ul>
  <li>Serverless VPC Access 是一个私有访问选项, 允许你通过一个 internal IP 让一个 无服务(serverless) 连接到 VPC 网络.
    <ul>
      <li>VPN tunnel 连接到的on-premise 也算  VPC网络内</li>
      <li>要无服务发起连接请求</li>
      <li>如果是 VM 先发起的请求, 就要走外网的无服务入口了</li>
    </ul>
  </li>
  <li>无服务包括
    <ul>
      <li>Cloud Run</li>
      <li>App Engine standard environment</li>
      <li>Cloud Function</li>
    </ul>
  </li>
</ul>

<h4 id="vpc-peering-vpc-network-peering">VPC Peering (VPC Network Peering)</h4>
<ul>
  <li>VPC Peering 可以让不同组织之间的 VPC 互相连接 并使用 内网 IP 相互通信
    <ul>
      <li>前提是两个 VPC  的网络 IP 不能重叠</li>
    </ul>
  </li>
  <li>数据交换不需要额外付费</li>
  <li>VPC1 和 VPC2 peer 了, PC2 和 VPC3 Peer 了, 并不能解决 VPC1 和 VPC3 的 Peering</li>
  <li>VPC 只能在 GCP 内部使用, 为两个 VPC 提供链接, 不能在  GCP 外部建立连接</li>
  <li>VPC peering 有时候也叫 network peering.</li>
</ul>

<h4 id="carrier-peering">Carrier Peering</h4>
<ul>
  <li>运营商对等</li>
  <li>Peer through a carrier</li>
  <li>是一种通过第三方运营商来实现的互联，这意味着一个网络可以通过运营商来连接到另一个网络。</li>
</ul>

<h4 id="cloud-router">Cloud Router</h4>
<p>VPC/on-prem network route exchange (BGP)</p>
<ul>
  <li>Google 管理的 build-in 服务</li>
  <li>Router 同一个 VPC 下面的不同subnet 之间的通信</li>
  <li>不同的 VPC 之间需要通过 VPN Gateway 或者 Cloud Interconnect 才能让不同subnet 之间通信</li>
  <li>Firewall 和 Router 的区别
    <ul>
      <li>Google Cloud Firewall rules are used to create and manage network access control lists (ACLs) that control the traffic that is allowed to and from a Google Cloud virtual private cloud (VPC) network. Cloud Router is a specialized virtual router that enables customers to route traffic between their on-premises networks and their Google Cloud VPC networks. Cloud Router also provides dynamic routing for customers who need to connect multiple VPC networks together or to other networks.
        <ul>
          <li>Google Cloud Firewall 规则用于创建和管理网络访问控制列表 （ACL），这些列表控制允许进出 Google Cloud 虚拟私有云 （VPC） 网络的流量。云路由器是一种专用的虚拟路由器，使客户能够在其本地网络和 Google Cloud VPC 网络之间路由流量。云路由器还为需要将多个VPC网络连接在一起或连接到其他网络的客户提供动态路由。
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-15-091711.jpg" alt="" /></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="direct-peering">Direct Peering</h4>
<ul>
  <li>直连 (on-prem 到 GCP VPC)</li>
  <li>Direct Peering可以让你在企业网络和 Google 边缘网络之间建立直接对等互连连接，并交换高吞吐的云端流量</li>
  <li>通过 network peering 直连 客户网络和 GCP 网络</li>
  <li>low level 的连接, <strong>不推荐</strong></li>
  <li>推荐使用 Cloud VPN 或者 Cloud Interconnect</li>
</ul>

<h4 id="cloud-nat-cloud-nat-gateway">Cloud NAT (Cloud NAT Gateway)</h4>
<ul>
  <li>无服务</li>
  <li>相当于 AWS 中的 NAT Gateway / Ineternet Gateway</li>
  <li>和 堡垒机相反, 提供 VPC 内部的互联网请求</li>
  <li>Cloud NAT 是一个网络组件, 并不存在于某个  VM 或者 应用上</li>
  <li>让 VPC 中的资源在没有 public IP 的情况下也可以访问互联网</li>
  <li>可以支持的 GCP 资源
    <ul>
      <li>VM</li>
      <li>GKE</li>
      <li>Cloud Run</li>
      <li>App Engine</li>
      <li>Cloud Function</li>
    </ul>
  </li>
  <li>不需要配置 firewall rules</li>
  <li>需要所在的  VPC有一个默认的 router , 这个 router 的下一跳(hop) 是 internet gateway
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-10-043548.jpg" alt="" /></li>
  <li>案例
    <ul>
      <li>要部署应用到  GKE上, 需要访问外网,  但GKE所在的 GCE VM 没有外网 IP, 如何解决?
        <ol>
          <li>把 GKE Cluster 作为一个 private subnet</li>
          <li>给这个 subnet 配置 CLoud NAT Gateway</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h4 id="vpn">VPN</h4>
<ul>
  <li>连接 on premise 和 GCP 网络</li>
  <li>每个 VPN 最高速度为 3Gbps, 多建几个可以增加带宽</li>
  <li>使用了 IPSec VPN Tunnel 实现</li>
  <li>通过 internet 公网连接</li>
  <li>用 Internet Key Exchange 协议加密</li>
  <li>VPN Gateway
    <ul>
      <li>要建立 VPN tunnel, 就要在所在的 region 建立一个 VPN Gateway</li>
      <li>Regional 的, 不是 global 的. 每个region 可以有一个 VPN gateway</li>
    </ul>
  </li>
  <li>两种 VPN 类型
    <ul>
      <li>HA VPN
        <ul>
          <li>SLA 99.99%</li>
          <li>对外暴露 2个 外部 IP 地址</li>
          <li>2条线路, 是 HA (在一个 region)</li>
          <li>只支持动态路由 (BGP)
            <ul>
              <li>Cloud Router
                <ul>
                  <li>支持动态路由, 当网络拓扑变化时, 可以自动更新路由</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>gateway
            <ul>
              <li>GCP 端是 Cloud HA VPN gateway</li>
              <li>on premise 端是 on-premise vpn gateway
                <ul>
                  <li>or peer gateway</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Clasic VPN
        <ul>
          <li>SLA 99.9%</li>
          <li>对外暴露 1个 外部 IP 地址</li>
          <li>1条线路, 非 HA</li>
          <li>支持动态和静态路由 (BGP)</li>
          <li>gateway
            <ul>
              <li>GCP 端是 Cloud Compute Engine VPN gateway</li>
              <li>on premise 端是 on-premise vpn gateway</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>适合场景
    <ul>
      <li>希望on premise 和 GCP 的通信进行加密</li>
      <li>对吞吐量要求不高, 没有太多 cost</li>
    </ul>
  </li>
  <li>VPN 和 Cloud Interconnect 适用的场景区别
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-15-092310.jpg" alt="" />
    <h4 id="cloud-interconnect">Cloud Interconnect</h4>
  </li>
  <li>专线网络, 连接 GCP 和 on premise</li>
  <li>高速连接, 高可用, 低延迟的私有连接</li>
  <li>通过私有网络连接
    <ul>
      <li>使用私有 IP 地址 (无外网 IP 接口)</li>
      <li>省去了 egress 外网流量的成本</li>
    </ul>
  </li>
  <li>有两种类型
    <ul>
      <li>Dedicated Interconnect
        <ul>
          <li>on-prem data center 需要和 GCP data center 比较近</li>
          <li>99.99% SLA</li>
          <li>独享专线, GCP 和 on-premise 直连</li>
          <li>80 Gbps 的网速 (or 200 Gbps circuits)</li>
          <li>缺点, 要花时间去建立, 一般几周到几个月</li>
        </ul>
      </li>
      <li>Partner Interconnect
        <ul>
          <li>on-prem data center 和 GCP data center 比较远, 才需要一个partner 在中间</li>
          <li>GCP 和 on-premise 中间还有一个partner 网络
            <ul>
              <li>partner 可以是中国电信, 联通, 移动</li>
            </ul>
          </li>
          <li>和 Dedicated 相比, 稍微低一点的带宽</li>
          <li>50 Mbps 到 10Gbps</li>
          <li>partner 这部分出了问题, Google 不负责.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>最佳实践
    <ul>
      <li>GCP 中和 on premise 连接的网络, 使用一个不同 IP 地址段
        <ul>
          <li>地址段不能相互重叠</li>
        </ul>
      </li>
      <li>网络连接要有备份方案
        <ul>
          <li>把 Cloud Interconnect 作为主要连接</li>
          <li>把 VPN 作为备份方案, 就算主要连接挂了, 也可以保持连接</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="cloud-dns">Cloud DNS</h4>
<ul>
  <li>谷歌云提供的 DNS 服务 (不含域名注册)</li>
  <li>Zone 是对某个域名的管理集合
    <ul>
      <li>分为 public zone (处理外网公有域名) 和 private zone (处理内网私有域名)</li>
    </ul>
  </li>
  <li>Record 是</li>
  <li>步骤:
    <ul>
      <li>在域名注册商那里购买域名</li>
      <li>将域名路由到 Cloud DNS
        <ul>
          <li>
            <ol>
              <li>在 Cloud DNS 中创建一个 Zone, 并指定要处理的域名</li>
            </ol>
          </li>
          <li>
            <ol>
              <li>在zone 中创建记录, 处理域名的不同解析方式
                <ul>
                  <li>比如:
                    <ul>
                      <li>Route api.dalong.work to the IP address of api server</li>
                      <li>Route static.dalong.work to the IP address of http server</li>
                      <li>Route email (dalong@dalong.work) to the mail server(mail.dalong.work)</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ol>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Cloud DNS 路由 policies
    <ul>
      <li>Cloud DNS 有两种路由规则
        <ul>
          <li>weighted round robin (权重)
            <ul>
              <li>如果 DNS 下面有两个 IP, 那么对两个  IP设置不同的权重, 20% 到一个 IP, 80% 到另一个 IP</li>
            </ul>
          </li>
          <li>geo-location
            <ul>
              <li>通过用户 IP 地址判断客户所在地, 然后再把客户流量转给对应的后端的LB 或者对应region 的服务) 
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-10-031419.jpg" alt="" /></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="cloud-cdn">Cloud CDN</h4>
<ul>
  <li>使用谷歌的 global edge network 让用户可以在全球范围内在就近, 快速获取到被缓存的静态资源</li>
  <li>和 External Https/Http LB 整合</li>
  <li>后端可以是
    <ul>
      <li>Cloud Storage buckets</li>
      <li>Instance groups</li>
      <li>App Engine</li>
      <li>Cloud Run</li>
      <li>Cloud Functions</li>
      <li>客户自己的数据源</li>
    </ul>
  </li>
  <li>原理
    <ul>
      <li>和memcache 差不多</li>
      <li>URL 如果map 到了Cloud CDN 中的cache 就直接返回给客户; 如果没map 到, 就去 origian 拿到静态数据, 然后返回给客户, 然后把缓存存到 CDN 中</li>
      <li>可以通过 TTL 设置缓存过期时间</li>
    </ul>
  </li>
  <li>cache key
    <ul>
      <li>默认是完整的 url 作为 cache key</li>
      <li>定制 cache key, 去掉 protocol 信息 可以提高cache 命中率
        <ul>
          <li>http 和 https 开头的, 后面 URL 完全相同的 cache key 合并, 可以提高命中率</li>
        </ul>
      </li>
      <li>缩短 cache 过期时间只会降低命中率</li>
    </ul>
  </li>
  <li>最佳实践
    <ul>
      <li>根据过期时间需要缓存静态内容
        <ul>
          <li>Example: Cache-Control: public, max-age=259200 (72 hours)</li>
          <li>Example: Cache-Control: public, max-age=300 (5 minutes)</li>
        </ul>
      </li>
      <li>提高 cache hit ratio (缓存命中率)
        <ul>
          <li>如果 URL 是 https://yourwebsite.com/my-image/1.jpg 那么下面两种  URL都不会命中缓存</li>
          <li>http://yourwebsite.com/my-image/1.jpg (http vs https)</li>
          <li>http://yourwebsite.com/my-image/1.jpg?mobile=1 (query string does not match)</li>
        </ul>
      </li>
      <li>可以通过命令来设置 cache key
        <ul>
          <li><code class="language-plaintext highlighter-rouge">gcloud compute backend-services update BACKEND_SERVICE --enable-cdn --no-cache-key-include-protocol --no-cache-key-include-host --no-cache-key-include-query-string</code></li>
        </ul>
      </li>
      <li>在 URL 中通过版本好来更新内容
        <ul>
          <li>https://yourwebsite.com/my-image/1.jpg?v=1</li>
          <li>https://yourwebsite.com/my-image/1.jpg?v=2</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="media-cdn">Media CDN</h4>
<ul>
  <li>CDN for Streaming and Videos</li>
</ul>

<h4 id="load-balancing-load-balancer">Load Balancing (Load Balancer)</h4>
<ul>
  <li>可以把流量在一个或多个region 传给应用实例, 提供高可用 HA</li>
  <li>配合 health check 和 auto scaling
    <ul>
      <li>LB 只会把流量给到 MIG 中的健康的VM</li>
      <li>如果一个 region 的 backend 都挂了, LB会把流量转到其他region</li>
    </ul>
  </li>
  <li>可以是 internal (VM 之间) 或者 external (互联网用户流量)
    <ul>
      <li>external 到 LB - 建议 HTTPS, TLS</li>
      <li>LB 到 VM - 建议 HTTPS, HTTP 也 OK</li>
      <li>internal 建议 HTTP, TCP</li>
    </ul>
  </li>
  <li>支持的 protocol
    <ul>
      <li>HTTP/HTTPS
        <ul>
          <li>第七层</li>
          <li>web, API, email(SMTP), FTP 等</li>
          <li>大多数应用都在这一层</li>
          <li>HTTP/HTTPS 是基于 第四层之上的</li>
        </ul>
      </li>
      <li>TCP(TLS)/UDP/ICMP(Ping)
        <ul>
          <li>第四层</li>
          <li>游戏, 视频等用 UDP</li>
          <li>性能更好</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>组成 LB 的 3 个部分
    <ul>
      <li>Frontend - 指定的 IP 地址, 端口和 protocol.
        <ul>
          <li>IP 地址客户可以直接访问</li>
        </ul>
      </li>
      <li>Host, path rules, http header - 就是路由规则
        <ul>
          <li>Host 就是用二级域名来判断把流量转到后台什么地方</li>
          <li>Path rules 就是利用 路径来判断把流量送哪里去</li>
          <li>Http header - 通过http header 决定怎么传递流量
            <ul>
              <li>authorization header</li>
              <li>post/get/…</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Backend - 提供服务的 endpoint
        <ul>
          <li>一般一个 Backend 指一个 MIG, 也可能是一个instance 或者 bucket</li>
          <li>因为 MIG 只能在一个 Region, 所以如果需要跨region 服务, 需要在多个region 部署几个跑同样应用的 MIG (同一个 project)</li>
          <li>LB 会把用户流量转到离用户最近(延迟最低)的那个region 的 MIG</li>
        </ul>
      </li>
      <li>Protocol 的常用端口
        <ul>
          <li>HTTP/HTTPS - 80,8080, 443</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>负载均衡类型
    <ul>
      <li>Global HTTP(S)</li>
      <li>Global SSL Proxy</li>
      <li>Global TCP</li>
      <li>Reginal</li>
      <li>Reginal Internal
        <ul>
          <li>多层应用之间,内网互访</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>几个容易混淆的概念
    <ul>
      <li>Bacakend Service
        <ul>
          <li>跨region</li>
          <li>一堆backend or bucket</li>
          <li>一个backend service 可以有多个 MIG 分布在不同的region</li>
        </ul>
      </li>
      <li>Backend : 比如一个 MIG</li>
    </ul>
  </li>
  <li>几个负载均衡的场景
    <ul>
      <li>同样的服务在不同region
        <ul>
          <li>方案: 1个 LB + 1个 backend service + 多个 backend (分布在不同region)</li>
        </ul>
      </li>
      <li>不同的服务在不同 region
        <ul>
          <li>方案: 1个 LB + 1个 URL Maps + 多个 backend service + 多个 backend (分布在不同region)</li>
        </ul>
      </li>
      <li>不同服务,不同版本在不同region
        <ul>
          <li>方案和上面一个一样, 同一个服务的不同版本视作不同的服务.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>例题:
    <ul>
      <li>Which of these networking tiers is recommended if you want to use Global HTTPS Load Balancing?
        <ul>
          <li>Premium network tier
            <ul>
              <li>premium 是高级的意思, 就是用最新的LB , 不用标准的(Standard network tier)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>How many HTTPS Load Balancing Backends would you need to support one version each of three different microservices, each with two MIGs in two different regions?
        <ul>
          <li>6个
            <ul>
              <li>一个微服务就表示一个backend service</li>
              <li>每个服务在两个region中分别部署一个 MIG(backend) , 一共是 6 个</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="service-directory">Service Directory</h4>
<ul>
  <li>谷歌提供的服务发现服务</li>
  <li>帮助微服务之间互相发现彼此</li>
  <li>一个地方 publish, discover, connect 服务</li>
  <li>可以在混合云中运行</li>
  <li>Managed Service</li>
  <li>通过 DNS, HTTP, and gRPC</li>
  <li>client libraries 支持多种开发语言, 提供 Rest/ RPC 的 API</li>
  <li>输出日志
    <ul>
      <li>Audit log</li>
      <li>request/response log</li>
    </ul>
  </li>
</ul>

<h4 id="eventarc">Eventarc</h4>
<ul>
  <li>谷歌的事件处理服务</li>
  <li>遵循了 <a href="https://cloudevents.io">CloudEvent</a> 标准
    <ul>
      <li>支持多语言, 混合云,</li>
      <li>标准类库和工具</li>
      <li>可移植性强</li>
    </ul>
  </li>
  <li>理解为事件总线, 集中</li>
  <li>上游 - 谁来触发 event
    <ul>
      <li>Pub/Sub</li>
      <li>Cloud Storage</li>
      <li>Cloud Functions</li>
      <li>Cloud IoT</li>
      <li>Cloud Memorystore</li>
      <li>Cloud Audit Logs (间接的, GCE 和  GAE可以先把log 发送到 Audit log, 然后由 audit log 触发event)</li>
      <li>..</li>
    </ul>
  </li>
  <li>下游 - 谁来处理event
    <ul>
      <li>Cloud Functions (2nd gen)</li>
      <li>Cloud Run</li>
      <li>GKE services</li>
      <li>..
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-04-060656.jpg" alt="" /></li>
    </ul>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre>gcloud eventarc triggers create my-pub-sub-trigger
  --destination-run-service<span class="o">=</span><span class="nv">$SERVICE_NAME</span> --destination-run-region<span class="o">=</span><span class="nv">$REGION</span>
  --event-filters<span class="o">=</span><span class="s2">"type=google.cloud.pubsub.topic.v1.messagePublished"</span>
gcloud eventarc triggers create my-audit-log-trigger
  --destination-run-service<span class="o">=</span><span class="nv">$SERVICE_NAME</span> --destination-run-region<span class="o">=</span><span class="nv">$REGION</span>
  --event-filters<span class="o">=</span><span class="s2">"type=google.cloud.audit.log.v1.written"</span>
  --event-filters<span class="o">=</span><span class="s2">"serviceName=storage.googleapis.com"</span>
  --event-filters<span class="o">=</span><span class="s2">"methodName=storage.objects.create"</span>
</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="devops-cicd-and-sre">DevOps CICD and SRE</h3>
<h4 id="cicd">CICD</h4>
<ul>
  <li>CI: continus integration
    <ul>
      <li>代码开发完后, 持续运行测试和打包</li>
      <li><img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-20-092024.jpg" alt="CI 工具" /></li>
    </ul>
  </li>
  <li>CD: continus deployment/ delivery
    <ul>
      <li>CI 之后, 持续部署到测试环境和生产环境</li>
    </ul>
  </li>
  <li>CICD 中要做的事情
    <ul>
      <li>静态代码分析
        <ul>
          <li>Sonar Lint , 开源代码分析工具</li>
        </ul>
      </li>
      <li>Runtime 检查</li>
      <li>测试
        <ul>
          <li>单元测试</li>
          <li>整合测试</li>
          <li>系统测试</li>
          <li>Sanity and Regression testing</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>CICD 的工具
    <ul>
      <li>CICD 的工具有的是 Google Cloud 的服务, 有的是要在 Google Market Plance 中找到, 并进行安装</li>
      <li><strong>Cloud Source Repositories</strong>
        <ul>
          <li>代码管理, 相当于 github</li>
          <li>优势
            <ul>
              <li>To keep code private to a Google Cloud project</li>
              <li>To reduce work</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong>Container Registory</strong>
        <ul>
          <li>保存 自己的镜像 image</li>
        </ul>
      </li>
      <li><strong>Jenkins</strong>
        <ul>
          <li>CI 工具</li>
        </ul>
      </li>
      <li><strong>Cloud Build</strong>
        <ul>
          <li>打包工具</li>
        </ul>
      </li>
      <li><strong>Spinnaker</strong>
        <ul>
          <li>多云部署平台 (CD)
            <ul>
              <li>支持 GCE, GKE, GAE 和其他云平台</li>
              <li>支持多种部署策略</li>
              <li>快速发布应用
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-01-083057.jpg" alt="" /></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Binary authorization
    <ul>
      <li>在 continus deployment 的环节的安全控制, 保证部署可信的Image 到GKE or Cloud Run 的容器中, 在部署过程中会对image 进行签名验证, 只有可信的image 才能部署到指定环境中</li>
      <li>步骤
        <ol>
          <li>给所有 GKE Cluster (开发, staging 和 生产)配置 Binary authorization policies (二进制认证 policy)</li>
          <li>认证后只有经过签名的 image 才能进行部署</li>
          <li>设置 CI/CI pipeline, 让 attestations (验证) 作为 Pipeline 的一部分,</li>
          <li>开发人员的image 没有经过 验证, 不能直接上生产了.</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h4 id="infrastructure-as-code">Infrastructure as Code</h4>
<ul>
  <li>通过配置文件 (比如YAML) 来对infrastructure 进行部署, 配置, 修改, 管理</li>
  <li>可以跟踪 infra 的变化</li>
  <li>可以通过配置文件快速复制 infra</li>
  <li>IaC 包括了软硬两部分
    <ul>
      <li>平台硬件资源管理 (Infra Provisioning)
        <ul>
          <li>可以部署虚机, 数据库, 网络, 存储等</li>
          <li>开源方案 - <strong>Terraform</strong>
            <ul>
              <li>Terraform can be used as an infrastructure management system for Google Cloud resources.</li>
              <li>将模板部署在规模较大的环境中 以便根据需要快速创建任意多个相同的应用环境</li>
              <li>要使用Terraform 你需要使用 HashiCorp Configuration Language (HCL) 创建一个描述环境组件的模板文件 然后Terraform会使用该模型 来确定创建所描述环境所需的操作</li>
              <li>如果你需要更改环境 可以修改模板 然后使用Terraform来更新环境以进行更改</li>
              <li>你可以在Cloud Source Repositories中 存储Terraform模板</li>
            </ul>
          </li>
          <li>GCP 方案 - <strong>Google Cloud Deployment Manager</strong>
            <ul>
              <li>用Deployment manager 创建资源, 可以用它管理 Terraform</li>
              <li>Yaml 是配置文件
                <ul>
                  <li>有版本控制</li>
                </ul>
              </li>
              <li>自动处理依赖关系</li>
              <li>部署遇到错误可以自动回滚</li>
              <li>免费使用, 为部署的硬件资源付费
```YAML</li>
              <li>type: compute.v1.instance
  name: my-first-vm
  properties:
      zone: us-central1-a
      machineType: «MACHINE_TYPE»
      disks:
      - deviceName: boot
          type: PERSISTENT
          boot: true
          autoDelete: true
          initializeParams:
              sourceImage: «SOURCE_IMAGE»
      networkInterfaces:
      - network: «NETWORK»
          # Give instance a public IP Address
          accessConfigs:
          - name: External NAT
              type: ONE_TO_ONE_NAT
```</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>配置管理 (Config Management)
        <ul>
          <li>安装适合的软件和工具到硬件资源上</li>
          <li>开源工具:
            <ul>
              <li><strong>Chef</strong></li>
              <li><strong>Puppet</strong></li>
              <li><strong>Ansible</strong></li>
              <li><strong>SaltStack</strong>
                <h4 id="sre">SRE</h4>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Site Reliability Engineering</li>
  <li>体现系统性能和可靠性的四个黄金信号(Four Golden Signals)
    <ul>
      <li>latency 延迟时间
        <ul>
          <li>请求应用的响应时间, 是否足够快</li>
        </ul>
      </li>
      <li>Traffic 流量
        <ul>
          <li>用来衡量系统的请求量的大小</li>
        </ul>
      </li>
      <li>Saturation 饱和度
        <ul>
          <li>用来衡量资源资源的容量消耗的程度</li>
        </ul>
      </li>
      <li>Errors
        <ul>
          <li>衡量系统健康程度</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>是 DevOps 的升级版本 , 专注的事情比以往的更多的指标
    <ul>
      <li>availability</li>
      <li>performance</li>
      <li>efficiency</li>
      <li>change management</li>
      <li>monitoring</li>
      <li>emergency response</li>
      <li>capacity planning</li>
    </ul>
  </li>
  <li>四个衡量维度 (metrics)
    <ul>
      <li>SLI - 服务级别指标
        <ul>
          <li>在一个时间范围内的, 可衡量的服务参数
            <ul>
              <li>A time-bound measurable attribute of a service</li>
              <li>比如</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>SLO - 服务目标
        <ul>
          <li>就是几个 9</li>
        </ul>
      </li>
      <li>SLA - 服务协议
        <ul>
          <li>是一份agreement , 签字了就是合同的一部分.</li>
        </ul>
      </li>
      <li>Error Budget (错误预算)
        <ul>
          <li>是一个数值, 是 100% 减 SLO , 结果可能是 0.01 , 或者 0.00001</li>
          <li>用来衡量 SRE 团队部署的速度 (错误越少, release 速度越快越频繁)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>最佳实践
    <ul>
      <li>处理负载过量 (exceed load)
        <ul>
          <li>一些企业由于突然太过成功导致应用的访问流量暴增(success disaster)</li>
          <li>解决方案
            <ul>
              <li>Load Shedding (卸载部分流量)
                <ul>
                  <li>通过 API 访问限制</li>
                  <li>将时序类型的数据丢弃一部分</li>
                </ul>
              </li>
              <li>Reduce Quality of Service (降低服务质量)
                <ul>
                  <li>原来的实时 response 改成 hardcode 的内容</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Peneration testing (渗透测试)
        <ul>
          <li>模拟黑客攻击, 寻找安全漏洞</li>
          <li>可以是黑盒测试或白盒测试</li>
        </ul>
      </li>
      <li>Load Testing (压力测试)
        <ul>
          <li>模拟真实场景的流量</li>
          <li>模拟突发流量</li>
          <li>工具: JMeter, LoadRunner, Locust, Gatling etc</li>
        </ul>
      </li>
      <li>Resilene Testing (伸缩测试)
        <ul>
          <li>当系统的某个部分损坏了, 整个应用仍然可以进行服务的能力</li>
          <li>几种测试方法
            <ul>
              <li>Chaos Testing (Simian Army)  混沌测试
                <ul>
                  <li>随机把机房的某个部分弄坏 (想象一个有武器的猴子进了机房, 可能会随便按按钮, 扯网线)</li>
                </ul>
              </li>
              <li>在应用的某层进行压力测试</li>
              <li>测试断网
                <ul>
                  <li>比如 VPN, Cloud Interconnect 断掉</li>
                </ul>
              </li>
              <li>灾难测试
                <ul>
                  <li>比如指定时间把整个 Data Center 停电</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="marketplace-cloud-launcher">Marketplace (Cloud Launcher)</h4>
<ul>
  <li>相当于 app store</li>
  <li>可以安装
    <ul>
      <li>操作系统 - Linux 等</li>
      <li>应用环境 - LAMP 等</li>
      <li>Web 应用 - WordPress 等</li>
      <li>企业应用 - SAP Hana on GCP (商业方案, 需要付费)</li>
      <li>数据应用 - Cssandra 等</li>
      <li>CICD 工具 - Jenkins 等</li>
      <li>…</li>
    </ul>
  </li>
</ul>

<h4 id="release-management">Release Management</h4>
<ul>
  <li>发布管理的目标
    <ul>
      <li>零 downtime</li>
      <li>同一时间, 生产只有一个版本</li>
      <li>最小化承恩</li>
      <li>新版本上生产之前要测试</li>
    </ul>
  </li>
  <li>最佳实践
    <ul>
      <li>小而快的发布</li>
      <li>尽量自动化</li>
      <li>处理新发布版本的问题
        <ul>
          <li>分析日志和查看监控</li>
          <li>回滚, 在另一个环境检查问题</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>几个发布方法
    <ul>
      <li>Recreate 重建发布
        <ul>
          <li>卸载掉原来的版本, 用新版本代替</li>
          <li>特点:
            <ul>
              <li>发布需要downtime , 影响客户正常访问</li>
              <li>回滚的话需要更长的 downtime</li>
              <li>过程非常快</li>
              <li>新版本不能向后兼容时(应用和数据), 可以用这个方法</li>
              <li>不需要额外的 infra</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Canary 金丝雀发布
        <ul>
          <li>先发布新版本到部分实例上, 测试好后再在全部实力上发布新版本</li>
          <li>特点
            <ul>
              <li>没有downtime, 对用户影响小</li>
              <li>有问题就回滚</li>
              <li>新版本需要有向后兼容能力.</li>
              <li>不需要额外infra</li>
            </ul>
          </li>
          <li>AB 测试
            <ul>
              <li>是基于金丝雀的发布方式</li>
              <li>要看一下用户对两个版本的不同反应</li>
              <li>最终留下客户喜欢的那个版本</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Rolling 滚动发布
        <ul>
          <li>和金丝雀基本一样, 就是需要先设定好一个滚动升级的机制, 比如每次新版本替换生产的实例个数或百分比</li>
          <li>特点
            <ul>
              <li>没有downtime, 对用户影响小</li>
              <li>是自动发布过程, 但需要提前setup 好</li>
              <li>有问题就回滚</li>
              <li>发布速度慢, rolling 需要一段时间</li>
              <li>新版本需要有向后兼容能力.</li>
              <li>不需要额外的infra</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Rolling with additional batch
        <ul>
          <li>和 rolling 基本一样, 但是需要额外的一个/几个 实例</li>
          <li>将新版本先发布到新增加的实例上, 没问题了再将新版本 rolling 到其他实例上</li>
          <li>特点 (对比 Rolling):
            <ul>
              <li>不会影响生产上的任何正在处理用户访问的实例</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Blue Green 蓝绿发布
        <ul>
          <li>增加额外的实例环境发布新版本, 两个环境(和版本)并行, 测试后撤掉原来的环境, 保留新环境为生产环境</li>
          <li>特点
            <ul>
              <li>没有downtime</li>
              <li>在两个环境值之前切换和回滚</li>
              <li>新版本要有向后兼容能力</li>
              <li>需要很多额外的infra</li>
              <li>配置有些复杂</li>
              <li>要避免支付等场景使用蓝绿发布, 因为可能会引起重复的支付交易订单</li>
            </ul>
          </li>
          <li>Shadow 测试
            <ul>
              <li>是基于蓝绿发布的</li>
              <li>第二个环境的流量是 shadow 第一个环境的流量</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>多个 Google 服务都可以应用不同的发布方式
    <ul>
      <li>MIG (Managed Instance Group)
        <ul>
          <li>Canary</li>
          <li>Rolling</li>
          <li>Blue Green</li>
        </ul>
      </li>
      <li>App Engine
        <ul>
          <li>Recreate</li>
          <li>Canary and AB Testing</li>
          <li>Rolling</li>
        </ul>
      </li>
      <li>GKE
        <ul>
          <li>Recreate</li>
          <li>Canary</li>
          <li>Rolling</li>
          <li>Blue Green</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="identify-and-security">Identify and Security</h3>

<h4 id="container-analysis">Container Analysis</h4>
<ul>
  <li>对容器进行自动安全扫描</li>
</ul>

<h4 id="artifact-registry">Artifact Registry</h4>
<ul>
  <li>image 镜像安全管理</li>
</ul>

<h4 id="kms">KMS</h4>
<ul>
  <li>Hosted key management service</li>
  <li>要启动 KMS API, 并创建一个 Key Ring
    <ul>
      <li>Key ring, 钥匙戒指, 算是一个KMS 的总钥匙?</li>
      <li>Key rings group keys together to keep them organized.</li>
      <li>先创建好 key ring, 再在下面创建 keys (Customer-managed key)</li>
      <li>创建好 Key 之后, 在创建一个新的compute engine 的 instance 的时候, 可以在选择add new desk 的时候, 就可以选择刚创建的Customer-managed key 进行加密. (默认是用google 自己的Google-managed key)</li>
    </ul>
  </li>
  <li>数据状态分为
    <ul>
      <li>Data at rest
        <ul>
          <li>存在某个地方的数据</li>
        </ul>
      </li>
      <li>Data in motion/ transit
        <ul>
          <li>传输中的数据</li>
        </ul>
      </li>
      <li>Data in use
        <ul>
          <li>使用中的数据</li>
          <li>比如内存中的数据</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>需要为at rest, in transit 的数据进行加密</li>
  <li>加密类型
    <ul>
      <li>Symmetric key encryption 对称加密
        <ul>
          <li>用同一个key 对数据进行加密和解密</li>
        </ul>
      </li>
      <li>Asymmetric key encryption 非对称加密
        <ul>
          <li>用公钥加密, 私钥解密</li>
          <li>公钥分享给别人, 私钥自己留着</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Cloud KMS
    <ul>
      <li>Google 的 key management service</li>
      <li>KMS 用于给google cloud 的所有可加密服务提供加密</li>
      <li>分为三种
        <ul>
          <li>Google-managed key
            <ul>
              <li>Google 创建和管理</li>
              <li>我们不需要做任何管理和配置</li>
            </ul>
          </li>
          <li>Customer-managed key
            <ul>
              <li>我们在 KMS 中创建和使用</li>
              <li>Use key from KMS</li>
            </ul>
          </li>
          <li>Customer-supplied key
            <ul>
              <li>可以自己的 key, 放在 KMS 中进行管理和使用</li>
              <li>Provide your own key</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="iam-service-account-服务账号-acl">IAM, Service Account (服务账号), ACL</h4>
<ul>
  <li>Identity and Access Management (IAM)
    <ul>
      <li>IAM 有继承关系, project &gt; bucket &gt; object
        <ul>
          <li>最低级的资源的 Policy 是它和它的祖先的所有 policy 的合集</li>
        </ul>
      </li>
      <li>用户或者应用都需要访问 Google Cloud 资源
        <ul>
          <li>IAM 可以提供服务: 配置谁, 访问什么资源, 访问什么内容, 可以做什么action</li>
          <li>Authentication - 正确的用户</li>
          <li>Authorization - 正确的访问权限</li>
        </ul>
      </li>
      <li>Identify 可以是:
        <ul>
          <li>GCP User</li>
          <li>A Group of GCP Users</li>
          <li>一个 GCP 应用</li>
          <li>一个 on premise 应用</li>
          <li>未认证的外部用户</li>
        </ul>
      </li>
      <li>提供的控制包括 (对单个用户)
        <ul>
          <li>执行一个 single action</li>
          <li>针对一个特定的 cloud resource</li>
          <li>来自某个特定的 IP address</li>
          <li>在一个特定的 time window</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>为一个同事赋予访问 storage bucket 的过程
    <ul>
      <li>概念
        <ul>
          <li>Role
            <ul>
              <li>包含一些 permission (提供对某些资源的某些actions)
                <ul>
                  <li>一个role 可以有多个permissions</li>
                </ul>
              </li>
              <li>Role 中并不定义 member/who
                <ul>
                  <li>Role 定义 “can do what”</li>
                </ul>
              </li>
              <li>分三种类型
                <ul>
                  <li>Basic Roles (现在google 已经不推荐了, 因为范围比较广, 如果给一个人设置了editor, 那么他可以编辑所有Project 下面的服务, 包括 GCE, GKE, Cloud Storage 等所有服务)
                    <ul>
                      <li>Owner
                        <ul>
                          <li>view + create + update + delete + billing</li>
                        </ul>
                      </li>
                      <li>Editor
                        <ul>
                          <li>view + create + update + delete</li>
                        </ul>
                      </li>
                      <li>Viewer
                        <ul>
                          <li>view</li>
                        </ul>
                      </li>
                      <li>Billing Admin
                        <ul>
                          <li>view + billing</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>Predefined Roles
                    <ul>
                      <li>Google 提前定义好的</li>
                      <li>比如:
                        <ul>
                          <li>Storage Admin  (roles/storage.admin)
                            <ul>
                              <li><code class="language-plaintext highlighter-rouge">storage.buckets.*</code></li>
                              <li><code class="language-plaintext highlighter-rouge">storage.objects.*</code></li>
                            </ul>
                          </li>
                          <li>Storage Object Admin (roles/storage.objectAdmin)
                            <ul>
                              <li><code class="language-plaintext highlighter-rouge">storage.objects.*</code></li>
                            </ul>
                          </li>
                          <li>Storage Object Viewer (roles/storage.objectViewer)
                            <ul>
                              <li><code class="language-plaintext highlighter-rouge">storage.objects.get</code></li>
                              <li><code class="language-plaintext highlighter-rouge">storage.objects.list</code></li>
                            </ul>
                          </li>
                          <li>Storage Object Creator  (roles/storage.objectCreator)</li>
                          <li><code class="language-plaintext highlighter-rouge">storage.objects.create</code></li>
                        </ul>
                      </li>
                      <li>每个 Role 都有的 permission
                        <ul>
                          <li><code class="language-plaintext highlighter-rouge">resourcemanager.projects.get</code></li>
                          <li><code class="language-plaintext highlighter-rouge">resourcemanager.projects.list</code></li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>Custom Roles
                    <ul>
                      <li>我们自己定义的 Roles 来弥补 perdefined roles 不能满足的情况</li>
                      <li>比如定义一个人, 除了可以 editor GCE 和 GKE 之外, 不能干别的事情</li>
                      <li>只能应用在 Org 和 Project level, 不能在 folder level 应用</li>
                      <li>一般用来设置指定的服务的访问权限</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Policy
            <ul>
              <li>指定 哪个 member/group/service account/workspace or cloud identity domain/外部用户 有什么 role
                <ul>
                  <li>一个member 可以有多个role, 是在policy 中定义的</li>
                </ul>
              </li>
              <li>指定有什么条件, 比如 Which Resources?, When?, From Where?</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>步骤
        <ul>
          <li>选择一个合适的 role - (ex. Storage Object Admin)</li>
          <li>创建 Policy, 把同事和这个role 绑定</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Service Account 服务账号
    <ul>
      <li>为应用提供访问 GCP 资源</li>
      <li>比如, 给一个 VM 访问Cloud Storage 的权限,而不用给VM创建一个个人账号</li>
      <li>service account 也是资源, 如果某个人要访问, 也需要给一个role (editor or viewer) 才能访问</li>
      <li>可以跨项目访问
        <ul>
          <li>In project B, add the service account from Project A and assign Storage Object Viewer Permission on the bucket</li>
        </ul>
      </li>
      <li>Service account 有一个唯一的email 地址, 但不需要password
        <ul>
          <li>有公钥私钥</li>
          <li>不能通过浏览器登录</li>
        </ul>
      </li>
      <li>服务账号的类型有三种
        <ul>
          <li>Default service account
            <ul>
              <li>当我们使用某些服务的时候, 系统会自动创建一个账号</li>
              <li>一般不推荐我们使用</li>
            </ul>
          </li>
          <li>User Managed
            <ul>
              <li>用户自己创建的 Service account</li>
              <li>推荐我们使用自定义的</li>
            </ul>
          </li>
          <li>Google Managed service account
            <ul>
              <li>GCP 用来代替用户对服务进行管理的</li>
              <li>我们不用管这种服务账号</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>服务账号在几个场景中的创建过程
        <ul>
          <li>场景 1: VM -&gt; Cloud Storage
            <ul>
              <li>创建一个 Service account 给 VM</li>
              <li>把Cloud Storage 的 <strong>IAM</strong> role assign 给 VM 实例
                <ul>
                  <li>系统会自动创建 Google Cloud-Managed Keys , 并用于 assignment</li>
                  <li>只要不删除 Service account, VM 就可以一只访问 cloud storage</li>
                  <li>这个 Role 也是 IAM Role, 把这个 IAM role 给 service account</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>场景 2: on-prem -&gt; Cloud Storage
            <ul>
              <li>我们不能直接把service account assign 给 on-premise 的 App</li>
              <li>创建一个 service account</li>
              <li>创建一个 service account User Managed Key</li>
              <li>让 on-prem 的应用访问 key file
                <ul>
                  <li>本地设置一个环境变量 <code class="language-plaintext highlighter-rouge">export GOOGLE_APPLICATION_CREDENTIALS="/PATH_TO_KEY_FILE"</code></li>
                </ul>
              </li>
              <li>本地应用调用 Google Cloud Client Libraries , 就可以找到环境变量, 并访问 Cloud Storage</li>
            </ul>
          </li>
          <li>场景 3: Google Cloud APIs (Short Lived)
            <ul>
              <li>因为访问时短暂的, 使用 OAuth2.0 或者 OpenID 或者 JWTs token 就可以了</li>
              <li></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>ACL (Access Control Lists)
    <ul>
      <li>定义了谁可以访问 Bucket, 以及访问什么level</li>
      <li>和 IAM 的区别
        <ul>
          <li>IAM 只能允许访问一个 Bucket 中的所有 objects
            <ul>
              <li>Uniform 的形式访问 Bucket</li>
            </ul>
          </li>
          <li>ACL 可以设定访问哪些 Objects
            <ul>
              <li>Fine-grained 的形式访问 Bucket.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>IAM 允许用户访问 Object, 但是 ACL 没有允许, 用户也可以访问 Object.</li>
    </ul>
  </li>
  <li>Signed URL
    <ul>
      <li>让外部用户(无google cloud 账号的用户) 临时的访问 Bucket 中的 objects</li>
      <li>创建流程
        <ul>
          <li>1: Create a key (YOUR_KEY) for the Service Account/User with the desired permissions</li>
          <li>2: Create Signed URL with the key: <code class="language-plaintext highlighter-rouge">gsutil signurl -d 10m YOUR_KEY gs://BUCKET_NAME/OBJECT_PATH</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>用 Bucket 创建一个静态网站
    <ul>
      <li>创建一个bucket, 上传web 页面
        <ul>
          <li>bucket 的名字要和 DNS 中的域名保持一致</li>
          <li>要有index.html 和 error.html</li>
          <li>在bucket 中的 permission中 增加 <code class="language-plaintext highlighter-rouge">allUser</code> , 并赋予 <code class="language-plaintext highlighter-rouge">Storage Object Viewer</code> 权限</li>
          <li>bucket 就会出现 public URL 地址</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Policy 的 描述文件
    <div class="language-json highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></td><td class="code"><pre><span class="p">{</span><span class="w">
  </span><span class="nt">"bindings"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
      </span><span class="p">{</span><span class="w">
          </span><span class="nt">"role"</span><span class="p">:</span><span class="w"> </span><span class="s2">"roles/storage.objectAdmin"</span><span class="p">,</span><span class="w">
          </span><span class="nt">"members"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
              </span><span class="s2">"user:you@in28minutes.com"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"serviceAccount:myAppName@appspot.gserviceaccount.com"</span><span class="p">,</span><span class="w">  
              </span><span class="s2">"group:administrators@in28minutes.com"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"domain:google.com"</span><span class="w">
          </span><span class="p">]</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="p">{</span><span class="w">
          </span><span class="nt">"role"</span><span class="p">:</span><span class="w"> </span><span class="s2">"roles/storage.objectViewer"</span><span class="p">,</span><span class="w">
          </span><span class="nt">"members"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
              </span><span class="s2">"user:you@in28minutes.com"</span><span class="w">
          </span><span class="p">],</span><span class="w">
          </span><span class="nt">"condition"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
              </span><span class="nt">"title"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Limited time access"</span><span class="p">,</span><span class="w">
              </span><span class="nt">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Only upto Feb 2022"</span><span class="p">,</span><span class="w">
              </span><span class="nt">"expression"</span><span class="p">:</span><span class="w"> </span><span class="s2">"request.time &lt; timestamp('2022-02-01T00:00:00.000Z')"</span><span class="p">,</span><span class="w">
          </span><span class="err">}</span><span class="w">
      </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table>
</div>
    </div>
  </li>
  <li>用 <code class="language-plaintext highlighter-rouge">gcloud</code> 命令</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre>gcloud compute project-info describe <span class="c">#- Describe current project</span>
gcloud auth login <span class="c">#- Access the Cloud Platform with Google user credentials</span>
gcloud auth revoke <span class="c">#- Revoke access credentials for an account</span>
gcloud auth list <span class="c">#- List active accounts</span>
<span class="c"># gcloud projects</span>
gcloud projects add-iam-policy-binding <span class="c">#- Add IAM policy binding</span>
gcloud projects get-iam-policy <span class="c">#- Get IAM policy for a project</span>
gcloud projects remove-iam-policy-binding <span class="c">#- Remove IAM policy binding </span>
gcloud projects <span class="nb">set</span>-iam-policy <span class="c"># - Set the IAM policy</span>
gcloud projects delete <span class="c">#- Delete a project</span>
<span class="c"># gcloud iam</span>
gcloud iam roles describe <span class="c">#- Describe an IAM role</span>
gcloud iam roles create <span class="c">#- create an iam role(--project, --permissions, --stage) </span>
gcloud iam roles copy <span class="c">#- Copy IAM Roles</span>

</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="iam-organization-billing-account-id-manager">IAM, Organization, Billing Account, ID manager</h4>
<ul>
  <li>IAM 中的几个概念
    <ul>
      <li>Google Account
        <ul>
          <li>一个人的账号, 一个 email 地址</li>
        </ul>
      </li>
      <li>Service Account
        <ul>
          <li>一个应用账号, 提供访问一个服务所需要的权限</li>
        </ul>
      </li>
      <li>Google Group
        <ul>
          <li>每个group 有一个对应的email 地址</li>
          <li>group 下面可以有多个 Google Account</li>
          <li>group 是跨project 的</li>
          <li>policy 可以应用到 group 上</li>
        </ul>
      </li>
      <li>Workspace
        <ul>
          <li>原来叫做 G suite</li>
          <li>提供google 多种产品的 API , 比如 Google Chat, Gmail, Calendar, Meet 的 API</li>
          <li>Workspace 下面的都是 SaaS 服务</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>GCP 的资源层级
    <ul>
      <li>Organization &gt; Folder &gt; Project &gt; Resources</li>
      <li>每个层级都可以单独设置 Policy, policy 向下继承</li>
      <li>由较低级别的策略实施的 IAM 策略可以 覆盖在更高级别定义的策略(IAM policies that are implemented by lower-level policies can
override the policies defined at a higher level.) ?</li>
      <li>组织是一个公司
        <ul>
          <li>org 有一些特殊权限的role, 比如 org.policy.administrator 专门负责修改权限</li>
          <li>默认用gmail 创建的GCP 是不带 org 的, 需要自己去创建 org, 主要的两个原因是:
            <ul>
              <li>When you want to centrally apply organization-wide policies</li>
              <li>When you want to create folders</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Folder 往往是一个部门
        <ul>
          <li>Folder 下面可以有 子Folder 和 projects</li>
          <li>Folder 可以设置 Policy, 被下面所有的 Folder 和 Projects 继承</li>
        </ul>
      </li>
      <li>Project 是一个项目的一个环境(开发/测试/生产)
        <ul>
          <li>为一个项目的不同环境创建不同项目</li>
          <li>可以为要共享的资源创建共享目录</li>
          <li>更容易为该环境的使用人员分配统一权限</li>
          <li>所有的 GCP 资源都跟某个 Project 关联 (project 可以关联所有的 GCP 资源)</li>
        </ul>
      </li>
      <li>Resources 是 project 下的一个服务</li>
    </ul>
  </li>
  <li>Billing Account (付费账户)
    <ul>
      <li>一个org 下面可以有多个 billing account
        <ul>
          <li>初创公司可以只有一个biiling account</li>
          <li>大企业建议按组织的架构设计 billing account, 比如 IT, HR</li>
        </ul>
      </li>
      <li>一个 Billing account 下面可以有一个或多个项目</li>
      <li>billing account 下面包含付费详细信息</li>
      <li>可以为每个billing account 设置 budget, alter and export
        <ul>
          <li>比如设置 400 块钱的 budget, 然后设置在 200 块钱, 320 块, 400 块的时候进行 alert 提醒
            <ul>
              <li>alert 可以发送到
                <ul>
                  <li>email</li>
                  <li>pub/sub</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>可以为已经花费的详细信息导出数据报表
            <ul>
              <li>可以在 Big Query 中进行查看分析</li>
              <li>可以把历史的 export 存放到 cloud storage 中长期保存</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Organization policies
    <ul>
      <li>是跨项目的, 全组织级别的 policies</li>
      <li>比如:
        <ul>
          <li>允许或者不允许在某个 region 创建资源</li>
          <li>全组织不允许创建 Service Account</li>
        </ul>
      </li>
      <li>需要有 Organization Policy Administrator 这个 Role 才能进行编辑</li>
      <li>Policy 是可以继承的, 从 Org &gt; Folder &gt; Project &gt; Resource
        <ul>
          <li>Policy 可以在任何一个层级进行设置</li>
          <li>Resources 会继承所有父层级的所有 policies
            <ul>
              <li>这个resrouce 上的有效 policy 是它和它的所有父 policy 的 并集 (Union)</li>
              <li>父层设置的 Policy, 子层是不能进行限制和修改的的
                <ul>
                  <li>比如 Org policy 设置了不能创建 VM, 那么 folder level 和 project level 就算设置了可以创建 VM 也没用.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>提示:
        <ul>
          <li>IAM 是 Who</li>
        </ul>
      </li>
      <li>Org Policy 是 What</li>
    </ul>
  </li>
  <li>IAM 最佳实践
    <ul>
      <li>最少权限
        <ul>
          <li>按需提供权限, 不要给额外的, 不需要的权限</li>
          <li>不建议给 Basic Roles (Owner/Viewer/Editor) 权限</li>
        </ul>
      </li>
      <li>分离权限
        <ul>
          <li>敏感的服务, 可以考虑把权限分给两个人, 每人负责一部分, 比如deploy 一个人, release 新版本 一个人</li>
        </ul>
      </li>
      <li>持续监控
        <ul>
          <li>用 cloud audit log 来审计  IAM policy 的使用 和 Service Account 的 key 的访问情况</li>
        </ul>
      </li>
      <li>尽量多的使用 Group
        <ul>
          <li>组中有多个用户, 可以绑定 role 和 group , 为多个用户赋予相同权限</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Identity management (谷歌云的 ID 管理)
    <ul>
      <li>普通用户
        <ul>
          <li>可以通过注册时使用的 Gmail 账号 可以作为 Super Admin 来访问 Organization, Folders, Projects</li>
        </ul>
      </li>
      <li>企业用户:
        <ul>
          <li>Option 1: Google Workspace
            <ul>
              <li>用户用企业自己的域名邮箱登录谷歌云</li>
              <li>企业通过 Worksapce 管理用户, 组</li>
              <li>把 Org 和 workspace 整合</li>
            </ul>
          </li>
          <li>Option 2: Federation
            <ul>
              <li>用户用第三方的 Idp (Identity provider) 登录谷歌云
                <ul>
                  <li>步骤
                    <ul>
                      <li>用户登录时跳转到第三方 Idp 进行登录认证</li>
                      <li>认证完成后, 再跳转回 google, 同时SAML assertion (断言) 会发送到 Google Sign-in</li>
                      <li>好处 - 不需要保留用户登录的敏感信息到 GCP 上, 满足一些企业的合规要求.</li>
                    </ul>
                  </li>
                  <li>第三方 Idp 包括
                    <ul>
                      <li>AD (Active Directory)
                        <ul>
                          <li>Google Cloud Directory Sync 可以同步 Google 和 (on-prem)AD 之间的用户和组的数据</li>
                          <li>单向同步 (on-prem to GCP)</li>
                          <li>同步之后, 就可以用 SAML 进行 SSO 登录</li>
                        </ul>
                      </li>
                      <li>AAD (Azure Active Directorty)
                        <ul>
                          <li>AAD 可以整合 on premises 的 AD</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>Federation 的场景
                    <ul>
                      <li>使用 IDaaS (比如 Okta) 作为 Idp, 进行 Single Sign On 登录</li>
                      <li>使用 AD 作为 Idp 进行 SSO 登录</li>
                      <li>使用 AAD 作为 Idp 进行 SSO 登录</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>IAM Member 和 ID 的场景
    <ul>
      <li>所有用户都有 G suit 账号, 我们创建了一个新的项目(生产) , 需要给运营团队提供访问权限.
        <ul>
          <li>方案
            <ul>
              <li>给运营团队创建一个组, 给这个组提供可以访问项目的权限</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>所有用户都有 G suit 账号, 我们创建了一个新的项目(生产) , 需要给一个团队成员提供访问权限.
        <ul>
          <li>方案
            <ul>
              <li>和上面的方案一样. 但如果只是一次性的临时访问, 就位这个人单独提供必要的 role 的访问权限</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>给一个外部的审计人员提供可以查看一个项目的所有资源, 他不能进行任何修改
        <ul>
          <li>方案
            <ul>
              <li>给审计人员提供 Basic Roles 的 roles/viewer role</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>项目 A 的一个 VM 上的应用需要访问项目 B 的 cloud storage 的 bucket.
        <ul>
          <li>方案
            <ul>
              <li>在 project B 中 给 Project A 的  VM 设置可以访问的 role</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>OAuth2.0 和 SAML 的不同场景
      1.  提到 Restful API 的 <code class="language-plaintext highlighter-rouge">authorization and authentication</code>, <code class="language-plaintext highlighter-rouge">delegated authorization</code> 那就是 OAuth 2.0
      2.  想要用 google/youtube 账号登录一个 smart TV app, 就用 OAuth 2
      3.  提到 <code class="language-plaintext highlighter-rouge">Identity management</code> , 企业内部软件放到 GCP 上, 要用企业内部  ID 进行 SSO 登录 , 就是 SAML<br />
      4.  要选择一个 protocol 来进行 SSO 登录, 那就是 SAML</li>
</ul>

<h4 id="identity-aware-proxy-iap">Identity Aware Proxy (IAP)</h4>
<ul>
  <li>提供登录认证授权服务</li>
  <li>当您要对应用和资源强制执行访问权限控制政策时，请使用 IAP</li>
  <li>比如对指定的用户,组授权访问资源</li>
  <li>比如您可以允许员工但不允许承包商使用某一资源，或者只允许特定部门使用该资源。</li>
  <li>IAP 可以使用  Google Cloud Directory Sync 与 Active Directory 或 LDAP 服务器同步 后的用户和组数据进行登录.</li>
</ul>

<h4 id="identity-platform">Identity Platform</h4>
<ul>
  <li>为客户的应用提供登录认证服务, 可以称为 CIAM</li>
  <li>和 IAM 区别
    <ul>
      <li>IAM 是提供用户访问谷歌云里的服务的认证机制</li>
      <li>CIAM 是为用户的应用提供认证的机制</li>
    </ul>
  </li>
  <li>主要功能
    <ul>
      <li>Authentication &amp; authorization for web &amp; mobile apps (iOS, Android, ..)</li>
      <li>Multiple authentication methods
        <ul>
          <li>SAML, OIDC, email/password, phone, social - Google/Facebook/Twitter/..</li>
        </ul>
      </li>
      <li>Features: User sign-up and sign-in, MFA etc.</li>
      <li>是从 Firebase Authentication Legacy 演化而来的</li>
      <li>完美集成了 Identity-Aware Proxy</li>
    </ul>
  </li>
  <li>使用 IAM 和 CIAM 的场景
    <ul>
      <li>An Application on a GCE VM needs access to cloud storage
        <ul>
          <li>Cloud IAM - Service Account</li>
        </ul>
      </li>
      <li>An enterprise user need access to upload objects to a Cloud Storage bucket
        <ul>
          <li>Cloud IAM</li>
        </ul>
      </li>
      <li>I want to manage end users for my application
        <ul>
          <li>Identity Platform</li>
        </ul>
      </li>
      <li>I want to enable “Login using facebook/twitter” for my application
        <ul>
          <li>Identity Platform</li>
        </ul>
      </li>
      <li>I want to create user sign-up and sign-in workflows for my application
        <ul>
          <li>Identity Platform</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>和 Service Account 的区别
    <ul>
      <li>service accoutn 是 GCP 内部的服务之间互相访问的权限机制</li>
    </ul>
  </li>
</ul>

<h4 id="cloud-armor">Cloud Armor</h4>
<ul>
  <li>是一个防止 DDos 网络攻击解决方案库, 收集每年的 OWASP Top 10 attacks, 并提供保护机制</li>
</ul>

<h4 id="secret-manager">Secret Manager</h4>
<ul>
  <li>存放数据库密码, API key credentials</li>
</ul>

<h4 id="security-command-center">Security Command Center</h4>
<ul>
  <li>用 Security Command Center 分析 infra 的安全
    <ul>
      <li>功能
        <ul>
          <li>维护 compliance</li>
          <li>发现风险 (对现有的project, 资源…)</li>
          <li>可视化风险</li>
        </ul>
      </li>
      <li>可以对多个 GCP 服务进行安全管理</li>
    </ul>
  </li>
</ul>

<p><img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-27-084817.jpg" alt="" />
<img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-27-085056.jpg" alt="" /></p>
<h4 id="network-intelligence-center">Network Intelligence Center</h4>
<ul>
  <li>用 Network Intelligence Center 监控网络, 检查网络拓扑和架构</li>
</ul>

<h3 id="operations-and-monitoring">Operations and Monitoring</h3>
<ul>
  <li>Cloud Operation 原来的名字是 Stackdriver, 包含了
    <ul>
      <li>Cloud Monitoring</li>
      <li>Cloud Logging</li>
      <li>Cloud Trace</li>
      <li>Cloud Debugger</li>
      <li>Cloud Profiler</li>
      <li>Cloud Error Reporting
        <h4 id="cloud-monitoring">Cloud Monitoring</h4>
      </li>
      <li>需要先建立 workspace (orgnization) 才能监控多个项目</li>
      <li>可以监控服务的 metrics
        <ul>
          <li>CPU</li>
          <li>Network</li>
          <li>Process matrics</li>
          <li>Disk traffic</li>
          <li>Uptime</li>
        </ul>
      </li>
      <li>可自定义监控指标 (custom metrics)</li>
      <li>需要在 VM 上安装 Cloud Monitoring agent</li>
      <li>可以创建 dashboard 来视觉化监控内容和结果</li>
      <li>可以配置 Alert 来提供报警
        <ul>
          <li>Condition</li>
          <li>Notification</li>
          <li>Documentation</li>
        </ul>
      </li>
      <li>可监控 GCP 的多个项目 和 AWS 服务</li>
    </ul>
  </li>
</ul>

<h4 id="opentelemetry">OpenTelemetry</h4>
<ul>
  <li>不是谷歌云的服务</li>
  <li><a href="https://opentelemetry.io">Opentelemetry</a> 一个遵循 CNCF 的, 跨平台的, 开源监控服务</li>
  <li>Steps to use OpenTelemetry:
1: Add OpenTelemetry libraries (for your specific language) to your project
2: Instrument your code to export telemetry</li>
  <li>下游:
    <ul>
      <li>Google Cloud Monitoring</li>
      <li>Google Cloud Logging</li>
      <li>Google Cloud Trace</li>
    </ul>
  </li>
  <li>用 <code class="language-plaintext highlighter-rouge">X-Cloud-Trace-Context</code> header 放指定参数, 来跟踪某个请求
    <ul>
      <li>To force a specific request to be traced, add an X-Cloud-Trace-Context header to the request.</li>
    </ul>
  </li>
</ul>

<h4 id="cloud-logging">Cloud Logging</h4>
<ul>
  <li>可以从所有的服务中获取实时日志进行分析
    <ul>
      <li>大多数Google managed service (无服务)都是自动发送日志到 Cloud Logging</li>
      <li>VM 是通过 安装 Logging Agent (基于 Fluentd) 想 Cloud Logging 发送日志
        <ul>
          <li>建议所有 VM 都安装 Logging Agent</li>
        </ul>
      </li>
      <li>On-premises 的服务器或者虚机可以通过下面两种方式发送日志
        <ul>
          <li>Blue Medora 的 BindPlane tool (推荐)</li>
          <li>Cloud Logging API</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>可提供日志的获取, 存储, 搜索, 分析, 监控, 报警</li>
  <li>可以自定义 log 的 metrics (Cloud Logging lets you define metrics based on your logs.)</li>
  <li></li>
  <li>无服务</li>
  <li>主要功能
    <ul>
      <li>Logs Explorer - Search, sort &amp; analyze using flexible queries</li>
      <li>Logs Dashboard - Rich visualization</li>
      <li>Logs Metrics - Capture metrics from logs (using queries/matching strings</li>
      <li>Logs Router - Route different log entries to different destinations</li>
    </ul>
  </li>
  <li>审计日志
    <ul>
      <li>提供
        <ul>
          <li>对什么服务</li>
          <li>做了什么操作</li>
          <li>对什么资源进行了audit</li>
          <li>谁进触发的日志</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>日志可以导出到以下服务中, 进行后续操作
    <ul>
      <li>Pub/sub</li>
      <li>BigQuery</li>
      <li>Cloud Storage</li>
    </ul>
  </li>
  <li>日志保存
    <ul>
      <li>普通日志: 默认 30 天,  最大 3650 天 (10 年)</li>
      <li>管理日志: 默认 400 天
        <h4 id="access-transparency-log-访问透明日志">Access Transparency Log (访问透明日志)</h4>
        <ul>
          <li>提供 GCP 团队访问我们的服务的日志 (只有 Gold 级别的客户才会有这个服务)
            <h4 id="cloud-audit-logs-审计日志">Cloud Audit Logs (审计日志)</h4>
          </li>
          <li>四种
            <ul>
              <li>Admin Activity Logs
                <ul>
                  <li>以管理员身份登录的用户进行的操作日志</li>
                  <li>比如 VM 的创建, 打补丁, 修改 IAM 权限</li>
                  <li>比如 修改bucket or object</li>
                </ul>
              </li>
              <li>Data Access Logs
                <ul>
                  <li>数据访问日志</li>
                  <li>比如 VM 的 Listing, Image 的 listing</li>
                  <li>比如 Bucket 和 object 的 修改和查看, 比如 BigQuery 的 query 查询
                    <ul>
                      <li>如果为了审计要求, 要记录一个bucket 中的所有的活动行为
                        <ul>
                          <li>为 Bucket 开启 <code class="language-plaintext highlighter-rouge">data access audit logging</code></li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>System Event Audit Logs
                <ul>
                  <li>非人为的系统级别日志</li>
                  <li>比如虚机自动重启, GCP 系统维护</li>
                </ul>
              </li>
              <li>Policy Denied Audit Logs
                <ul>
                  <li>用户或者Service account 访问被拒绝</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>日志的路由 (Routing)
    <ul>
      <li><img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-01-07-155107.jpg" alt="" /></li>
      <li>Log 从不同的来源都要经过 Routing</li>
      <li>路由通过查看规则决定将什么来源的日志, 需要经过什么样的过滤/筛选, 最后发送到什么地方</li>
      <li>Sinks 是路由规则</li>
      <li>Log 经过路由可以保存到:
        <ul>
          <li>Locked sinks (默认的日志存放方式)
            <ul>
              <li>_Required logs bucket
                <ul>
                  <li>存放管理事件, 系统事件, Access Transparency logs</li>
                  <li>保存 400 天 (不能改)</li>
                  <li>免费, 不能删掉bucket</li>
                </ul>
              </li>
              <li>_Default logs bucket
                <ul>
                  <li>其他类型系统日志</li>
                  <li>保存 30 天 (可改成 1 天到 10 年)</li>
                  <li>不能删, 但是可以disable</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>User-managed Log Sinks (用户自定义的日志导出, 长期存放的下游服务)
            <ul>
              <li>Cloud Storage</li>
              <li>BigQuery</li>
              <li>Pub/Sub</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>日志使用场景
    <ul>
      <li>VM 的 trouble shooting
        <ul>
          <li>安装 Cloud logging agent 把日志导到 Cloud Logging</li>
          <li>在Cloud Logging 导出的日志中搜索线索</li>
        </ul>
      </li>
      <li>用 BigQuery 查询和分析日志
        <ul>
          <li>安装 Cloud logging agent 把日志导到 Cloud Logging</li>
          <li>创建 BigQuery 数据库</li>
          <li>在 Cloud Logging 中创建 Sink, 把log 在按照规则导出到 BigQuery</li>
        </ul>
      </li>
      <li>保留日志给外部审计使用
        <ul>
          <li>在 Cloud Logging 中创建 Sink , 把log 导到自己创建的bucket 中</li>
          <li>在 Bucket 中为审计员创建 Storage Object Viewer role</li>
          <li>也可以用 Google Data Studio 看分析图形数据</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="stackdrive-log">Stackdrive log</h4>
<ul>
  <li>就是 Cloud log 原来的名字</li>
  <li>收集各种日志, stackdriver is google’s recommended tool for monitoring and debbuging</li>
  <li>场景:
    <ul>
      <li>测试 灾难计划</li>
    </ul>
  </li>
  <li>Stackdriver logs对比 (Admin) Activity logs
    <ul>
      <li>(Admin) Activity logs 是用来查看系统被用户使用的情况的
        <ul>
          <li>以管理员身份登录的用户进行的操作日志</li>
          <li>比如 VM 的创建, 打补丁, 修改 IAM 权限</li>
          <li>比如 修改bucket or object</li>
        </ul>
      </li>
      <li>Stackdriver logs 可以看系统级别的事件
        <ul>
          <li>可以从所有的服务中获取实时日志进行分析和debug</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="cloud-trace">Cloud Trace</h4>
<ul>
  <li>相当于浏览器的网页加载过程分析工具, 像甘特图一样展示所有元素的加载时间和依赖关系.</li>
  <li>它可以告诉你
    <ul>
      <li>• How long does it take to handle a given request?</li>
      <li>. Why is it taking so long to handle a request?</li>
      <li>• Why do some of the requests take longer than others?</li>
      <li>• What is the overall latency of requests for the application?</li>
    </ul>
  </li>
  <li>分布式跟踪系统</li>
  <li>通过对应用的tracing , 获取应用每个步骤的延迟(读取)时间数据, 并进行分析, 找出性能瓶颈</li>
  <li>通过 Cloud Trace API 可以跟踪很多服务
    <ul>
      <li>Compute Engine</li>
      <li>Cloud Run</li>
      <li>Cloud Function</li>
      <li>GKE</li>
      <li>App Engine (Flexible/Standard)</li>
      <li>…</li>
    </ul>
  </li>
  <li>支持的语言包括
    <ul>
      <li>C#, Go, Java, Node.js, PHP, Python &amp; Ruby
        <h4 id="cloud-debugger">Cloud Debugger</h4>
      </li>
    </ul>
  </li>
  <li>可让您在任意代码位置检查应用状态，既不需要停止正在运行的应用，也不会导致应用性能下降</li>
  <li>部署，包括测试、开发和生产。只有在捕获应用状态时，调试程序才会在请求延迟时间内增加不到 10 毫秒的时间</li>
  <li>Take snapshots of variables and call stack</li>
  <li>No need to add logging statements</li>
  <li>支持的语言包括
    <ul>
      <li>Python、 Node.js、 Java、 Go、 Ruby、 PHP 或 .NET Core
        <h4 id="cloud-profiler">Cloud Profiler</h4>
      </li>
    </ul>
  </li>
  <li>系统性能瓶颈 的剖析工具
    <ul>
      <li>分析 CPU ,内存</li>
      <li>从源代码中剖析, 找到性能瓶颈</li>
      <li>可以分析运行在不同平台环境的应用, 包括
        <ul>
          <li>GCP</li>
          <li>AWS,Azure,…</li>
          <li>on-premise</li>
        </ul>
      </li>
      <li>功能包括
        <ul>
          <li>Profiling agent (获取剖析数据)</li>
          <li>Profiler interface (查看数据报表)</li>
        </ul>
      </li>
      <li>支持的开发语言
        <ul>
          <li>Java</li>
          <li>go</li>
          <li>python</li>
          <li>node.js
            <h4 id="error-reporing">Error Reporing</h4>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>实时获取生产环境的异常问题</li>
  <li>把所有的 error 集中在 console 中管理</li>
  <li>使用 Firebase Crash Reporting (放在手机上跟踪app crash 的) 获取 iOS 和 Android 的崩溃信息</li>
  <li>可以看到error 详细信息
    <ul>
      <li>时间,频率, 影响的用户账号登</li>
    </ul>
  </li>
  <li>特支持开发语言包括
    <ul>
      <li>Go, Java, .NET, Node.js, PHP, Python, and Ruby</li>
    </ul>
  </li>
</ul>

<h4 id="os-patch-management">OS Patch Management</h4>
<ul>
  <li>给  VM 的操作系统机型升级管理的</li>
  <li>包含两部分
    <ul>
      <li>Patch compliance reporting
        <ul>
          <li>which provides insights on the patch status of your VM instances across Windows and Linux distributions. Along with the insights, you can also view recommendations for your VM instances.</li>
        </ul>
      </li>
      <li>Patch deployment
        <ul>
          <li>which automates the operating system and software patch update process. A patch deployment schedules patch jobs. A patch job runs across VM instances and applies patches.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="cloud-operations-for-gke">Cloud Operations for GKE</h4>
<ol>
  <li>You can view a cluster’s key metrics, such as CPU utilization, memory utilization, and the number of open incidents.</li>
  <li>You can view clusters by their infrastructure, workloads, or services.</li>
  <li>You can inspect namespaces, nodes, workloads, services, pods, and containers.</li>
  <li>For pods and containers, you can view metrics as a function of time and view log entries.</li>
</ol>

<h4 id="场景">场景</h4>
<ul>
  <li>跟踪对微服务的一个请求
    <ul>
      <li>Cloud Trace</li>
    </ul>
  </li>
  <li>确定一个微服务的 异常 (error)
    <ul>
      <li>Error Reporting</li>
    </ul>
  </li>
  <li>再生产上 一步一步 Debug 一个问题
    <ul>
      <li>Cloud Debugger</li>
    </ul>
  </li>
  <li>要看一个请求的日志
    <ul>
      <li>Cloud Logging</li>
    </ul>
  </li>
  <li>为了审计要求, 要记录一个bucket 中的所有的活动行为
    <ul>
      <li>为 Bucket 开启 <code class="language-plaintext highlighter-rouge">data access audit logging</code></li>
    </ul>
  </li>
</ul>

<h3 id="complaiance-and-regulations-合规">Complaiance and Regulations 合规</h3>
<ul>
  <li>谷歌云支持合规</li>
  <li>用谷歌云的用户也需要确保自己在云上的应用合规</li>
  <li>客户如果要保证合规, 需要和 google 签署一份 BAA (Business Associate Agreement)</li>
  <li>谷歌云支持多种认证和标准
    <ul>
      <li>ISO/IEC 27001
        <ul>
          <li>security controls , 管理信息风险</li>
        </ul>
      </li>
      <li>ISO/IEC 27017
        <ul>
          <li>information security controls , 云服务</li>
        </ul>
      </li>
      <li>ISO/IEC 27018
        <ul>
          <li>云的个人隐私数据安全,  critical components of cloud privacy - personally identifiable information (PII)</li>
        </ul>
      </li>
      <li>ISO/IEC 27701
        <ul>
          <li>国际隐私标准</li>
        </ul>
      </li>
      <li>PCI DSS
        <ul>
          <li>Payment Card Industry (PCI) Data Security Standards (DSS)</li>
          <li>PCI DSS: PCI 支付卡的数据安全标准</li>
          <li>用 tokenizer service 加密信用卡中的敏感信息
            <ul>
              <li>tokenizer service 是用来对信用卡的敏感信息做对应的token, 有了这个 token 就不用保存信用卡的敏感信息了, 也就合规了.</li>
            </ul>
          </li>
          <li>22 年,  GCP 整体都满足了  PCI 的合规要求, 但是客户仍然需要自己配置环境, 让自己的应用满足 PIC 合规</li>
        </ul>
      </li>
      <li>SOC 1
        <ul>
          <li>审计, 供应商的服务</li>
        </ul>
      </li>
      <li>SOC 2
        <ul>
          <li>审计, 服务供应商的安全,  可用, 隐私, 保密.</li>
        </ul>
      </li>
      <li>COPPA
        <ul>
          <li>儿童线上隐私保护 Children’s Online Privacy Protection Act</li>
        </ul>
      </li>
      <li>HIPAA
        <ul>
          <li>健康保险便携义务 Health Insurance Portability and Accountability Act</li>
          <li>Reference: https://cloud.google.com/security/compliance/hipaa/</li>
        </ul>
      </li>
      <li>GDPR
        <ul>
          <li>欧洲数据保护 General Data Protection Regulation</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>HIPAA 最佳实践
    <ul>
      <li>应用 IAM 最佳实践</li>
      <li>开启 Cloud Storage buckets 的 版本功能</li>
      <li>开启 Autid log, 并把log 存到 Cloud Storage 中</li>
      <li>不要对 PHI 的信息 缓存到 Cloud CDN</li>
    </ul>
  </li>
  <li>PCI 最佳实践
    <ul>
      <li>碰到有支付的应用, 为支付环境创建一个单独的账号和环境
        <ul>
          <li>隔离其他环境</li>
        </ul>
      </li>
      <li>限制对这个环境的访问
        <ul>
          <li>Follow “principle of least privilege”</li>
        </ul>
      </li>
      <li>控制进和出的流量
        <ul>
          <li>inbound: 通过 firewall rule 控制, 只允许
            <ul>
              <li>https</li>
              <li>同一个内网网段访问</li>
              <li>办公室的网络(给审计和管理用)</li>
            </ul>
          </li>
          <li>outbound: 只允许
            <ul>
              <li>https</li>
              <li>反馈给 third-party payment processor</li>
            </ul>
          </li>
          <li>应用
            <ul>
              <li>用 compute engine 和 GKE 来跑应用
                <ul>
                  <li>不建议 App Engine 和 Cloud Function ,因为他们不支持 outbound cloud firewall rule</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>创建 HTTPS 的 Load Balancer, 并绑定SSL 证书</li>
      <li>使用 harden (成熟的, 官方的) Linux Image</li>
      <li>只安装必要软件</li>
      <li>自动化 DevOps, 少人工干预</li>
      <li>用开源软件进行安全管理, 定期升级安全补丁</li>
      <li>开启
        <ul>
          <li>VPC Flow Log</li>
          <li>Access Transparency Logs</li>
          <li>Firewall Rules Logging</li>
          <li>Configure Monitoring Alert</li>
        </ul>
      </li>
      <li>Log 保存到 Cloud Storage, 或 BigQuery 进行分析</li>
      <li>开启 Cloud Data Loss Prevention 权限来限制数据访问</li>
    </ul>
  </li>
</ul>

<h3 id="migration-to-gcp-云迁移和整合">Migration to GCP 云迁移和整合</h3>
<h4 id="云迁移">云迁移</h4>
<ul>
  <li>云迁移的几个阶段
    <ul>
      <li>Phase 1: Assess the workloads to be migrated
        <ul>
          <li>评估要迁移到云上的内容
            <ul>
              <li>对要迁移的应用进行整理和分类</li>
              <li>做一些实验和 POC 验证</li>
              <li>计算迁移成本</li>
              <li>确定要迁移的应用和先后顺序
                <ul>
                  <li>可以基于:
                    <ul>
                      <li>Business value</li>
                      <li>Teams</li>
                      <li>Dependencies</li>
                      <li>Refactoring effort</li>
                      <li>Licensing and compliance needs</li>
                      <li>Availability and reliability requirements</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Phase 2: Plan the foundation
        <ul>
          <li>设置云端环境
            <ul>
              <li>设计 资源org 层级, 配置 IAM, 设计网络拓扑和连接(GCP 内部连接, 云和 on-premise 连接)</li>
              <li>安全, 监控和治理计划</li>
              <li>组建迁移团队</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Phase 3: Deploy the workloads
        <ul>
          <li>迁移应用和数据
            <ul>
              <li>数据迁移
                <ul>
                  <li>评估成本, 时间窗口, 实时和批量迁移, 数据安全</li>
                </ul>
              </li>
              <li>应用部署</li>
              <li>进行自动化
                <ul>
                  <li>Automate configuration management with Ansible, Chef or Puppet</li>
                  <li>Automate build and deployment using Jenkins, SonarQube, Cloud Build or Spinnaker</li>
                  <li>Implement Infrastructure as Code using Terraform or Deployment Manager</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Phase 4: Optimize your environment
        <ul>
          <li>迁移后进行优化
            <ul>
              <li>提供日志, 监控和报警支持</li>
              <li>增加无服务比例</li>
              <li>通过 autoscaling 优化成本</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>几种云迁移方式
    <ul>
      <li>Retaining: 不迁移(保留在 on-premise)</li>
      <li>Retiring: 淘汰掉老旧不用的服务</li>
      <li>Rehosting: 原来应用啥样还啥样, 直接放到云上, 换个环境</li>
      <li>Replatforming: 对原有应用简单调整, 比如进行容器化</li>
      <li>Repurchasing: 对原有应用进行云改造, 比如换个云数据库</li>
      <li>Refactoring: 重构, 不如做成微服务, 无服务</li>
    </ul>
  </li>
  <li>两个云迁移案例
    <ul>
      <li>MS SQL Server 迁移到谷歌云的步骤如下:
        <ul>
          <li>Create a Cloud SQL for SQL Server instance</li>
          <li>Move backup of your database to Cloud Storage</li>
          <li>Import the database into Cloud SQL for SQL Server</li>
          <li>Validate the imported data</li>
        </ul>
      </li>
      <li>容器迁移到谷歌云的几个选项:
        <ul>
          <li>迁移到:
            <ul>
              <li>App Engine flexible environment
                <ul>
                  <li>不能定制底层 VM 环境, 但马上就可以用, 很少的环境管理负担, 可伸缩性强, 但不能缩到零</li>
                </ul>
              </li>
              <li>Cloud Run and Cloud Run for Anthos
                <ul>
                  <li>不能定制环境, 但是可以马上就用, 没有环境管理负担, 可伸缩性强, 可以缩到零</li>
                </ul>
              </li>
              <li>GKE and Anthos clusters
                <ul>
                  <li>比较麻烦, 需要自己配置管理 Cluster, 但是比较灵活, Highly scalable</li>
                </ul>
              </li>
              <li>Compute Engine
                <ul>
                  <li>不推荐, 啥都要自己配置, 太麻烦</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="迁移大量数据的计算">迁移大量数据的计算</h4>

<ul>
  <li>例如 迁移200T的数据， 带宽是100Mbps , 需要多长时间
    <ul>
      <li>按 1Gbps 与 1T 是 3 小时 -&gt; 6000 小时 -&gt; 250 天</li>
    </ul>
  </li>
  <li>数据迁移的时间表</li>
  <li>
    <p><img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-10-092444.jpg" alt="" /></p>
  </li>
  <li>数据迁移的方案选择
    <ol>
      <li>aws 到 GCS 建议用 Storage Transfer Service</li>
      <li>GCS 到 GCS 建议用 Storage Transfer Service</li>
      <li>on-prem 迁到 GCS 带宽够用, 1T 以下的数据迁移 , 用 gsutil</li>
      <li>on-prem 迁到 GCS 带宽够用, 1T 以上的数据迁移 , Storage Transfer Service</li>
      <li>on-prem 迁到 GCS 带宽不够用, 花费时间不满足业务要求, transfer appliance</li>
    </ol>
  </li>
</ul>

<h4 id="cloud-scheduler">Cloud Scheduler</h4>
<ul>
  <li>google cloud 的 cron job</li>
  <li>scheduler 底层是一个 Google App Engine 的 cron 服务</li>
  <li>使用 Unix cron 格式</li>
  <li>自动重试功能</li>
  <li>前提:
    <ul>
      <li>需要先在项目中建立一个 GAE</li>
    </ul>
  </li>
  <li>案例
    <ul>
      <li>scheduler 发送信息到 pub/sub</li>
      <li>GCE 的多个实例从 pub/sub 中读取信息, 然后进行处理</li>
    </ul>
  </li>
</ul>

<h4 id="cloud-emulators">Cloud Emulators</h4>
<ul>
  <li>模拟的开发环境 (sandbox)</li>
  <li>用于在无法连接到 GCP 的时候, 开发人员可以在自己的机器上模拟 GCP 进行应用开发</li>
  <li>支持模拟:
    <ul>
      <li>Cloud Bigtable</li>
      <li>Cloud Datastore/ Firestore</li>
      <li>Cloud Pub Sub</li>
      <li>Cloud Spanner</li>
    </ul>
  </li>
</ul>

<h4 id="managed-service-for-microsoft-active-directory">Managed Service for Microsoft Active Directory</h4>
<ul>
  <li>也是 Active Directory Federation Service (AD FS)</li>
  <li>For single sign-on</li>
  <li>synchronize users and groups from Active Directory to Cloud Identity</li>
  <li>将您的本地 AD 网域连接到云端</li>
</ul>

<h4 id="pricing-calculator">Pricing Calculator</h4>
<ul>
  <li><a href="https://cloud.google.com/products/calculator?hl=zh-cn">价格计算器</a> , 计算 GCP 中不同服务的价格</li>
  <li>支持 40 多种服务</li>
  <li>注意, 这只是计算器, 并没有直接和我们的项目中的已经使用的服务绑定</li>
</ul>

<h3 id="hybrid-and-multi-cloud">Hybrid and Multi-cloud</h3>

<h4 id="anthos">Anthos</h4>
<ul>
  <li>混合多云的集成开发环境</li>
  <li>相当于 OpenShift, 混合多云版本的 GKE (GKE on-prem + GKE on-GCP)
    <ul>
      <li>主要运行 K8S</li>
      <li>既可以在GCP 上管理 K8s, 也可以在 on-premise 上管理 K8s</li>
    </ul>
  </li>
  <li>集中的配置管理 (Git)</li>
  <li>多集群(multi-cluster)管理</li>
  <li>提供 Service Mesh (based on K8s Istio)
    <ul>
      <li></li>
    </ul>
  </li>
  <li>课程提供的解释:
    <ul>
      <li>Run Kubernetes clusters anywhere (cloud and on-premises)</li>
      <li>Config Mgmt - Central policies - Kubernetes API, Service Mesh, Access control</li>
      <li>Service Mesh (dashboards, logging, monitoring, distributed tracing)
        <ul>
          <li>Anthos Service Mesh 是一个工具套装, 用来监控, tracing, logging, 深度了解服务的 performance, 以及 performance 如何影响其他的流程, 发现存在的问题.
            <ul>
              <li>例子: 通过Anthos Service Mesh 监控一个服务的 latency, 超过阈值就报警
                <ol>
                  <li>安装 Anthos Service Mesh</li>
                  <li>在 console 中定义 Service Level Objective(SLO)</li>
                  <li>基于 SLO 创建 alerting policy</li>
                </ol>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>CI/CD - Watch for updates in the Git repository and applies changes to all relevant clusters automatically</li>
    </ul>
  </li>
</ul>

<p><img src="http://dalong-1251052260.cos.ap-shanghai.myqcloud.com/2023-02-08-032734.jpg" alt="" /></p>

<h3 id="api">API</h3>

<h4 id="api-management-tools">API Management Tools</h4>
<ul>
  <li>有多种 API 管理工具, 包含
    <ul>
      <li>Cloud Endpoint</li>
      <li>API Gateway</li>
      <li>APIgee Edge</li>
    </ul>
  </li>
</ul>

<h5 id="cloud-endpoint">Cloud Endpoint</h5>
<ul>
  <li>Cloud API Gateway</li>
  <li>分布式 API 管理系统</li>
  <li>提供 API console, hosting, logging, monitoring, and other features</li>
  <li>可以使用任何支持 API 标准的 API</li>
  <li>可以支持 GCE, GAE, GKE,</li>
  <li>支持的终端
    <ul>
      <li>IOS</li>
      <li>Android</li>
      <li>Javascript
        <h5 id="api-gateway">API Gateway</h5>
      </li>
    </ul>
  </li>
  <li>full namaged API Gateway</li>
  <li>提供定义良好的 Rest API 来包住backend services</li>
</ul>

<h4 id="apigee-edge">Apigee (Edge)</h4>
<ul>
  <li>管理 Rest API 生命周期
    <ul>
      <li>设计</li>
      <li>安全</li>
      <li>发布</li>
      <li>分析</li>
      <li>监控</li>
      <li>scale
        <ul>
          <li>on-premise</li>
          <li>google cloud</li>
          <li>hybrid cloud</li>
        </ul>
      </li>
      <li>caching with Cloud CDN</li>
    </ul>
  </li>
  <li>提供 develoer portals
    <ul>
      <li>方便开发人员 管理 API, 获取 API key</li>
    </ul>
  </li>
  <li>案例:
    <ul>
      <li>为老旧应用抽象出 API 对外服务</li>
      <li>把已有资产进行 API 暴露</li>
      <li>perform business analytics and billing on a customer-facing API
        <ul>
          <li>把商业分析和 Billing 包装成面向客户的 API 暴露出来</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="transcoder-api">Transcoder API</h4>
<ul>
  <li>Optimized files for delivery</li>
  <li>提高 transcoding 的效率</li>
  <li>数据源和目的地都可以是 Cloud Storage</li>
</ul>

<h4 id="video-intelligence-api">Video Intelligence API</h4>
<ul>
  <li>Scene-level video annotation</li>
  <li>实时流媒体的视频智能分析</li>
</ul>

<h3 id="game">Game</h3>
<h4 id="game-server">Game Server</h4>
<ul>
  <li>提供 Agones 集群协调管理服务</li>
  <li>提供无缝的多人游戏体验平台</li>
</ul>

<h3 id="好的架构设计">好的架构设计</h3>
<ul>
  <li>Resiliency: 弹性, 挂了部分, 服务还能用
    <ul>
      <li>用 Cloud Monitoring</li>
      <li>安装 logging agent 发送日志到 Cloud Logging</li>
      <li>给 VM 开 Migrate VM Instance 和 Automatic restart</li>
      <li>健康检查</li>
      <li>用 LB 放在 VM 前面</li>
    </ul>
  </li>
  <li>Availability: 99.99%
    <ul>
      <li>99% 代表 7 小时一个月可以挂</li>
      <li>99.9% 代表43分钟一个月可以挂</li>
      <li>99.99% 代表一个月有 4 分半可以挂</li>
      <li>99.999% 代表一个月有 26 秒可以挂</li>
    </ul>
  </li>
  <li>High Avaibility
    <ul>
      <li>多 region 支持的服务, 一个region 挂了也没事</li>
      <li>用 LB 分配流量</li>
      <li>用 health check 检查出问题的实例, 不在给问题实例分配流量</li>
      <li>给 VM 的 On host maintenance 配置 <strong>Migrate VM Instance</strong>
        <ul>
          <li>当计算引擎执行定期基础架构维护时，它可以将您的 VM 实例迁移到其他服务器(同一个zone的)，而不会停机</li>
          <li>不支持 GPU 类型 和  Pod 类型 的 VM</li>
        </ul>
      </li>
      <li>给 VM 配置 <strong>Automatic restart</strong> (当VM 发生非人为的关闭后, 会自动重启)</li>
    </ul>
  </li>
  <li>Scalability: 伸缩, 随着流量/用户/数据的增减, 可以增减服务器
    <ul>
      <li>横向伸缩: 增加实例个数, 配上 LB + auto scaling
        <ul>
          <li>单zone</li>
          <li>一个region 的多 zone</li>
          <li>多个region 的多 zone</li>
        </ul>
      </li>
      <li>纵向伸缩: 增加单个机器的性能</li>
    </ul>
  </li>
  <li>lower costs: 知道怎么省钱
    <ul>
      <li>Sustained use discount 持续使用的折扣
        <ul>
          <li>VM 用的久且有持续流量, 那么满了一个月, 那么从用量的 25% 开始逐渐打折, 一直到月底打到 7 折</li>
          <li>这个是自动发生的, google 帮我们算.</li>
          <li>只有 GCE 和 GKE 才可以打折</li>
          <li>某些机型, 比如 E2 和 A2 不打折</li>
          <li>通过 App Engine Flexible 和 Dataflow生成的 VM 不打折</li>
        </ul>
      </li>
      <li>Committed use discounts 提前预定好用量的折扣
        <ul>
          <li>预定1-3 年</li>
          <li>最高可以达到 3 折</li>
          <li>某些机型, 比如 E2 和 A2 不打折</li>
          <li>通过 App Engine Flexible 和 Dataflow生成的 VM 不打折</li>
          <li>适用场景: 大量用户的稳定网站.</li>
        </ul>
      </li>
      <li>Spot (preemptible vm) 临时用用的机器
        <ul>
          <li>临时的机器可以用于那种数据不怕丢的计算, 不需要实时进行的计算</li>
          <li>最高可以打到 2 折, 最便宜的一种机型</li>
          <li>可能随时被 google 收回</li>
          <li>有 30 秒的警告</li>
          <li>没有 SLA 保障</li>
          <li>不会自动重启</li>
          <li>300 美金的免费账号用不了</li>
          <li>Preemptible 和 Spot 的区别主要是
            <ul>
              <li>Preemptible 有 24 小时的提前通知</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Billing 账单
        <ul>
          <li>google 是按秒算钱的</li>
          <li>实例停了不算钱, 但它上面的存储会算钱</li>
          <li>最好创建 Budget alert 提醒我们别花超了</li>
        </ul>
      </li>
      <li>网络流量费用
        <ul>
          <li>ingress 免费</li>
          <li>egress
            <ul>
              <li>egress 到 google 服务免费 (youtue, map )</li>
              <li>同一个 region 之间的谷歌服务 egress 免费</li>
              <li>不同 region 之间 egress 付费</li>
              <li></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>安全
    <ul>
      <li>使用 Firewall Rules</li>
      <li>尽量用内部 IP 地址</li>
      <li>如果有合规要求, 用 Sole-tenant nodes</li>
      <li>使用自己做的 custom image 来生成 VM</li>
      <li></li>
    </ul>
  </li>
</ul>

<h3 id="架构师要知道的东西">架构师要知道的东西</h3>
<ul>
  <li>业务需求
    <ul>
      <li>降低成本
        <ul>
          <li>managed service</li>
          <li>autoscaling</li>
          <li>premptible vms</li>
          <li>总成本(TCO - total cost of ownership)来源:
            <ul>
              <li>licensing cost (软硬件)</li>
              <li>计算服务成本</li>
              <li>存储成本</li>
              <li>网络成本(线路成本, 数据的 ingress, egress)</li>
              <li>人员成本(开发, 测试, 运维, 业务)</li>
              <li>其他
                <ul>
                  <li>事故成本</li>
                  <li>第三方API 等</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>CAPEX，全称为Capital Expenditure，即资本性支出, 如果在  GCP, 那就是采购云的一次性支出</li>
          <li>OPEX，全称为Operating Expense，指的是企业的管理支出, 如果在 GCP 那就是持续的订阅支出</li>
        </ul>
      </li>
      <li>加快开发/创新速度
        <ul>
          <li>devops(CI/CD) SRE</li>
          <li>微服务?</li>
        </ul>
      </li>
      <li>合规</li>
      <li>应用和架构透明</li>
      <li>数据智能</li>
    </ul>
  </li>
  <li>技术需求
    <ul>
      <li>功能性需求, 比如技术部门要求:
        <ul>
          <li>容器化</li>
          <li>linux</li>
          <li>容器协调</li>
          <li>自动scaling</li>
          <li>NoSQL</li>
          <li>大量数据存储, 且低成本</li>
        </ul>
      </li>
      <li>非功能性需求
        <ul>
          <li>High Availability
            <ul>
              <li>Compute Engine
                <ul>
                  <li>MIG, AutoScaling, Health Checks (Auto healing), GLB, Global &gt; Multi-Regional &gt; Regional &gt; Zonal</li>
                </ul>
              </li>
              <li>GKE
                <ul>
                  <li>Multi master, Regional clusters with pod and cluster autoscaling</li>
                </ul>
              </li>
              <li>Bigtable
                <ul>
                  <li>Place clusters in different zones or regions</li>
                </ul>
              </li>
              <li>Cloud Firestore/Datestore
                <ul>
                  <li>Use Multi-region locations</li>
                </ul>
              </li>
              <li>Cloud SQL
                <ul>
                  <li>Use HA configuration (regional)</li>
                  <li>read replica 不能作为 HA</li>
                </ul>
              </li>
              <li>网络连接
                <ul>
                  <li>Dedicated interconnect &gt; Partner interconnect &gt; VPN Have a backup connection.</li>
                </ul>
              </li>
              <li>Managed Services - like App Engine, Cloud Functions, Cloud Storage, Cloud Firestore/Datastore, BigQuery</li>
            </ul>
          </li>
          <li>Scalability
            <ul>
              <li>CE
                <ul>
                  <li>用 MIG 和 template + LB</li>
                  <li>UMIG 不能自动伸缩</li>
                </ul>
              </li>
              <li>GKE
                <ul>
                  <li>用 pod 和 cluster 自动伸缩</li>
                </ul>
              </li>
              <li>persistent disk
                <ul>
                  <li>可以伸缩, 比如增加硬盘大小, 增加硬盘数量</li>
                </ul>
              </li>
              <li>local SSD
                <ul>
                  <li>不能自动伸缩</li>
                </ul>
              </li>
              <li>无服务
                <ul>
                  <li>Cloud Storage, App Engine and Cloud Functions are serverless (Auto Scaling)</li>
                </ul>
              </li>
              <li>数据库
                <ul>
                  <li>Pub/Sub, BigQuery and Cloud Datastore are serverless (Auto Scaling)</li>
                  <li>BigTable, Cloud Spanner, Cloud SQL, Dataproc are NOT serverless ,</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Durability</li>
          <li>Security
            <ul>
              <li>Cloud KMS
                <ul>
                  <li>对 传输的数据或者 at rest 数据进行加密</li>
                  <li>公钥私钥</li>
                </ul>
              </li>
              <li><strong>Cloud Armor</strong>
                <ul>
                  <li>是一个网络攻击解决方案库, 收集每年的 OWASP Top 10 attacks, 并提供保护机制</li>
                </ul>
              </li>
              <li>Secret Manager
                <ul>
                  <li>存放数据库密码, API key credentials</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="谷歌云-architecture-framework">谷歌云 Architecture Framework</h3>
<ul>
  <li>有四个原则
    <ul>
      <li>运营完美
        <ul>
          <li>高效的运行, 管理和监控交付的商业价值</li>
          <li>策略
            <ul>
              <li>自动 build, 测试和部署</li>
              <li>监控商业指标</li>
              <li>执行灾难恢复测试</li>
            </ul>
          </li>
          <li>增加软件开发和发布的速度
            <ul>
              <li>小而快的发布</li>
              <li>对静态代码分析和安全扫描</li>
              <li>使用
                <ul>
                  <li>Cloud Source Repositories</li>
                  <li>Container Registry</li>
                  <li>Cloud Build</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>监控系统和业务健康度
            <ul>
              <li>监控和日志
                <ul>
                  <li>Cloud Monitoring</li>
                  <li>Cloud Logging</li>
                  <li>Cloud Debugger</li>
                  <li>Error Reporting</li>
                  <li>Cloud Trace</li>
                  <li>Cloud Profiler</li>
                </ul>
              </li>
              <li>SLI, SLO, SLA</li>
            </ul>
          </li>
          <li>灾难恢复 Dister Recovery
            <ul>
              <li>创建 DR 恢复方案</li>
              <li>定义 RTO, RPO</li>
              <li>考虑 网络, 计算, 数据, 带宽, infra</li>
              <li>定期进行灾难测试</li>
              <li>DNS 来切换 primary 和 backup</li>
              <li>定期对 VM 的持久磁盘进行snapshot 并拷贝到其他region</li>
              <li>开启 Live Migration, 确保 VM 在维护的时候也能正常提供服务</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>安全, 隐私和合规
        <ul>
          <li>对安全控制, 隐私, 进行计划,确保合规</li>
          <li>策略
            <ul>
              <li>仅提供最小的权限</li>
              <li>自动部署敏感任务</li>
              <li>进行安全监控</li>
            </ul>
          </li>
          <li>Authentication and authorization
            <ul>
              <li>IAM policy
                <ul>
                  <li>提供必要的role 给用户</li>
                  <li>使用 Org Policy Service (组织都允许什么)</li>
                  <li>使用 <strong>Cloud Asset Inventory</strong> (跟踪资产目录)</li>
                  <li>使用 Cloud Audit Logs (audit IAM Policy 变化 和 Service Accounts)</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>计算安全控制
            <ul>
              <li>尽量使用私有 IP (避免外网访问)</li>
              <li>使用 harden VM image (没有乱七八糟的软件)</li>
              <li>使用 Shielded VM (避免远程攻击, privilege escalation, and malicious insiders)</li>
              <li>开启 GKE 集群 的 Node 自动 upgrade</li>
            </ul>
          </li>
          <li>网络安全
            <ul>
              <li>用 custom VPC (不要用default VPC)</li>
              <li>每个 project 对应一个 VPC (相互隔绝)</li>
              <li>使用 firewall rules 控制进出的流量</li>
              <li>用 <strong>Security Command Center</strong> 分析 infra 的安全</li>
              <li>用 <strong>Network Intelligence Center</strong> 检查网络拓扑和架构</li>
            </ul>
          </li>
          <li>数据安全
            <ul>
              <li>谷歌云默认会把存放在云上的数据进行加密</li>
              <li>Cloud Storage
                <ul>
                  <li>给 bucket 使用版本 (敏感数据)</li>
                  <li>bucket 中数据进行生命周期管理, 可以降低成本</li>
                  <li>合规的数据可以用 Bucket Lock</li>
                  <li>临时对外提供的数据用 Signed URLs</li>
                </ul>
              </li>
              <li>使用其他数据类服务, 用 audit log</li>
              <li>开启 Access Transparency Logs</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>可靠性
        <ul>
          <li>设计可伸缩, 高可用, Self-healing(自动修复)的架构</li>
          <li>定义 SLI, SLO, SLA 和 Error budget</li>
          <li>监控和日志
            <ul>
              <li>Monitoring, logging, tracing, profiling, debugging etc.</li>
            </ul>
          </li>
          <li>设计高可用和伸缩
            <ul>
              <li>设计跨region 架构来实现 failover</li>
              <li>尽量 横向 scale</li>
              <li>预测高峰流量, 并进行提前计划</li>
            </ul>
          </li>
          <li>事故管理
            <ul>
              <li>减少 mean time to detect (MTTD 平均故障发现时间): 及时通知团队</li>
              <li>减少 Mean Time to Mitigate (MTTM 平均故障缓和时间): 临时措施</li>
              <li>减少 Mean Time to Recovery (MTTR 平均故障修复时间): 彻底修复</li>
              <li>延长两次故障间隔时间 Mean Time Between Failures (MTBF): build 可靠系统</li>
              <li>记录故障原因和修复记录, 以及lessons learn</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>性能和成本优化
        <ul>
          <li>Use GPUs and TPUs 增加性能
            <ul>
              <li>GPU 用来提高 ML, 视觉的性能</li>
              <li>TPU 用硬件加速 ML</li>
            </ul>
          </li>
          <li>尽量使用无服务, managed service
            <ul>
              <li>Cloud Run, App Engine, Cloud Functions, Dataproc and Dataflow</li>
            </ul>
          </li>
          <li>分析成本和优化
            <ul>
              <li>Cloud Billing 看账单, 导出账单
                <ul>
                  <li>BigQuery 可以分析账单</li>
                  <li>Google Data Studio 对账单视觉化</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>几种打折
            <ul>
              <li>Sustained use discounts (长时间使用的打折)</li>
              <li>Committed use discounts (预定时长的打折)</li>
              <li>Preemptible VMs (用临时vm 运行不重要的工作任务, 可以打折)</li>
              <li>用 Cloud Storage Lifecycle 管理数据, 节省成本</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="managed-service--serverless-无服务">Managed service / Serverless 无服务</h3>
<ul>
  <li>一些名词
    <ul>
      <li>IaaS (Infrastructure as a Service)
        <ul>
          <li>比如: Compute Engine</li>
        </ul>
      </li>
      <li>PaaS (Platform as a Service)
        <ul>
          <li>比如: App Engine
            <ul>
              <li>是serverless</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>FaaS (Function as a Service)
        <ul>
          <li>比如: Cloud Function
            <ul>
              <li>是serverless</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>CaaS (Container as a Service) Serverless
        <ul>
          <li>比如: GKE, Cloud Run
            <ul>
              <li>GKE 也有 serverless</li>
              <li>Cloud Run是serverless</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>无服务
    <ul>
      <li>不需要自己去设置 VM, LB, Disk 的服务</li>
      <li>不需要自己在虚机上安装相关的软件</li>
      <li>上来就能用.</li>
      <li>VM , LB, Disk 对用户都是透明的</li>
      <li>默认提供了 auto scalling, HA</li>
      <li>一般是付钱就能用, 按请求数, 用多少付多少</li>
      <li>比如:
        <ul>
          <li>AWS 的 Lambda</li>
          <li>GCP 的 function</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Serverless NEG (network endpoint groups)
    <ul>
      <li>一个 NEG 定义了 一组 backend endpoints for a load balancer.</li>
      <li>A serverless NEG is a backend that points to a Cloud Run, App Engine, Cloud Functions, or API Gateway service.</li>
      <li>一个 NEG 可以代表
        <ul>
          <li>1 个或者一组 Cloud Run 服务</li>
          <li>1 个或者一组 Cloud Function 服务</li>
          <li>1 个或者一组 App Engine 服务</li>
          <li>1 个或者一组 API Gateway 服务</li>
        </ul>
      </li>
      <li>NEG 前面放一个 LB</li>
      <li>可以把  NEG 比作 无服务版本的 MIG</li>
    </ul>
  </li>
  <li>Serverless VPC Access
    <ol>
      <li>Serverless VPC Access 是一个私有访问选项, 允许你通过一个 internal IP 让一个 无服务(serverless) 连接到 VPC 网络.</li>
      <li>VPN tunnel 连接的on-premise 环境(包含的database) 也算是 VPC 网络, 让 Serverless 服务访问 on-premise 的服务(比如数据库)</li>
    </ol>
  </li>
</ul>

<h3 id="workesapce">Workesapce</h3>
<ul>
  <li>为使用 GCP 的组织和组织的员工提供便利的服务</li>
  <li>比如, 日历, 文档, 邮件等.</li>
  <li>方便组织的开发人员/员工可以远程高效开发/办公</li>
  <li>workspace 里面的应用都是SaaS 的服务</li>
</ul>

<h2 id="命令行工具---cloud-shell-gcloud">命令行工具 - Cloud Shell (GCloud)</h2>
<ul>
  <li>谷歌云提供四种方式和云进行交互
    <ul>
      <li>Web Console/ Mobile Console/ Admin console</li>
      <li>CLI</li>
      <li>API</li>
      <li>SDK</li>
    </ul>
  </li>
  <li>cloud shell 是 google 默认给我们提供的一个虚机
    <ul>
      <li>5G 默认 磁盘 放在 $HOME 目录</li>
      <li>我们自己在目录下创建的的文件只在 访问的 session 期间存在</li>
      <li>20 分钟不用 shell, 会就被自动terminate 掉</li>
      <li>120 天不活跃, 目录可能都被删了</li>
      <li>可以在这个shell 上通过 SSH 登录其他的 VM</li>
    </ul>
  </li>
  <li>通过命令行工具可以和管理谷歌云的服务
    <ul>
      <li>create</li>
      <li>delete</li>
      <li>update</li>
      <li>read</li>
    </ul>
  </li>
  <li>有一些谷歌云服务有特别的命令行
    <ul>
      <li>Cloud Storage - gsutil</li>
      <li>Cloud BigQuery - bq</li>
      <li>Cloud Bigtable - cbt</li>
      <li>Kubernetes - kubectl (in addition to Gcloud which is used to manage clusters)</li>
    </ul>
  </li>
  <li>使用方法
    <ul>
      <li>Mac 上 安装 Gcloud SDK</li>
      <li>网页上用 Cloud Shell</li>
    </ul>
  </li>
  <li>官方<a href="https://cloud.google.com/sdk/docs/cheatsheet">中文介绍以及相关命令</a></li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre>gcloud init  <span class="c"># 初始化 gcloud, 包括允许 gcloud 使用我的账号认证信息, 并设置 configuration</span>
gcloud config list  <span class="c"># 列出我的账号的可配置参数</span>
gcloud compute instances list 

<span class="c">## 语法</span>
<span class="c">## gcloud 组 子组 动作 ...</span>

gcloud compute zones list
gcloud compute regions list
gcloud compute machine-types list
gcloud compute machine-types list --filter<span class="o">=</span><span class="s2">"zone:us-central1-b"</span>
gcloud compute machine-types list --filter<span class="o">=</span><span class="s2">"zone:( us-central1-b europe-west1-d )"</span>

</pre></td></tr></tbody></table>
</div>
</div>

            </div>

            <!-- Rating -->
            
            <div class="rating mb-4 d-flex align-items-center">
                <strong class="mr-1">Rating:</strong> <div class="rating-holder">
<div class="c-rating c-rating--regular" data-rating-value="4.5">
  <button>1</button>
  <button>2</button>
  <button>3</button>
  <button>4</button>
  <button>5</button>
</div>
</div>
            </div>
            

            <!-- Post Date -->
            <p>
            <small>
                <span class="post-date"><time class="post-date" datetime="2023-02-23">23 Feb 2023</time></span>           
                
                </small>
            </p>

            <!-- Post Categories -->
            <div class="after-post-cats">
                <ul class="tags mb-4">
                    
                    
                    <li>
                        <a class="smoothscroll" href="/categories#Agile">Agile</a>
                    </li>
                    
                    <li>
                        <a class="smoothscroll" href="/categories#Scrum">Scrum</a>
                    </li>
                    
                </ul>
            </div>
            <!-- End Categories -->

            <!-- Post Tags -->
            <div class="after-post-tags">
                <ul class="tags">
                    
                    
                </ul>
            </div>
            <!-- End Tags -->

            <!-- Prev/Next -->
            <div class="row PageNavigation d-flex justify-content-between font-weight-bold">
            
            <a class="prev d-block col-md-6" href="//Agile-Project-Management-and-Agile-Delivery/"> &laquo; Agile Project Management and Agile Delivery</a>
            
            
            <a class="next d-block col-md-6 text-lg-right" href="//%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">Interpretation of New China MLPS 2.0 &raquo; </a>
            
            <div class="clearfix"></div>
            </div>
            <!-- End Categories -->

        </div>
        <!-- End Post -->

    </div>
</div>
<!-- End Article
================================================== -->

<!-- Begin Comments
================================================== -->

    <div class="container">
        <div id="comments" class="row justify-content-center mb-5">
            <div class="col-md-8">
                <section class="disqus">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'demowebsite'; 
        var disqus_developer = 0;
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = window.location.protocol + '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>

            </div>
        </div>
    </div>

<!--End Comments
================================================== -->

<!-- Review with LD-JSON, adapt it for your needs if you like, but make sure you test the generated HTML source code first: 
https://search.google.com/structured-data/testing-tool/u/0/
================================================== -->

<script type="application/ld+json">
{
  "@context": "http://schema.org/",
  "@type": "Review",
  "itemReviewed": {
    "@type": "Thing",
    "name": "Prepare for Google CLoud Platform Professional Architect Certification"
  },
  "author": {
    "@type": "Person",
    "name": "Dalong"
  },
  "datePublished": "2023-02-23",
  "reviewRating": {
    "@type": "Rating",
    "ratingValue": "4.5",
    "bestRating": "5"
  }
}
</script>

</div>


    
</div>

<!-- Categories Jumbotron
================================================== -->
<div class="jumbotron fortags">
	<div class="d-md-flex h-100">
		<div class="col-md-4 transpdark align-self-center text-center h-100">
            <div class="d-md-flex align-items-center justify-content-center h-100">
                <h2 class="d-md-block align-self-center py-1 font-weight-light">Explore <span class="d-none d-md-inline">→</span></h2>
            </div>
		</div>
		<div class="col-md-8 p-5 align-self-center text-center">
            
            
                
                    <a class="mt-1 mb-1" href="/categories#Linux">Linux (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Python">Python (16)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Mysql">Mysql (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Redis">Redis (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#MongoDB">MongoDB (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Flask">Flask (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Django">Django (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#DjangoRest">DjangoRest (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Numpy">Numpy (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Panda">Panda (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Sklearn">Sklearn (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Jupyter">Jupyter (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#OpenCV">OpenCV (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#AI">AI (3)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Tensorflow">Tensorflow (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Microservice">Microservice (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Docker">Docker (3)</a>
                
                    <a class="mt-1 mb-1" href="/categories#NLP">NLP (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#AWS">AWS (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Architecture">Architecture (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Agile">Agile (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Scrum">Scrum (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#MLPS">MLPS (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#PIPL">PIPL (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Metaverse">Metaverse (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Togaf">Togaf (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#ChatGPT">ChatGPT (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#OpenAI">OpenAI (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#LLM">LLM (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Azure">Azure (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Data-Science">Data Science (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#ITIL">ITIL (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#IT">IT (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Jekyll">Jekyll (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Github">Github (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Liquid">Liquid (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Markdown">Markdown (1)</a>
                
            
            
		</div>
	</div>
</div>

<!-- Begin Footer
================================================== -->
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                Copyright © 2023 Dalong's personal blog 
            </div>
            <div class="col-md-6 col-sm-6 text-center text-lg-right">    
                <a target="_blank" href="#">Designed</a> by Dalong.work
            </div>
        </div>
    </div>
</footer>
<!-- End Footer
================================================== -->

</div> <!-- /.site-content -->

<!-- Scripts
================================================== -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>

<script src="/assets/js/mediumish.js"></script>



<script src="/assets/js/ie10-viewport-bug-workaround.js"></script> 


<script id="dsq-count-scr" src="//demowebsite.disqus.com/count.js"></script>


</body>
</html>
