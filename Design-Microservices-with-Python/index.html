<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<link rel="icon" href="/assets/images/logo.png">

<title>Design Microservices with Python | Dalong's personal blog</title>

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Design Microservices with Python | Dalong’s personal blog</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Design Microservices with Python" />
<meta name="author" content="Dalong" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="微服务架构是一种软件设计方法，将大型应用程序分解为独立服务，每项服务都旨在满足特定的业务需求。这些服务在专用资源上运行，包括单独的数据库实例和计算能力。与整体系统不同，微服务应用程序是松散耦合的，允许更大的灵活性。本文我将带领大家深入浅出的了解微服务框架以及通过 Python 来实现一些案例." />
<meta property="og:description" content="微服务架构是一种软件设计方法，将大型应用程序分解为独立服务，每项服务都旨在满足特定的业务需求。这些服务在专用资源上运行，包括单独的数据库实例和计算能力。与整体系统不同，微服务应用程序是松散耦合的，允许更大的灵活性。本文我将带领大家深入浅出的了解微服务框架以及通过 Python 来实现一些案例." />
<link rel="canonical" href="http://localhost:4000/Design-Microservices-with-Python/" />
<meta property="og:url" content="http://localhost:4000/Design-Microservices-with-Python/" />
<meta property="og:site_name" content="Dalong’s personal blog" />
<meta property="og:image" content="http://localhost:4000/assets/images/microservices.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-03-14T00:00:00+08:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Design Microservices with Python","dateModified":"2021-03-14T00:00:00+08:00","datePublished":"2021-03-14T00:00:00+08:00","description":"微服务架构是一种软件设计方法，将大型应用程序分解为独立服务，每项服务都旨在满足特定的业务需求。这些服务在专用资源上运行，包括单独的数据库实例和计算能力。与整体系统不同，微服务应用程序是松散耦合的，允许更大的灵活性。本文我将带领大家深入浅出的了解微服务框架以及通过 Python 来实现一些案例.","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/images/logo.png"},"name":"Dalong"},"image":"http://localhost:4000/assets/images/microservices.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Design-Microservices-with-Python/"},"url":"http://localhost:4000/Design-Microservices-with-Python/","author":{"@type":"Person","name":"Dalong"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    
<link href="/assets/css/screen.css" rel="stylesheet">

<link href="/assets/css/main.css" rel="stylesheet">

<script src="/assets/js/jquery.min.js"></script>

</head>




<body class="layout-post">
	<!-- defer loading of font and font awesome -->
	<noscript id="deferred-styles">
		<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
        <link rel="preconnect" href="https://fonts.googleapis.com"> 
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
        <link href="https://fonts.googleapis.com/css2?family=Carter+One&display=swap" rel="stylesheet">
    </noscript>


<!-- Begin Menu Navigation
================================================== -->
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">

    <div class="container pr-0">

    <!-- Begin Logo -->
    <a class="navbar-brand" href="/">
    <img src="/assets/images/logo.png" alt="Dalong's personal blog">
    </a>
    <!-- End Logo -->

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarMediumish">

        <!-- Begin Menu -->

            <ul class="navbar-nav ml-auto">

                
                <li class="nav-item">
                
                <a class="nav-link" href="/index.html">Blog</a>
                </li>

                <li class="nav-item">
                <a class="nav-link" href="/about">About</a>
                </li>

<!-- 以后再加上相关链接

                <li class="nav-item">
                <a target="_blank" class="nav-link" href="https://bootstrapstarter.com/bootstrap-templates/template-mediumish-bootstrap-jekyll/"> Docs</a>
                </li>

                <li class="nav-item">
                <a target="_blank" class="nav-link" href="https://www.wowthemes.net/themes/mediumish-wordpress/"><i class="fab fa-wordpress-simple"></i> WP Version</a>
                </li>

                <li class="nav-item">
                <a target="_blank" class="nav-link" href="https://www.wowthemes.net/themes/mediumish-ghost/"><i class="fab fa-snapchat-ghost"></i> Ghost Version</a>
                </li>
-->
                <li class="nav-item">
                <a target="_blank" class="nav-link" href="https://github.com/dalongli"><i class="fab fa-github"></i> Fork on Github</a>
                </li>

                <script src="/assets/js/lunr.js"></script>


<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>


<form class="bd-search" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
    <input type="text" class="form-control text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Type and enter..."/>
</form>

<div id="lunrsearchresults">
    <ul></ul>
</div>

<script src="/assets/js/lunrsearchengine.js"></script>

            </ul>

        <!-- End Menu -->

    </div>

    </div>
</nav>
<!-- End Navigation
================================================== -->

<div class="site-content">

<div class="container">

<!-- Site Title
================================================== -->
<div class="mainheading">
    <h1 class="sitetitle">Dalong's personal blog</h1>
    <p class="lead">
        Record the bits and pieces of the technology big bang.
    </p>
</div>

<!-- Content
================================================== -->
<div class="main-content">
    <!-- Begin Article
================================================== -->
<div class="container">
    <div class="row">

        <!-- Post Share -->
        <div class="col-md-2 pl-0">
            <div class="share sticky-top sticky-top-offset">
    <p>
        Share
    </p>
    <ul>
        <li class="ml-1 mr-1">
            <a target="_blank" href="https://twitter.com/intent/tweet?text=Design Microservices with Python&url=http://localhost:4000/Design-Microservices-with-Python/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                <i class="fab fa-twitter"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://facebook.com/sharer.php?u=http://localhost:4000/Design-Microservices-with-Python/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=435');return false;">
                <i class="fab fa-facebook-f"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/Design-Microservices-with-Python/" onclick="window.open(this.href, 'width=550,height=435');return false;">
                <i class="fab fa-linkedin-in"></i>
            </a>
        </li>

    </ul>
    
    <div class="sep">
    </div>
    <ul>
        <li>
        <a class="small smoothscroll" href="#disqus_thread"></a>
        </li>
    </ul>
    
</div>

        </div>

        <!-- Post -->
        

        <div class="col-md-9 flex-first flex-md-unordered">
            <div class="mainheading">

                <!-- Author Box -->
                
                <div class="row post-top-meta">
                    <div class="col-xs-12 col-md-3 col-lg-2 text-center text-md-left mb-4 mb-md-0">
                        
                        <img class="author-thumb" src="/assets/images/avatar_dl.png" alt="Dalong">
                        
                    </div>
                    <div class="col-xs-12 col-md-9 col-lg-10 text-center text-md-left">
                        <a target="_blank" class="link-dark" href="https://dalongli.github.io/about">Dalong</a><a target="_blank" href="https://dalongli.github.io." class="btn follow">Follow</a>
                        <span class="author-description">A profesional technical consultant and blogger.</span>
                    </div>
                </div>
                

                <!-- Post Title -->
                <h1 class="posttitle">Design Microservices with Python</h1>

            </div>

            <!-- Adsense if enabled from _config.yml (change your pub id and slot) -->
            
            <!-- End Adsense -->

            <!-- Post Featured Image -->
            

            
            <img class="featured-image img-fluid" src="/assets/images/microservices.jpg" alt="Design Microservices with Python">
            

            
            <!-- End Featured Image -->

            <!-- Post Content -->
            <div class="article-post">
                <!-- Toc if any -->
                
                    
                    <div class="toc mt-4 mb-4 lead">
                        <h3 class="font-weight-bold">Summary</h3>
                        <ul>
  <li><a href="#微服务介绍">微服务介绍</a>
    <ul>
      <li><a href="#概念">概念:</a></li>
      <li><a href="#优缺点">优缺点:</a>
        <ul>
          <li><a href="#好处">好处:</a></li>
          <li><a href="#缺点">缺点:</a></li>
        </ul>
      </li>
      <li><a href="#架构师的战略目标原则和实践">架构师的战略目标,原则和实践</a></li>
      <li><a href="#如何建模微服务">如何建模微服务</a>
        <ul>
          <li><a href="#好的服务-松耦合-高内聚">好的服务, 松耦合, 高内聚</a></li>
          <li><a href="#限界上下文">限界上下文</a></li>
        </ul>
      </li>
      <li><a href="#集成">集成</a>
        <ul>
          <li><a href="#理想的集成技术">理想的集成技术</a></li>
          <li><a href="#为微服务创建接口">为微服务创建接口</a></li>
          <li><a href="#共享数据库">共享数据库</a></li>
          <li><a href="#微服务的同步与异步">微服务的同步与异步</a></li>
          <li><a href="#rest">REST</a></li>
          <li><a href="#json--xml-还是其他">JSON , XML 还是其他</a></li>
          <li><a href="#版本管理">版本管理</a></li>
          <li><a href="#为前端提供服务的后端">为前端提供服务的后端</a></li>
        </ul>
      </li>
      <li><a href="#分解单块系统">分解单块系统</a>
        <ul>
          <li><a href="#分解上下文">分解上下文</a></li>
          <li><a href="#分解的原则">分解的原则:</a></li>
          <li><a href="#打破外键">打破外键</a></li>
          <li><a href="#共享静态数据">共享静态数据</a></li>
          <li><a href="#重构数据库">重构数据库</a></li>
          <li><a href="#事物边界">事物边界</a></li>
          <li><a href="#生成报告">生成报告</a></li>
        </ul>
      </li>
      <li><a href="#部署">部署</a>
        <ul>
          <li><a href="#持续集成-ci">持续集成 CI</a></li>
          <li><a href="#把持续集成映射到微服务">把持续集成映射到微服务</a></li>
          <li><a href="#构建流水线和持续交付">构建流水线和持续交付</a></li>
          <li><a href="#特定构建物">特定构建物</a></li>
          <li><a href="#微服务和主机之间的映射">微服务和主机之间的映射</a></li>
          <li><a href="#虚拟化容器化">虚拟化,容器化</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#用python-开发-微服务">用Python 开发 微服务</a>
    <ul>
      <li><a href="#微服务用到的python扩展">微服务用到的Python扩展</a></li>
      <li><a href="#网络请求用到的相关技术">网络请求用到的相关技术</a>
        <ul>
          <li><a href="#异步网络框架-twisted-and-tornado">异步网络框架 Twisted and Tornado</a></li>
          <li><a href="#多任务协程请求-greenlet-and-gevent">多任务协程请求: Greenlet and Gevent</a></li>
          <li><a href="#高并发模块-asyncio--python3">高并发模块 asyncio  (python3)</a></li>
        </ul>
      </li>
      <li><a href="#flask-的使用">Flask 的使用</a>
        <ul>
          <li><a href="#flask处理网络请求">Flask处理网络请求</a></li>
          <li><a href="#服务之间的调用">服务之间的调用</a>
            <ul>
              <li><a href="#同步请求">同步请求</a></li>
              <li><a href="#异步请求">异步请求</a></li>
            </ul>
          </li>
          <li><a href="#发布和订阅">发布和订阅</a></li>
          <li><a href="#测试请求--模拟调用">测试请求 – 模拟调用</a></li>
        </ul>
      </li>
      <li><a href="#监控微服务">监控微服务</a>
        <ul>
          <li><a href="#日志管理">日志管理</a></li>
          <li><a href="#监控管理">监控管理</a>
            <ul>
              <li><a href="#系统级别监控">系统级别监控</a></li>
              <li><a href="#代码级别监控">代码级别监控</a></li>
              <li><a href="#web-server-级别监控">web server 级别监控</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#微服务安全">微服务安全</a>
        <ul>
          <li><a href="#oauth2-认证">OAuth2 认证</a></li>
          <li><a href="#ccg---基于token的认证">CCG - 基于Token的认证</a></li>
          <li><a href="#jwt-标准">JWT 标准</a>
            <ul>
              <li><a href="#pyjwt-可以轻松的创建jwt-token-并读取jwt-token">PyJWT 可以轻松的创建JWT token 并读取JWT token.</a></li>
            </ul>
          </li>
          <li><a href="#基于-x509-证书的认证">基于 X.509 证书的认证</a></li>
          <li><a href="#tokendealer-的微服务代码案例">TokenDealer 的微服务代码案例</a></li>
          <li><a href="#web防火墙">Web防火墙</a>
            <ul>
              <li><a href="#openresty---lua--nginx-实现-waf">OpenResty - Lua + Nginx 实现 WAF</a></li>
            </ul>
          </li>
          <li><a href="#代码安全">代码安全</a>
            <ul>
              <li><a href="#判断进来的数据">判断进来的数据</a></li>
              <li><a href="#限制应用的执行范围">限制应用的执行范围</a></li>
              <li><a href="#使用bandit-linter-进行代码扫描">使用Bandit linter 进行代码扫描</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#打包-运行微服务">打包， 运行微服务</a>
        <ul>
          <li><a href="#打包工具链">打包工具链</a>
            <ul>
              <li><a href="#打包用的配置文件">打包用的配置文件</a>
                <ul>
                  <li><a href="#setuppy">setup.py</a></li>
                  <li><a href="#requirementstxt-文件">requirements.txt 文件</a></li>
                  <li><a href="#manifestin-文件">MANIFEST.in 文件</a></li>
                </ul>
              </li>
              <li><a href="#版本管理-1">版本管理</a></li>
              <li><a href="#打包命令">打包命令</a></li>
            </ul>
          </li>
          <li><a href="#distributing-部署">Distributing 部署</a></li>
          <li><a href="#运行所有的微服务">运行所有的微服务</a>
            <ul>
              <li><a href="#argparse-模块创建自己的启动服务的命令行">argparse 模块创建自己的启动服务的命令行</a></li>
            </ul>
          </li>
          <li><a href="#多进程管理">多进程管理</a>
            <ul>
              <li><a href="#安装-uwsgi">安装 uWSGI</a></li>
              <li><a href="#安装circus">安装Circus</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#容器---将微服务放在容器中">容器 - 将微服务放在容器中</a>
        <ul>
          <li><a href="#什么是docker">什么是Docker</a></li>
          <li><a href="#docker-101">Docker 101</a></li>
          <li><a href="#为docker安装全套环境---openresty-circus-and-flask">为Docker安装全套环境 - OpenResty, Circus and Flask</a></li>
          <li><a href="#部署docker">部署Docker</a>
            <ul>
              <li><a href="#docker-compose">Docker Compose</a></li>
              <li><a href="#docker-的clustering-and-provisioning服务发现">Docker 的clustering and Provisioning（服务发现）</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#在-aws-上部署微服务">在 AWS 上部署微服务</a>
        <ul>
          <li><a href="#routing---route53-elb-autoscaling">Routing - Route53, ELB, AutoScaling</a></li>
          <li><a href="#execution---ec2-and-lambda">Execution - EC2 and Lambda</a></li>
          <li><a href="#storage---ebs-s3-rds-elasticcache-and-cloudfront">Storage - EBS, S3, RDS, ElasticCache, and CloudFront</a></li>
          <li><a href="#messaging---ses-sqs-and-sns">Messaging - SES, SQS, and SNS</a></li>
          <li><a href="#微服务的部署--实践">微服务的部署- 实践</a></li>
        </ul>
      </li>
      <li><a href="#在阿里云上部署微服务">在阿里云上部署微服务</a></li>
    </ul>
  </li>
  <li><a href="#对微服务api服务网关的理解">对微服务API服务网关的理解</a>
    <ul>
      <li><a href="#1-简介">1. 简介</a></li>
      <li><a href="#2-什么是api网关">2. 什么是API网关</a></li>
      <li><a href="#3-为什么需要api网关">3. 为什么需要API网关</a></li>
      <li><a href="#4-api网关在微服务架构体系中处于什么位置">4. API网关在微服务架构体系中处于什么位置</a>
        <ul>
          <li><a href="#41-调用者眼中的api网关">4.1 调用者眼中的API网关</a></li>
          <li><a href="#42-所处的位置">4.2 所处的位置</a></li>
        </ul>
      </li>
      <li><a href="#5-网关技术实现有哪些">5. 网关技术实现有哪些</a></li>
      <li><a href="#6-zuul网关工作原理是什么样的">6. zuul网关工作原理是什么样的</a>
        <ul>
          <li><a href="#61-整体处理流程图">6.1 整体处理流程图</a></li>
          <li><a href="#62-请求生命周期">6.2 请求生命周期</a></li>
        </ul>
      </li>
      <li><a href="#7-技术上如何选型">7. 技术上如何选型</a></li>
    </ul>
  </li>
  <li><a href="#对微服务路由发现体系的理解">对微服务路由发现体系的理解</a>
    <ul>
      <li><a href="#简介">简介</a></li>
      <li><a href="#1什么是微服务路由">1.什么是微服务路由</a></li>
      <li><a href="#2微服务为什么需要路由">2.微服务为什么需要路由</a></li>
      <li><a href="#3从路由的角度看微服务的体系架构是什么样的">3.从路由的角度看微服务的体系架构是什么样的</a>
        <ul>
          <li><a href="#31-内部服务如何调用">3.1 内部服务如何调用</a></li>
          <li><a href="#32-外部路由如何实现">3.2 外部路由如何实现</a></li>
        </ul>
      </li>
      <li><a href="#4路由api网关服务发现负载均衡有什么关系">4.路由、API网关、服务发现、负载均衡有什么关系</a></li>
      <li><a href="#5补充负载均衡算法有哪些">5.补充：负载均衡算法有哪些</a></li>
    </ul>
  </li>
</ul>
                    </div>
                
                <!-- End Toc -->
                <p>微服务架构是一种软件设计方法，将大型应用程序分解为独立服务，每项服务都旨在满足特定的业务需求。这些服务在专用资源上运行，包括单独的数据库实例和计算能力。与整体系统不同，微服务应用程序是松散耦合的，允许更大的灵活性。本文我将带领大家深入浅出的了解微服务框架以及通过 Python 来实现一些案例.</p>

<p>[TOC]</p>

<h1 id="微服务介绍">微服务介绍</h1>

<p>有人把微服务比作一把双刃剑, 一方面它把单个问题域的复杂度降低了, 服务可以独立更新,快速交付; 但另一方面, 面对一个有不同技术栈支撑的整体系统, 运维和交付的难度增大了.</p>

<h2 id="概念">概念:</h2>

<ul>
  <li>可以协同工作的, 小而自助的服务. 是我们能够更快的响应不可避免的变化</li>
  <li>服务很小, 专注于做好一件事</li>
  <li>自治性, 可以独立部署在PaaS上, 也可以作为一个操作系统存在.
    <ul>
      <li>尽量避免把多个服务部署在同一个机器上.</li>
      <li>服务之间通过网络调用进行通信.</li>
      <li>服务之间独立修改, 避免耦合.</li>
      <li>服务只暴露出API.</li>
    </ul>
  </li>
</ul>

<h2 id="优缺点">优缺点:</h2>

<h3 id="好处">好处:</h3>

<ol>
  <li>技术异构性: 比如, 一个应用的不同部分用不同的技术和存储实现的最佳实践方式. 如下图, 帖子用ruby代码写, 用文档数据库, 社交关系用go编写代码,用图数据库存储数据. 图片用java编写用blob数据库保存数据. 可以快速使用新技术实现功能, 并降低了使用新的技术的风险. 
<img src="https://ws3.sinaimg.cn/large/006tNbRwgy1furpbgjfl0j309m040jrz.jpg" alt="" /></li>
  <li>提高系统弹性</li>
  <li>扩展性: 庞大的服务只能作为一个整体扩展. 即使只有一小部分的功能有性能瓶颈也需要整体扩展. 微服务只需要对特定有瓶颈的服务进行扩展. 如下图, 图片是瓶颈,  那么就对图片的实例进行扩展. <img src="https://ws3.sinaimg.cn/large/006tNbRwgy1furpsrns6hj30d006u40b.jpg" alt="" /></li>
  <li>简化部署: 发布时只对需要升级的服务进行部署升级, 不需要对整个系统进行重新部署</li>
  <li>可组合性, 可代替性: 对于已有系统, 可以轻松进行重新组合创建出新的系统. 老旧的系统可以轻松换掉某些不需要的服务.</li>
</ol>

<h3 id="缺点">缺点:</h3>

<ol>
  <li>缺乏经验导致差劲的切分; 尽量避免过早的对产品进行微服务切分</li>
  <li>更多的网络交互.因为切分后, 一个进程变成了多个进程, 本来的内部请求都变成了外部网络调用请求. 而且还要考虑到网络延迟, 网络请求失败, 同步请求还是异步, 请求响应时间, 网络错误码的设计.</li>
  <li>数据的存储和分享. 很难保持数据的重复和微服务的数据隔离(独立); 进行多表联合查询也是一件挺费事的事. 微服务之间的数据分享变得困难</li>
  <li>版本兼容问题. 如果一个新的需求产生了向后兼容问题, 并且需要修改多个微服务, 且服务之间还需要进行数据交换, 那么就会产生问题. 可以通过版本控制解决问题.</li>
  <li>测试和部署. 切分微服务后, 整个产品端到端的测试就会演变成对每个微服务的端到端测试, 增加了许多工作量.</li>
</ol>

<h2 id="架构师的战略目标原则和实践">架构师的战略目标,原则和实践</h2>

<ul>
  <li>
    <p>战略目标关心的是公司走向以及如何才能让客户满意, 比如开拓亚洲市场, 或者让客户尽量使用自助服务</p>
  </li>
  <li>
    <p>原则遵从战略目标, 最好不要超过十个</p>
  </li>
  <li>
    <p>通过实践来保证目标得到实施, 实践更偏重技术层面, 比如 HTTP/REST 接口标准. 下面是一个例子<img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fusu889c4mj30g30b279q.jpg" alt="" /></p>
  </li>
</ul>

<h2 id="如何建模微服务">如何建模微服务</h2>

<p>传统的架构</p>

<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fuvzs6g9syj30ds09iab3.jpg" alt="" /></p>

<p>微服务架构<img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fuvztk4gm6j30gr0b0ju0.jpg" alt="" /></p>

<h3 id="好的服务-松耦合-高内聚">好的服务, 松耦合, 高内聚</h3>

<ul>
  <li>
    <p>如果做到了松耦合, 修改一个服务就不需要修改另一个服务;</p>
  </li>
  <li>一个松耦合的服务应该尽量少的知道与之协作的其他服务的信息. 就是说限制两个服务之间不同调用形式的数量, 因为过度通信会导致紧耦合</li>
  <li>把相关的行为聚合一起, 无关的行为放在别处. 因为当需要改变一个行为的时候, 最好在一个地方就可以完成修改, 然后尽快的发布. 如果在不同的地方进行修改, 那么就可能会有多个微服务发布. 在多个地方进行修改会很慢, 并且会提高发布的风险.</li>
</ul>

<h3 id="限界上下文">限界上下文</h3>

<ul>
  <li>就是对提供的微服务限制使用边界和使用场景, 哪些需要对外提供服务, 哪些不需要; 边界和场景就是上下文</li>
  <li>每个上下文都有明确的接口, 该接口决定了他会暴露哪些模型给其他的上下文.</li>
  <li>比如财务部门和仓库是两个独立的限界上下文. 他们都有明确的对外接口. 财务部门不需要知道仓库的内部细节, 只需要知道一些必要的信息. 反之亦然. 如下图. 财务部门和仓库之间的共享模型. 两个上下文的衔接部分就是库存项.<img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fuswua8evmj30f307njt4.jpg" alt="" /></li>
  <li>同一个名字在不同的上下文中也有不同的含义. 比如退货, 在客户的上下文中, 退货意味着打印运送标签, 寄送包裹, 等待退款. 在仓库的上下文中, 表示即将到来一个包括, 并且等待重新入库.</li>
  <li>当规划上下文的时候, 不应该从上下文提供的<strong>共享数据</strong>考虑, 而是从上下文提供的<strong>服务</strong>来考虑, 比如仓库上下文要考虑提供的服务是共享库存清单, 财务的上下文是共享月末账目或者为新员工创建工资单.</li>
  <li>逐步划分上下文, 就是说不需要一次性的把微服务分的太细, 可以先大块的进行切分上下文, 然后等业务需要在进行更细粒度的划分. 比如可以先将仓库划分为一个上下文. 如果之后有必要, 再将库存管理划分为一个单独的上下文. <img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fusxcd3romj30g804xt9f.jpg" alt="" /></li>
  <li>按地理位置和组织结构划分上下文. 有的时候不同团队负责不同的模块开发, 那么尽量将不同团队做的模块划分成不同的上下文. 如果两个地区的两个团队再做同一个模块的开发, 也要考虑是否将他们的工作内容分开到不同的上下文中, 这样有利于对基于上下问的微服务进行快速响应和部署发布.</li>
</ul>

<h2 id="集成">集成</h2>

<p>集成是微服务相关技术中最重要的一个</p>

<h3 id="理想的集成技术">理想的集成技术</h3>

<ol>
  <li>向后兼容, 避免破坏性修改. 如果一个微服务在响应中增加了一个字段, 已有的消费方式不应该受到影响</li>
  <li>保证API的技术无关性. 就是说不管是用.net, java, php 还是 python, 都应该保证微服务的通信方式. 技术无关性. 意味着不应该选择对微服务的具体实现技术有限制的集成方式.</li>
  <li>易于消费方使用. 如果消费方使用我们的微服务比登天还难, 那么再好的微服务也没有任何意义. 消费方应该可以使用任何技术都可以获得微服务提供的服务. 可以考虑使用客户端(SDK), 但是容易造成紧耦合(也就是说修改一个微服务, 同时也要修改SDK 才能给消费端使用).</li>
  <li>隐藏内部实现细节. 我们不希望消费方和微服务的内部细节绑定起来, 否则会增加耦合度. 增加不影响消费端的修改难度.为了可以更容易的进行向后兼容, 就应该尽量少的暴露细节.</li>
</ol>

<h3 id="为微服务创建接口">为微服务创建接口</h3>

<p>举个例子, 创建一个 <strong>新建用户</strong> 的接口</p>

<p>新建用户不仅仅是CRUD, 还需要调用其他的微服务(业务流程), 比如进行付账设置, 发送欢迎邮件等. 修改或者删除用户也会出发其他相关的业务流程.</p>

<h3 id="共享数据库">共享数据库</h3>

<p>不要让消费方直接访问数据库. 因为数据库本身可能会被替换, 表结构也可能经常变化. 因此就造成了高耦合.</p>

<h3 id="微服务的同步与异步">微服务的同步与异步</h3>

<ul>
  <li>
    <p>同步通信是指调用方发起远程服务调用后,需要阻塞自己直到整个操作完成.</p>
  </li>
  <li>
    <p>异步通信, 调用方不需要等待操作完成就可以返回. 不需要关心操作是否可以完成.</p>
  </li>
  <li>同步方式比较简单, 很容易知道调用的成功和失败, 但是增加了耦合度. 异步降低了耦合度, 但是却无法知道成功失败.</li>
  <li>建议使用异步+回调的方式进行.</li>
</ul>

<h3 id="rest">REST</h3>

<ul>
  <li>REST 是 RPC 的一种代替方式, 是一种数据通信的风格和标准</li>
  <li>通过 HTTP的 POST, GET, PUT, DELETE 等动词请求, 通过JSON格式进行数据的发送和响应.</li>
  <li>需要为每一个API请求提供足够丰富的Error Code/Message 来帮助消费方了解发生错误时具体遇到了什么问题.</li>
  <li>建议所有对微服务的请求需要证书来进行认证</li>
</ul>

<h3 id="json--xml-还是其他">JSON , XML 还是其他</h3>

<ul>
  <li>
    <p>相比于XML, JSON 的内容更加紧凑.</p>
  </li>
  <li>
    <p>XML 的优势是可以进行超媒体控制</p>
  </li>
</ul>

<h3 id="版本管理">版本管理</h3>

<ul>
  <li>使用语义化的版本管理, 既给每个版本一个可以看懂,并有一些含义的版本名称</li>
  <li>比如 Major.Minor.Patch. 这样一个版本名字
    <ul>
      <li>Major 意味着包含了向后不兼容的修改.</li>
      <li>Minor 意味着有新功能增加, 但是向后兼容.</li>
      <li>Patch 的改变意味着对已有功能的缺陷修改</li>
      <li>比如: 1.2.0 到1.3.0 就不需要消费方进行任何修改, 而1.3.0 到2.0.0 就需要消费方进行代码的升级更新了.</li>
    </ul>
  </li>
  <li>同一个接口的不同版本: 为了降低消费方修改代码的几率, 我们可以将不同版本共存, 比如同时提供 1.3.0 和2.0.0 的服务, 保存新老两个接口. 好处是我们可以尽快发布新版本, 不需要等待客户方的修改, 同时也给了客户足够的时间进行版本的迁移. 一旦观察到老的版本不再需要(没有任何访问了), 就可以删除掉老的接口和代码. 但是绝对要避免维护太多的版本, 建议不要超过2个. 可以将不同版本号加到URI 中, 比如/v1/storePatientData, /v2/storePatientData<img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fuu1vgkyjtj30g708u40x.jpg" alt="" /></li>
</ul>

<h3 id="为前端提供服务的后端">为前端提供服务的后端</h3>

<ul>
  <li>前端web/app 界面可以在一个界面中请求一个或者多个API</li>
  <li>有时, 为了提高后端的响应效率, 后端可以将信息集成后发送给前端. 就是说前端之访问一个 gateway 接口, gateway 接口负责调用其他API 获得数据后返回给前端.</li>
  <li>也可以为每一种前端单独定制自己的独立API入口<img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuu2d429a6j30gf0c1juh.jpg" alt="" /></li>
</ul>

<h2 id="分解单块系统">分解单块系统</h2>

<p>如何将一个已有的系统进行分解, 变成可用的微服务</p>

<h3 id="分解上下文">分解上下文</h3>

<p>识别上下文: 以在线音乐服务 MusicCorp 为例, 首先识别有哪些上下文, 分解如下</p>

<ul>
  <li>产品目录: 正在销售的音乐CD产品相关的元数据</li>
  <li>财务: 账户, 支付, 退款等信息</li>
  <li>仓库: 分发客户的订单, 处理退货, 库存等</li>
  <li>推荐: 推荐算法和专利.</li>
</ul>

<h3 id="分解的原则">分解的原则:</h3>

<ul>
  <li>
    <p>按上下文分解</p>
  </li>
  <li>
    <p>按照团队分解: 不同地区的团队应该具有独立自主的对某些上下文全权负责.</p>
  </li>
  <li>
    <p>按技术分解: 对于某些专门的技术, 比如推荐系统, 或某种开发语言比如Java, 将这种内容才分成独立的</p>
  </li>
  <li>
    <p>安全: 将有特殊安全要求的服务单独分离出来作为一个微服务</p>
  </li>
</ul>

<h3 id="打破外键">打破外键</h3>

<ol>
  <li>财务报表直接使用总账表, 总账表中只有产品ID, 没有产品名称, 名称在产品表中.</li>
  <li>原来的代码是财务报表是通过外键直接访问产品表获取产品名称, <img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fuv2hxidg8j30fy06dq3z.jpg" alt="" /></li>
  <li>经过修改, 让财务服务直接访问产品服务来获取产品名称 <img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fuv2j84e6pj30g206e0tq.jpg" alt="" /></li>
  <li>缺点是增加了一次数据库访问, 但是这个是可以进行优化的.</li>
  <li>如果原来数据库中有事物的需要, 那么就需要将数据库的事物改到代码中.</li>
</ol>

<h3 id="共享静态数据">共享静态数据</h3>

<ul>
  <li>比如多个微服务都需要使用一个静态的国家列表数据, 解决方法是将这些数据拷贝成多份, 每个微服务读取期中一份.</li>
</ul>

<h3 id="重构数据库">重构数据库</h3>

<ul>
  <li>在拆分上下文的时候, 也要考虑重构表结构(会有一些必要的拆分动作). 拆分表结构之后会造成数据库的访问次数增加.</li>
  <li>表结构拆分成功后, 如果每个微服务都可以顺利跑桶, 就可以考虑进行数据库拆分了.</li>
  <li>最后将整个应用程序拆分成若干个微服务.</li>
</ul>

<h3 id="事物边界">事物边界</h3>

<ul>
  <li>数据库中实现事物很简单, 但是一旦拆分到不同的服务中, 想要保持事物就比较困难了, 比如微服务1提交成功后, 需要微服务2继续提交,但是失败了. 那么就需要两种方法</li>
  <li>
    <ol>
      <li>继续提交, 直到成功</li>
      <li>撤销微服务1之前的提交.</li>
    </ol>
  </li>
</ul>

<h3 id="生成报告">生成报告</h3>

<ul>
  <li>未被拆分的数据库可以很容易生成跨表进行联查的报告, 但是一旦将原有数据库拆分, 进行查询就困难了</li>
  <li>解决方法有两种:</li>
  <li>
    <ol>
      <li>每个微服务就提供获取有限报告的接口</li>
      <li>每个微服务将数据推送到独立的报告系统中, 然后再在报告系统中生成视图, 组装报告 <img src="https://ws2.sinaimg.cn/large/0069RVTdgy1fuv3khjza4j30g505nwfo.jpg" alt="" /> <img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fuv3jeace1j30ga08vwgb.jpg" alt="" /></li>
    </ol>
  </li>
</ul>

<h2 id="部署">部署</h2>

<h3 id="持续集成-ci">持续集成 CI</h3>

<p>测试别人是否真正理解CI的三个问题</p>

<ul>
  <li>你是否每天签入代码到主线?  要尽可能频繁的把代码提交到主干或分支中</li>
  <li>你是否有一组测试来验证修改? 没有对代码进行检验的CI不是真正的CI</li>
  <li>当构建失败, 团队是否把修改CI单过第一优先级的事情来做? 构建失败后需要立即修复, 否则拖的时间越长, 新代码越多, 也越难修复.</li>
</ul>

<h3 id="把持续集成映射到微服务">把持续集成映射到微服务</h3>

<ol>
  <li>
    <p>简单的做法: 只有一个构建, 任何修改都会出发构建. 每个构架你会产生三个微服务. 缺点是每次都是所有微服务同时发布. 好处是简单. 建议项目初期使用.<img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fuv54omu8aj30g4063taq.jpg" alt="" /></p>
  </li>
  <li>
    <p>中间做法:将一个代码库分成多个子目录, 应扫到不同的构建中 <img src="https://ws2.sinaimg.cn/large/0069RVTdgy1fuv58xn7lbj30f706j0uu.jpg" alt="" /></p>
  </li>
  <li>
    <p>最好的方法: 每个微服务有自己的源代码库, 和CI 构建 <img src="https://ws2.sinaimg.cn/large/0069RVTdgy1fuv59u5ib6j30fd05x764.jpg" alt="" /></p>
  </li>
</ol>

<h3 id="构建流水线和持续交付">构建流水线和持续交付</h3>

<ul>
  <li>
    <p>将构建分成多个阶段是有必要的 , 下面是标准的构建流水线的发布流程<img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fuv5clgklaj30g502ngmb.jpg" alt="" /></p>
  </li>
  <li>微服务的世界中, 每个微服务都有一套像上面一样自己的构建流程.</li>
  <li>唯一例外是在项目刚开始阶段, 很难划清上下文边界和构建边界, 那个阶段必须把所有服务打包发布. 当API稳定之后, 就可以把他们移到自己的构建当中了.</li>
  <li>随着微服务的增多, 部署的整个流程需要自动化完成</li>
</ul>

<h3 id="特定构建物">特定构建物</h3>

<p>不同语言会有不同的构建物</p>

<ul>
  <li>Java - JAR</li>
  <li>Ruby - gem</li>
  <li>Python - egg</li>
  <li>Node.js - NPM</li>
</ul>

<p>可以使用 puppet 或者 chef , Ansible 这样的自动化配置管理工具.</p>

<p>通过虚拟机来安装软件和部署环境, 可以加快部署速度 <img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fuv5tv97rnj30ga084abq.jpg" alt="" /></p>

<h3 id="微服务和主机之间的映射">微服务和主机之间的映射</h3>

<p>一个微服务到底需要几个主机(物理或者虚拟或者容器) , 下面是几种选择</p>

<ol>
  <li>
    <p>单主机多服务: 好处是成本低, 易管理. 缺点是难以监控(比如CUP高了, 不知道是哪个服务造成的), 也会造成部署复杂. 因为有可能一个服务的部署会依赖另一个服务. 或者两个服务之间的部署环境冲突.</p>
  </li>
  <li>
    <p>单主机多容器,多服务:一台主机部署多个容器, 每个同期部署一个微服务. <img src="https://ws2.sinaimg.cn/large/0069RVTdgy1fuv6ggj2wej30ga07wgmx.jpg" alt="" /></p>
  </li>
  <li>
    <p>单主机单服务: 但是成本会更高.</p>
  </li>
  <li>
    <p>使用PaaS 云服务的单主机但服务: 基于3#, 可以降低成本.</p>
  </li>
</ol>

<h3 id="虚拟化容器化">虚拟化,容器化</h3>

<p>虚拟化可以将单台物理机更有效的利用起来</p>

<p><img src="https://ws2.sinaimg.cn/large/0069RVTdgy1fuv6dyrfjrj30g4078di6.jpg" alt="" /></p>

<p>不同的虚拟技术有</p>

<ul>
  <li>AWS, WMWare, VSphere, Xen, KVM. Docker</li>
  <li>CentOS 有一个专门为 Docker 设计的操作系统</li>
  <li>Docker 是一个简单的Paas</li>
  <li>Kubernets 和 CoreOS , Deis 这些工具可以帮助我们扩平台管理容器.</li>
</ul>

<h1 id="用python-开发-微服务">用Python 开发 微服务</h1>

<h2 id="微服务用到的python扩展">微服务用到的Python扩展</h2>

<p>网络请求</p>

<blockquote>
  <p><a href="https://twistedmatrix.com/trac/">twisted</a>  异步处理框架</p>

  <p><a href="http://www.tornadoweb.org/en/stable/">Tornado</a> 异步处理框架</p>

  <p><a href="https://pypi.org/project/greenlet/">Greenlet</a> 高并发的线程框架</p>

  <p><a href="http://www.gevent.org">Gevent</a> 在Greenlet 基础上做的基于协程的高并发看框架</p>

  <p><a href="https://docs.python.org/3/library/asyncio.html">Asyncio</a> 官方推荐的异步网络操作, 并发, 协程</p>
</blockquote>

<p>Python 编译器</p>

<blockquote>
  <p><a href="http://pypy.org">Pypy</a> 比Cpython 更快的编译器, 可以用于微服务.</p>
</blockquote>

<p>日志</p>

<blockquote>
  <ul>
    <li><a href="http://flask.pocoo.org/docs/1.0/api/">Signal</a> : Flask 整合了 Blinker (https://pythonhosted.org/blinker/), 支持信号. 当一个事件被触发, 就会发出一个信号, 并调用执行我们自定义的方法.比如template_rendered 就是当前程序在获取到模板渲染完毕后就会触发这个信号. 可以用于发送日志和统计数据. 我们可以自定义信号, 比如下载完一个PDF的时候, 可以定义一个 pdf_ready. 缺点是产生的信号是同步处理的, 如果不是很快完成信号触发的任务, 就会造成程序阻塞.</li>
    <li><a href="https://www.rabbitmq.com/">RabbitMQ</a> 可以解决 Blinker 的同步问题.</li>
  </ul>
</blockquote>

<p>Flask 配置参数管理</p>

<blockquote>
  <ul>
    <li>
      <p><a href="https://github.com/mozilla-services/konfig">Konfig</a>  用Flask 默认取配置信息的方法是将素有配置文件放在一个单独的python 文件中(比如prod_settings.py), 然后在再在主程序中调用<code class="language-plaintext highlighter-rouge">app.config.from_object('prod_settings.Config')</code> , 这种方法有两个缺点, 1 配置文件可能会出现负责的python代码逻辑, 2 需要将这个代码放在代码库中, 但是这是不合适的.  Konfig 支持读取.ini文件, 并可以读取Yaml格式的文件.</p>

      <div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="gp">$ </span>more settings.ini
   <span class="o">[</span>flask]
   DEBUG <span class="o">=</span> 0
   SQLURI <span class="o">=</span> postgres://tarek:xxx@localhost/db
   <span class="nv">$ </span>python
   &gt;&gt;&gt; from konfig import Config
   &gt;&gt;&gt; from flask import Flask
   &gt;&gt;&gt; c <span class="o">=</span> Config<span class="o">(</span><span class="s1">'settings.ini'</span><span class="o">)</span>
   &gt;&gt;&gt; app <span class="o">=</span> Flask<span class="o">(</span>__name__<span class="o">)</span>
   &gt;&gt;&gt; app.config.update<span class="o">(</span>c.get_map<span class="o">(</span><span class="s1">'flask'</span><span class="o">))</span>
   &gt;&gt;&gt; app.config[<span class="s1">'SQLURI'</span><span class="o">]</span>
   <span class="s1">'postgres://tarek:xxx@localhost/db
</span></pre></td></tr></tbody></table>
</div>
      </div>
    </li>
  </ul>
</blockquote>

<p>微服务Flask代码框架</p>

<blockquote>
  <ul>
    <li>
      <p><code class="language-plaintext highlighter-rouge">setup.py</code>: Distutils’ setup file, which is used to install and release the project</p>
    </li>
    <li><code class="language-plaintext highlighter-rouge">Makefile</code>: A Makefile that contains a few useful targets to make, build, and run the project</li>
    <li><code class="language-plaintext highlighter-rouge">settings.ini</code>: The application default settings in the INI file</li>
    <li><code class="language-plaintext highlighter-rouge">requirements.txt</code>: The project dependencies following the pip format</li>
    <li><code class="language-plaintext highlighter-rouge">myservices</code>/: The actual package
      <ul>
        <li><code class="language-plaintext highlighter-rouge">__init__.py</code></li>
        <li><code class="language-plaintext highlighter-rouge">app.py</code>: The app module, which contains the app itself</li>
        <li><code class="language-plaintext highlighter-rouge">views</code>/: A directory containing the views organized in blueprints <strong>init</strong>.py</li>
        <li><code class="language-plaintext highlighter-rouge">home.py</code>: The home blueprint, which serves the root endpoint</li>
        <li><code class="language-plaintext highlighter-rouge">tests</code>: The directory containing all the tests
          <ul>
            <li><code class="language-plaintext highlighter-rouge">__init__.py</code></li>
            <li><code class="language-plaintext highlighter-rouge">test_home.py</code>: Tests for the home blueprint views</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>测试</p>

<blockquote>
  <p><a href="https://requests-mock.readthedocs.io/en/latest/overview.html">requests-mock</a> 用于单元测试的模拟请求</p>

  <p><a href="https://github.com/tarekziade/boom">Boom</a> 是一个基于AB的压力测试框架</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>pip install boom 
boom http://127.0.0.1:5000/api -c 100 -d 10 -q
</pre></td></tr></tbody></table>
</div>
  </div>

  <p><a href="https://github.com/muatik/flask-profiler">flask-profiler</a> 是一个带报表的压力测试框架</p>
</blockquote>

<h2 id="网络请求用到的相关技术">网络请求用到的相关技术</h2>

<h3 id="异步网络框架-twisted-and-tornado">异步网络框架 Twisted and Tornado</h3>

<p><a href="https://blog.csdn.net/qq_33855133/article/details/73105366">简单介绍</a></p>

<h3 id="多任务协程请求-greenlet-and-gevent">多任务协程请求: Greenlet and Gevent</h3>

<p>Greenlet 和 Gevent 都是python 的协程类库, 帮助Python 实现多携程, 不用等待一个请求的结束就可以执行另一个请求.</p>

<p><a href="https://www.cnblogs.com/PrettyTom/p/6628569.html">简单介绍</a></p>

<h3 id="高并发模块-asyncio--python3">高并发模块 asyncio  (python3)</h3>

<p><a href="https://www.cnblogs.com/zhaof/p/8490045.html">简单介绍</a></p>

<p>asyncio 是干什么的？</p>

<ul>
  <li>异步网络操作</li>
  <li>并发</li>
  <li>协程</li>
</ul>

<h2 id="flask-的使用">Flask 的使用</h2>

<p>使用python3 或者 python2都可以, 因为微服务可以让每个服务有自己的版本, 但Flask官方还是建议开始使用python3 <a href="http://flask.pocoo.org/docs/dev/python3/#python3-support">建议</a> 因为 2020年之后Python官方也不再支持python2<a href="https://pythonclock.org">反方消息</a>, 而且很多新的技术和框架都是基于3的.</p>

<h3 id="flask处理网络请求">Flask处理网络请求</h3>

<p>最简单的网络请求响应</p>

<div class="language-python highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">jsonify</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>


<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/api'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_microservice</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">({</span><span class="s">'Hello'</span><span class="p">:</span> <span class="s">'World!'</span><span class="p">})</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>用curl 来测试请求</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>curl -v http://127.0.0.1:5000/api

</pre></td></tr></tbody></table>
</div>
</div>

<h3 id="服务之间的调用">服务之间的调用</h3>

<h4 id="同步请求">同步请求</h4>

<ul>
  <li>
    <p>需要创建一个 request, 并用session保持连接</p>
  </li>
  <li>
    <p>需要通过异常捕获处理超时的问题</p>
  </li>
  <li>
    <p>可以使用连接池</p>
  </li>
  <li>
    <p>可以http cache 头 缓存内容, 改变数据时更新 Etag</p>
  </li>
  <li>
    <p>request请求时用gzip压缩内容</p>
  </li>
  <li>
    <p>将内容变成二进制进行传输, 用 Protocol Buffer 和 MessagePack 库</p>
  </li>
</ul>

<h4 id="异步请求">异步请求</h4>

<ul>
  <li>如果用同一个进程的多线程/协程处理多请求, 那么主进程挂了或者卡出了就会出问题</li>
  <li>更好的方法是发一个消息出去</li>
  <li>Celery, Redis 都可以作为消息代理</li>
  <li>Task Queue是一个服务向一个queue中丢任务,另一端的workers从queue中取任务, Celery 实现的是Task Queue</li>
  <li>Topic Queue是Task Queue的一个变种, queue两端是根据topic来发送和接收消息的. 是通过订阅的方式来进行的. Rabbit MQ 就是这种实现, 使用的是 AMQP 协议.</li>
  <li>Rabit MQ + Pika 组合可以在python中实现topic queue.</li>
  <li>Pick-pool 是另一个类库, 可以建立一个消息池, 这样就不用每次都打开和关闭rabitMQ了. 但是需要一个独立的flask 执行一个pick-client 进程来接收信息.</li>
</ul>

<h3 id="发布和订阅">发布和订阅</h3>

<ul>
  <li>和queue相比，消息订阅和发布可以让一个消息传送到多个消费者手中， 相当于把一个message 广播给多个微服务。</li>
</ul>

<h3 id="测试请求--模拟调用">测试请求 – 模拟调用</h3>

<ul>
  <li>requests-mock  是一个模拟调用的类库</li>
  <li>可以通过 unittest 单元测试结合 requests-mock 进行模拟网络调用。</li>
  <li>既可以模拟同步调用， 也可以模拟异步调用</li>
  <li>测试微服务的请求原则是隔绝测试， 既只测试自己发送和接收消息的能力， 不要依赖其他微服务。多个微服务的整体的测试需要日志系统协助来trouble shooting。</li>
</ul>

<h2 id="监控微服务">监控微服务</h2>

<ul>
  <li>
    <p>好处</p>

    <ul>
      <li>当多个微服务相互调用时出现了问题， 很难追踪到底哪里出了问题。</li>
      <li>解决方法时将log 中心化， 放在一个地方统一的进行观察和分析。</li>
      <li>同时需要监控每个微服务的内存用量，CPU用量， 每分钟请求数等。</li>
      <li>从成本考虑， 也可以根据监控的出的结论来的计算结果推导出来目前的平台网络成本和建议</li>
      <li>对于新上线的修改和变化，可以通过监控来了解是否一切正常。</li>
    </ul>
  </li>
</ul>

<h3 id="日志管理">日志管理</h3>

<ul>
  <li>Python 的 Logging 类库可以用来进行 log 的收集</li>
  <li>Sentry 是一个进行错误日志集中收集的Python 类库， 他还有一个UI界面可以查看日志， 并能够设计处理错误信息的工作流程。</li>
  <li>GrayLog 可以收集的不仅仅是错误日志，还可以收集普通log信息,  有一个强大的搜索引擎， 基于Elasticsearch 。 日志数据存储在MongoDB中。
    <ul>
      <li>设置Graylog比较麻烦， 简单的方法是使用它的docker image http://docs.graylog.org/en/latest/pages/installation/docker.html</li>
      <li>Graylog也有后台界面可以访问。</li>
      <li>Graypy 是 python 的一个访问 GrayLog的类库， 可以通过UDP 或者 AMQP协议，upd可能会丢失log, 如果要求严格， 可以用基于AMQP协议的RabitMQ 传输log</li>
    </ul>
  </li>
</ul>

<h3 id="监控管理">监控管理</h3>

<p>监控分为</p>

<ul>
  <li>
    <p>系统级别监控， 磁盘， 内存，cpu等</p>
  </li>
  <li>
    <p>代码级别监控</p>
  </li>
  <li>
    <p>web server 级别监控</p>
  </li>
</ul>

<h4 id="系统级别监控">系统级别监控</h4>

<ul>
  <li>psutil 是一个python 类库， 相似与 linux 的ps命令。结合 graypy 就可以将信息通过日志发送到日志中心。可以运行一个独立的python专门获取cpu信息并发送日志</li>
  <li>system-metrics 更强大一些， 可以获得更多的系统信息， 并且可以和Graylog结合， 显示在GrayLog的UI上， 并发送接收报警。</li>
</ul>

<h4 id="代码级别监控">代码级别监控</h4>

<ul>
  <li>
    <p>代码级别可以查看jinjia2 的读取速度和数据库的响应速度等。</p>
  </li>
  <li>一种方法是用benchmark 的方式在读取模板或者数据库的代码前后用代码包住， 计算时间。 但是这种方法有风险， 因为会污染代码</li>
  <li>方法是写一个装饰器 @timeit</li>
</ul>

<h4 id="web-server-级别监控">web server 级别监控</h4>

<p>这个级别的监控日志也要发到日志中心， 但是需要nginx直接发送，而不是通过 flask</p>

<ul>
  <li>Graylog 有一个nginx content pack 包， 可以将error logs, access log 发送到 graylog</li>
  <li>可以获取的信息如下：
    <ul>
      <li>The average response time</li>
      <li>The number of requests per minute</li>
      <li>The remote address</li>
      <li>The endpoint and verb of the request</li>
      <li>The status code and size of the response</li>
    </ul>
  </li>
</ul>

<h2 id="微服务安全">微服务安全</h2>

<p><strong>认证</strong></p>

<p>OAuth2 用于第三方访问我们微服务的认证</p>

<p>CCG用于微服务间的认证。</p>

<p><strong>防火墙</strong></p>

<p>为了防止DDoS攻击， 我们需要做一个basic firewall 来进行防御</p>

<p><strong>代码安全</strong></p>

<p>我们还要进行一些代码扫描， 确保代码没有安全问题。</p>

<h3 id="oauth2-认证">OAuth2 认证</h3>

<p>OAuth2 用于第三方访问我们微服务的认证</p>

<p>对于微服务我们要知道两点</p>

<ul>
  <li>we need to know who is calling the
service (<strong>authentication</strong>) and</li>
  <li>we need to make sure that the caller is allowed to perform the
call (<strong>authorization</strong>).</li>
</ul>

<p>OAuth2是一个灵活的解决方案来解决微服务的安全认证问题。</p>

<blockquote>
  <p>OAuth2 是一个中心化的认证系统，让访问者先用code 或者 token 进行身份验证。这个验证也叫 three-legged OAuth (三条腿认证) ， 图示如下(右上角可以暂时理解为微信的认证服务)：</p>

  <p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fv108383swj307u06bmxq.jpg" alt="" /></p>

  <p>当用户访问app时（1），会被重新跳转到微信认证服务，让app可以得到被允许访问微信的授权（2）。一旦授权通过，app就会通过一个http回调请求拿到授权， 并代表用户使用微信的API</p>
</blockquote>

<p>OAuth2 用于第三方访问我们微服务的认证</p>

<h3 id="ccg---基于token的认证">CCG - 基于Token的认证</h3>

<ul>
  <li>OAuth 2.0 定义了四种授权方式：authorizationcode、implicit、resource owner password credentials、client credentials。</li>
  <li>CCG(Client Credentials Grant) 是其中同一种https://tools.ietf.org/html/rfc6749#section-4.4</li>
  <li>CCG认证用于微服务之间的认证。</li>
  <li>微服务之间的认证不需要牵扯用户， 所以只需要使用 <strong>Client Credentials Grant (CCG)</strong> 就可以了。</li>
  <li>Token 就相当于密码， 它允许你访问一个指定的资源， 不管你是用户还是微服务。</li>
  <li>Token可以是
    <ul>
      <li>用户名或者ID</li>
      <li>scope, 请求者可以访问的资源的范围，或者权限</li>
      <li>时间戳， 表示token 颁发的时间点</li>
      <li>时间戳， 表示token过期时间</li>
    </ul>
  </li>
  <li>一个Token 可以被设置成访问多个微服务。</li>
</ul>

<h3 id="jwt-标准">JWT 标准</h3>

<ul>
  <li>
    <p>Jason Web Token的缩写</p>
  </li>
  <li>OAuth2 为它的Token 使用JWT标准</li>
  <li>
    <p>JWT tokens用base64的加密方式</p>
  </li>
  <li>JWT Token 是用两个点分割的三个部分组成
    <ul>
      <li>
        <p><strong>Header</strong>: 提供token的信息， 比如加密方式</p>
      </li>
      <li>
        <p><strong>Payload</strong>：真实的数据</p>
      </li>
      <li>
        <p><strong>Signature</strong>： hash签字， 用来确认合法性</p>
      </li>
      <li>
        <p>一个例子 : 其实token 是一行，下面例子为了容易看， 分成三行</p>

        <div class="language-text highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJ1c2VyIjoidGFyZWsifQ.
OeMWz6ahNsf-TKg8LQNdNMnFHNtReb0x3NMs0eY64WA
</pre></td></tr></tbody></table>
</div>
        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="pyjwt-可以轻松的创建jwt-token-并读取jwt-token">PyJWT 可以轻松的创建JWT token 并读取JWT token.</h4>

<p>pyJWT既可以创建对称加密解密的token, 也可以创建公钥私钥的tlken</p>

<h3 id="基于-x509-证书的认证">基于 X.509 证书的认证</h3>

<p>SSL 就是基于X.509的协议。</p>

<p>这是基于公钥和私钥的token方式</p>

<p>这要先通过 openssl 命令生成公钥私钥。</p>

<p>然后再利用PyJWT , 用私钥加密， 用公钥解密</p>

<h3 id="tokendealer-的微服务代码案例">TokenDealer 的微服务代码案例</h3>

<ul>
  <li>是系统中的唯一的认证微服务</li>
  <li>使用CCG 流程</li>
  <li>当前微服务会收到其他微服务获取token的请求, 并授予一个一天期限的token</li>
  <li>使用私钥处理token, 然后发布公钥给其他服务验证token.</li>
  <li>这个微服务会保存所有client ids 和 安全码</li>
  <li>TokenDealer 暴露出来的三个接口
    <ul>
      <li>Get <code class="language-plaintext highlighter-rouge">/.well-known/jwks.json</code> 是Json Web Key, 用于其他微服务自己我验证token的</li>
      <li>POST <code class="language-plaintext highlighter-rouge">/oauth/token</code> 会返回一个token.</li>
      <li>POST <code class="language-plaintext highlighter-rouge">/verify_token</code> 返回token 的 payload, 是验证token. 如果验证失败, 返回400</li>
    </ul>
  </li>
</ul>

<h3 id="web防火墙">Web防火墙</h3>

<p>了解一些基本的网络攻击形式</p>

<ul>
  <li>SQL 注入</li>
  <li>Cross Site Scripting(XSS) 跨站攻击</li>
  <li>Cross-Site REquest Forgery(XSRF/CSRF)  跨站请求伪造</li>
  <li>DDOS 攻击</li>
</ul>

<h4 id="openresty---lua--nginx-实现-waf">OpenResty - Lua + Nginx 实现 WAF</h4>

<p>OpenResty® 是一个基于 <a href="http://openresty.org/cn/nginx.html">Nginx</a> 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关</p>

<p>使用NGINX+Openresty实现WAF功能</p>

<p>英文：Web Application Firewall，简称： WAF</p>

<h3 id="代码安全">代码安全</h3>

<p>两个基本原则：</p>

<ol>
  <li>外部的任何请求都需要谨慎对待后再进入内部系统处理</li>
  <li>内部系统做任何事情都需要在一个定义良好的范围内</li>
</ol>

<h4 id="判断进来的数据">判断进来的数据</h4>

<ul>
  <li>防止SQL注入</li>
  <li>防止模板注入</li>
</ul>

<h4 id="限制应用的执行范围">限制应用的执行范围</h4>

<ul>
  <li>用JWT Token 可以限制微服务之间的读写权（POST, Get, Put, Delete）</li>
  <li>可以在阿里云上设置防火墙的黑白名单</li>
  <li>不要用root用户在Linux上执行操作。
    <ul>
      <li>web 服务需要用非root用户执行</li>
      <li>尽量不要在代码中执行系统命令</li>
    </ul>
  </li>
</ul>

<h4 id="使用bandit-linter-进行代码扫描">使用Bandit linter 进行代码扫描</h4>

<h2 id="打包-运行微服务">打包， 运行微服务</h2>

<p>开发过程中我们需要将多个微服务安装到自己的本地环境中进行测试， 如何打包和部署测试是一个重要任务。</p>

<p>关于打包的一些名词的定义：</p>

<ul>
  <li>
    <p>Python package: 是包含python modules的目录树， 是命名空间</p>
  </li>
  <li>Python project: 是包含多个package和资源的项目， 可以被单独release. 我们的每个微服务是一个独立的python project</li>
  <li>Python application: 是一个可以和用户交互的python project. UI 或者命令行都可以是和用户交互的方式。</li>
  <li>Python library: 是一类特别的python project, 可以被其他的Python project 进行内部调用。 没有直接的用户交互接口。</li>
</ul>

<h3 id="打包工具链">打包工具链</h3>

<h4 id="打包用的配置文件">打包用的配置文件</h4>

<p>打包项目之前需要有三个文件</p>

<ol>
  <li>setup.py: 可以驱动所有事情的模块</li>
  <li>requirement.txt: 项目的依赖列表</li>
  <li>MANIFEST.in: 一个模板文件列出了release 时需要被包含的文件列表。</li>
</ol>

<h5 id="setuppy">setup.py</h5>

<p><a href="https://www.cnblogs.com/maociping/p/6633948.html">说明</a></p>

<p>pip 是在线安装一个包的命令， 而如果想将一个自己开发的包发布出去， 那么就需要有一个setup.py文件来管理你开发的这个项目需要依赖的内容了。</p>

<p>假如我在本机开发一个程序，需要用到python的redis、mysql模块以及自己编写的redis_run.py模块。我怎么实现在服务器上去发布该系统，如何实现依赖模块和自己编写的模块redis_run.py一起打包，实现一键安装呢？</p>

<p>在这种应用场景下，pip工具似乎派不上了用场，只能使用python的构建工具setup.py了，使用此构建工具可以实现上述应用场景需求，只需在 setup.py 文件中写明依赖的库和版本，然后到目标机器上使用<code class="language-plaintext highlighter-rouge">python setup.py install</code>安装。</p>

<p>setup.py的一些参数说明</p>

<div class="language-python highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></td><td class="code"><pre><span class="o">--</span><span class="n">name</span> <span class="err">包名称</span>
<span class="o">--</span><span class="n">version</span> <span class="p">(</span><span class="o">-</span><span class="n">V</span><span class="p">)</span> <span class="err">包版本</span>
<span class="o">--</span><span class="n">author</span> <span class="err">程序的作者</span>
<span class="o">--</span><span class="n">author_email</span> <span class="err">程序的作者的邮箱地址</span>
<span class="o">--</span><span class="n">maintainer</span> <span class="err">维护者</span>
<span class="o">--</span><span class="n">maintainer_email</span> <span class="err">维护者的邮箱地址</span>
<span class="o">--</span><span class="n">url</span> <span class="err">程序的官网地址</span>
<span class="o">--</span><span class="n">license</span> <span class="err">程序的授权信息</span>
<span class="o">--</span><span class="n">description</span> <span class="err">程序的简单描述</span>
<span class="o">--</span><span class="n">long_description</span> <span class="err">程序的详细描述</span>
<span class="o">--</span><span class="n">platforms</span> <span class="err">程序适用的软件平台列表</span>
<span class="o">--</span><span class="n">classifiers</span> <span class="err">程序的所属分类列表</span>
<span class="o">--</span><span class="n">keywords</span> <span class="err">程序的关键字列表</span>
<span class="o">--</span><span class="n">packages</span> <span class="err">需要处理的包目录（包含</span><span class="n">__init__</span><span class="o">.</span><span class="n">py</span><span class="err">的文件夹）</span> 
<span class="o">--</span><span class="n">py_modules</span> <span class="err">需要打包的</span><span class="n">python</span><span class="err">文件列表</span>
<span class="o">--</span><span class="n">download_url</span> <span class="err">程序的下载地址</span>
<span class="o">--</span><span class="n">cmdclass</span> 
<span class="o">--</span><span class="n">data_files</span> <span class="err">打包时需要打包的数据文件，如图片，配置文件等</span>
<span class="o">--</span><span class="n">scripts</span> <span class="err">安装时需要执行的脚步列表</span>
<span class="o">--</span><span class="n">package_dir</span> <span class="err">告诉</span><span class="n">setuptools</span><span class="err">哪些目录下的文件被映射到哪个源码包。一个例子：</span><span class="n">package_dir</span> <span class="o">=</span> <span class="p">{</span><span class="s">''</span><span class="p">:</span> <span class="s">'lib'</span><span class="p">}</span><span class="err">，表示“</span><span class="n">root</span> <span class="n">package</span><span class="err">”中的模块都在</span><span class="n">lib</span> <span class="err">目录中。</span>
<span class="o">--</span><span class="n">requires</span> <span class="err">定义依赖哪些模块</span> 
<span class="o">--</span><span class="n">provides</span><span class="err">定义可以为哪些模块提供依赖</span> 
<span class="o">--</span><span class="n">find_packages</span><span class="p">()</span> <span class="err">对于简单工程来说，手动增加</span><span class="n">packages</span><span class="err">参数很容易，刚刚我们用到了这个函数，它默认在和</span><span class="n">setup</span><span class="o">.</span><span class="n">py</span><span class="err">同一目录下搜索各个含有</span> <span class="n">__init__</span><span class="o">.</span><span class="n">py</span><span class="err">的包。</span>

                          <span class="err">其实我们可以将包统一放在一个</span><span class="n">src</span><span class="err">目录中，另外，这个包内可能还有</span><span class="n">aaa</span><span class="o">.</span><span class="n">txt</span><span class="err">文件和</span><span class="n">data</span><span class="err">数据文件夹。另外，也可以排除一些特定的包</span>

                          <span class="n">find_packages</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="s">"*.tests"</span><span class="p">,</span> <span class="s">"*.tests.*"</span><span class="p">,</span> <span class="s">"tests.*"</span><span class="p">,</span> <span class="s">"tests"</span><span class="p">])</span>

<span class="o">--</span><span class="n">install_requires</span> <span class="o">=</span> <span class="p">[</span><span class="s">"requests"</span><span class="p">]</span> <span class="err">需要安装的依赖包</span>
<span class="o">--</span><span class="n">entry_points</span> <span class="err">动态发现服务和插件，下面详细讲</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>setup.py的一个例子</p>

<div class="language-python highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></td><td class="code"><pre><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">find_packages</span>
       <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'README.rst'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
           <span class="n">LONG_DESC</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
       <span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'MyProject'</span><span class="p">,</span>
             <span class="n">version</span><span class="o">=</span><span class="s">'1.0.0'</span><span class="p">,</span>
             <span class="n">url</span><span class="o">=</span><span class="s">'http://example.com'</span><span class="p">,</span>
             <span class="n">description</span><span class="o">=</span><span class="s">'This is a cool microservice based on strava.'</span><span class="p">,</span>
             <span class="n">long_description</span><span class="o">=</span><span class="n">LONG_DESC</span><span class="p">,</span>
             <span class="n">author</span><span class="o">=</span><span class="s">'Tarek'</span><span class="p">,</span> <span class="n">author_email</span><span class="o">=</span><span class="s">'tarek@ziade.org'</span><span class="p">,</span>
             <span class="n">license</span><span class="o">=</span><span class="s">'MIT'</span><span class="p">,</span>
             <span class="n">classifiers</span><span class="o">=</span><span class="p">[</span>
                <span class="s">'Development Status :: 3 - Alpha'</span><span class="p">,</span>
                <span class="s">'License :: OSI Approved :: MIT License'</span><span class="p">,</span>
                <span class="s">'Programming Language :: Python :: 2'</span><span class="p">,</span>
                <span class="s">'Programming Language :: Python :: 3'</span><span class="p">],</span>
             <span class="n">keywords</span><span class="o">=</span><span class="p">[</span><span class="s">'flask'</span><span class="p">,</span> <span class="s">'microservice'</span><span class="p">,</span> <span class="s">'strava'</span><span class="p">],</span>
             <span class="n">packages</span><span class="o">=</span><span class="n">find_packages</span><span class="p">(),</span>
             <span class="n">include_package_data</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
             <span class="n">zip_safe</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">entry_points</span><span class="o">=</span><span class="s">"""
             [console_scripts]
             mycli = mypackage.mymodule:myfunc
             """</span><span class="p">,</span>
             <span class="n">install_requires</span><span class="o">=</span><span class="p">[</span><span class="s">'stravalib'</span><span class="p">])</span>
<span class="p">)</span>
</pre></td></tr></tbody></table>
</div>
</div>

<p>这里的install_requires 部分可以留空，用requirements.txt 来管理依赖包。</p>

<h5 id="requirementstxt-文件">requirements.txt 文件</h5>

<ul>
  <li>
    <p>依赖包列表文件， 可以使用 pip install -r thefile.txt 来调用并安装依赖列表。 本地环境下一般需要先进入虚拟环境下之后再执行这个命令。</p>
  </li>
  <li>开发环境和生产环境可以有不同的依赖列表。dev-requirements.txt, prod-requirements.txt</li>
  <li>pip-tools 是一个扩展包 <code class="language-plaintext highlighter-rouge">pip install pip-tools</code> 之后可以查看当前环境下安装了的所有依赖包和相应版本。<code class="language-plaintext highlighter-rouge">pip-compile</code></li>
  <li><code class="language-plaintext highlighter-rouge">pip freeze</code> 也是一个获取当前环境已经安装过的依赖包的命令</li>
</ul>

<h5 id="manifestin-文件">MANIFEST.in 文件</h5>

<p>这个文件包含了你想要打包的文件目录和列表</p>

<p>示例文件</p>

<div class="language-python highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="n">include</span> <span class="n">requirements</span><span class="o">.</span><span class="n">txt</span>
<span class="n">include</span> <span class="n">README</span><span class="o">.</span><span class="n">rst</span>
<span class="n">include</span> <span class="n">LICENSE</span>
<span class="n">recursive</span><span class="o">-</span><span class="n">include</span> <span class="n">myservice</span> <span class="o">*.</span><span class="n">ini</span>
<span class="n">recursive</span><span class="o">-</span><span class="n">include</span> <span class="n">docs</span> <span class="o">*.</span><span class="n">rst</span> <span class="o">*.</span><span class="n">png</span> <span class="o">*.</span><span class="n">svg</span> <span class="o">*.</span><span class="n">css</span> <span class="o">*.</span><span class="n">html</span> <span class="n">conf</span><span class="o">.</span><span class="n">py</span>
<span class="n">prune</span> <span class="n">docs</span><span class="o">/</span><span class="n">build</span><span class="o">/*</span>
</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>prune 是不包含自动生成的文档目录。</li>
  <li><code class="language-plaintext highlighter-rouge">check-manifest</code> 命令可以检查MANIFEST.in 文件是否语法正确和包含后的效果。</li>
</ul>

<p>一个典型的微服务项目包含的文件目录如下</p>

<ul>
  <li>setup.py: The setup file</li>
  <li>README.rst: The content of the long_description option</li>
  <li>MANIFEST.in: The MANIFEST template</li>
  <li>requirements.txt: PIP requirement files generated from install_requires</li>
  <li>docs/: The Sphinx documentation</li>
  <li>package/: The package containing the microservice code</li>
</ul>

<h4 id="版本管理-1">版本管理</h4>

<p>版本号写在setup.py 中</p>

<p>Python 打包工具并不强制需要一个版本号， 且版本号的命名规范也没有要求， 这就需要我们自己制定一个命名规范。</p>

<p>我们可以借鉴pip 管理依赖包中的做法， 用两个点分割三个数字。</p>

<p><code class="language-plaintext highlighter-rouge">Major.Minor.Patch</code></p>

<ul>
  <li>
    <p>Major: 自增数字，当新的一个向后不兼容的大功能产生， 就会增加1</p>
  </li>
  <li>
    <p>Minor: 自增数字， 对当前版本没有大影响（向后兼容）的小功能</p>
  </li>
  <li>
    <p>Patch: 自增数字， bug修复</p>
  </li>
</ul>

<p>还没有第一个release 之前的版本的名字往往是0.1.0， 第一个release 的版本往往是1.0.0</p>

<h4 id="打包命令">打包命令</h4>

<ul>
  <li>sdist 是打包发布命令
    <ul>
      <li><code class="language-plaintext highlighter-rouge">python setup.py sdist</code> 命令需要在项目根目录下执行。执行后会产生一个包含了项目文件的归档包。</li>
      <li>sdist 读取了setup.py 和 MANIFEST.in， 然后获取到所有相应的文件并放到存档包中。生成的包放在 dist/目录下。文件名是由MANIFEST.in中的项目名加上版本号组成。</li>
      <li>生成的存档包可以直接被pip命令进行安装 <code class="language-plaintext highlighter-rouge">pip install dist/runnerly-tokendaler-0.1.0.tar.gz</code></li>
    </ul>
  </li>
  <li>wheel 是另一种打包发布命令, 安装包的速度会更快些。
    <ul>
      <li>需要先 <code class="language-plaintext highlighter-rouge">pip install wheel</code>  安装 wheel, 然后 <code class="language-plaintext highlighter-rouge">python setup.py bidst_wheel universal</code> 将项目目录下的内容进行打包</li>
    </ul>
  </li>
</ul>

<h3 id="distributing-部署">Distributing 部署</h3>

<p>如果我们想开源我们的项目， 就可以考虑将我们的项目发布到 pypi上， 让大家下载。</p>

<ul>
  <li>
    <p>项目的名字要和已有的pypi项目不重名</p>
  </li>
  <li>
    <p>需要去pypi注册一个账号， 然后在项目的根目录下创建一个 .pypirc的文件并包含如下内容</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="p">[</span><span class="n">pypi</span><span class="p">]</span>
<span class="n">username</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">username</span><span class="o">&gt;</span>
<span class="n">password</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">password</span><span class="o">&gt;</span>

</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>然后用twine （<code class="language-plaintext highlighter-rouge">pip install twine</code>）命令将包发布到pypi上面</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>twine register dist/runnerly-tokendealer-0.1.0.tar.gz
twine upload dist/<span class="k">*</span>
</pre></td></tr></tbody></table>
</div>
</div>

<ul>
  <li>现在就可以在pypi 索引中找到我们的项目了</li>
</ul>

<h3 id="运行所有的微服务">运行所有的微服务</h3>

<p>如果是在本地运行一个微服务， 那么用flask自带的命令 <code class="language-plaintext highlighter-rouge">python xxx.py runserver</code> 就可以了</p>

<p>另一种方法是创建自己的启动服务的命令行脚本 - 使用 argparse 模块。</p>

<h4 id="argparse-模块创建自己的启动服务的命令行">argparse 模块创建自己的启动服务的命令行</h4>

<p><a href="https://docs.python.org/3/library/argparse.html">官方说明</a></p>

<ol>
  <li>创建启动脚本</li>
  <li>在setup.py中声名脚本</li>
  <li>命令行运行自定义的命令的名字（比如runnerly-dataservice） 就可以了</li>
</ol>

<h3 id="多进程管理">多进程管理</h3>

<h4 id="安装-uwsgi">安装 uWSGI</h4>

<p>说明: uWSGI 是实现了WSGI协议的应用程序， 好处是可以同时运行多个flask 进程， 方便在开发测试阶段对多个微服务统一管理。</p>

<p>安装运行后就不需要在用  <code class="language-plaintext highlighter-rouge">python3.6 test.py -r -d -h0.0.0.0</code> 来启动服务了, 而是 <code class="language-plaintext highlighter-rouge">uwsgi --http 10.11.56.210:5000 --wsgi-file</code></p>

<p>具体安装和使用方法请看 Flask 的笔记</p>

<p>uWSGI缺点是只能用来启动web服务。</p>

<h4 id="安装circus">安装Circus</h4>

<p>Circus的好处是可以运行任何类型的进程， 比如多个微服务的WEB进程和Redis, Mongo进程。</p>

<p>Circus配置文件中要配置如下内容， 要跑5个web进程和1个redis进程</p>

<p>myconfig.ini</p>

<pre><code class="language-ba&#39;sh">[watcher:web]
cmd = chaussette --fd $(circus.sockets.web) server.application
use_sockets = True
numprocesses = 5
[watcher:redis]
cmd = /usr/local/bin/redis-server  
use_sockets = False
numprocesses = 1
[socket:web]
host = 0.0.0.0
port = 8000
</code></pre>

<p>运行命令</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>circusd myconfig.ini
</pre></td></tr></tbody></table>
</div>
</div>

<h2 id="容器---将微服务放在容器中">容器 - 将微服务放在容器中</h2>

<p>如果想快速的部署环境，可以考虑使用容器。</p>

<p>VMWare, Virtual-Box 还可以， 但是虚拟机更占内存， 而且往往不是开源的，所以作为demo环境还可以，但是用于生产就不是很好了。</p>

<p>Docker是一个理想的方案， 他是一个开源的虚拟工具， 他最大的好处是可以在生产环境运行，速度就像本地一样快。</p>

<h3 id="什么是docker">什么是Docker</h3>

<ul>
  <li>Docker是一个容器平台， 让我们可以在一个隔绝的环境运行我们的应用。</li>
  <li>我们要做的就是将镜像告诉Docker, Docker就会帮我们做所有的脏活了。</li>
  <li>image 就是一个能够让Docker运行起来的，基于linux kernal 的所有进城资源。比如Ubuntu 的 image</li>
</ul>

<p>去官网下载Docker for mac, 并安装</p>

<ul>
  <li>
    <p>Docker 有一个服务端和客户端， 之间用 socket 进行通信。</p>
  </li>
  <li>
    <p>docker 客户端可以连接其他服务器上的docker 服务端</p>
  </li>
  <li>
    <div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>docker version
</pre></td></tr></tbody></table>
</div>
    </div>
  </li>
</ul>

<h3 id="docker-101">Docker 101</h3>

<p>Docker Hub (https://hub.docker.com)  有很多已有的Docker 镜像可以提供下载。</p>

<p>一些Python环境的镜像可以直接使用， Alpine Linux (refer to http://gliderlabs.viewdocs.io/docker-alpine/) 是最小的python运行环境</p>

<h3 id="为docker安装全套环境---openresty-circus-and-flask">为Docker安装全套环境 - OpenResty, Circus and Flask</h3>

<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fv36em3o8xj30c906ewf4.jpg" alt="" /></p>

<h3 id="部署docker">部署Docker</h3>

<p>把微服务部署在Docker中后， 我们还需要让Docker之间相互通信。</p>

<ul>
  <li>假设两个Docker, 一个叫 host a , 一个叫host b.</li>
  <li>只要两个docker 都有公共地址， 并且都暴露出了本地的sockets， 就可以桥接。</li>
  <li>还可以创建 docker 的专属虚拟网络 Virtual Network.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>docker network create -driver<span class="o">=</span>bridge runnerly
docker run --rm --net<span class="o">=</span>runnerly --name<span class="o">=</span>tokendealer -v /tmp/logs:/logs -p5555:8080 -it runnerly/tokendealer
</pre></td></tr></tbody></table>
</div>
</div>

<h4 id="docker-compose">Docker Compose</h4>

<p>Docker Compose (https://docs.docker.com/compose/) 可以在一个配置文件中定义多个docker的配置。</p>

<h4 id="docker-的clustering-and-provisioning服务发现">Docker 的clustering and Provisioning（服务发现）</h4>

<ul>
  <li>可以将同一个 image 启动多个实例， 我们管这个叫做 clustering.</li>
  <li>多个同样的docker 实例可以用负载均衡来实现请求的分配策略。Nginx可以做这个事情。</li>
  <li>如果想要让微服务有高可用， 并可以自动的上线或者下线， 需要有<strong>服务发现</strong>功能，它自动的让负载均衡识别到新的容器， 或者自动下线出故障不可用的容器。</li>
  <li><strong>Consul</strong> (https://www.consul.io/) or <strong>Etcd</strong> (https://coreos.com/etcd/) and Docker’s <strong>swarm</strong> mode 可以用来进行服务的配置工作</li>
  <li>部署微服务需要好多步骤:
    <ol>
      <li>Read a configuration file that describes the instances needed via a few Docker Compose files.</li>
      <li>Start a few VMs on the cloud provider.</li>
      <li>Wait for all VMs to be up and running.</li>
      <li>Make sure everything needed to run services on the VM is set.</li>
      <li>Interact with the Docker daemon on each VM to start some containers.</li>
      <li>Ping whatever service needs to be pinged to make sure the new instances are all interlinked.</li>
    </ol>
  </li>
  <li><strong>Ansible</strong> (https://www.ansible.com/) or <strong>Salt</strong> (https://docs.saltstack.com) 也可以用来进行服务的自动化部署和配置工作</li>
  <li><strong>Kubernetes</strong> (https://kubernetes.io/)  是另一个部署分布式容器的工具. 和Ansible 和 Salt不同的是, Kubernets 只针对容器提供全面的解决方案. 让容器可以部署在任何地方, 包括主流的云服务AWS, Digital Ocean, Openstack等.</li>
</ul>

<h2 id="在-aws-上部署微服务">在 AWS 上部署微服务</h2>

<p>在AWS上部署微服务的好处:</p>

<ul>
  <li>便宜</li>
  <li>稳定</li>
  <li>安全</li>
  <li>有很多现成的服务可以使用</li>
</ul>

<p>AWS有很多很多服务, 但是主要用于微服务的服务可分为4类</p>

<ol>
  <li>路由型: 这类服务会将请求重定向(跳转)到正确的地方, 比如DNS服务和负载均衡服务一样.</li>
  <li>执行型: 执行你的代码的服务, 比如EC2 和 Lambda</li>
  <li>存储型: 存储数据的服务, 比如 缓存, 传统数据库, 长期数据存储, CDN等</li>
  <li>消息型: 处理消息的服务, 比如发送推送, 邮件等</li>
</ol>

<p>下图是一个分类示意图:</p>

<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fv3n6dp09kj309709575w.jpg" alt="" /></p>

<h3 id="routing---route53-elb-autoscaling">Routing - Route53, ELB, AutoScaling</h3>

<p>路由: <strong>Route53</strong> (https://aws.amazon.com/route53/) 是亚马逊的DNS服务.  我们可以在Route53中定义DNS的入口,  自动将请求路由到指定的AWS上我们的应用或者文件上.</p>

<p>负载均衡: Route53可以无缝的和<strong>ELB</strong>进行协作. Elastic Load Balancing (<strong>ELB</strong>)(https://aws.amazon.com/elasticloadbalancing/) 是负载均衡服务.  如果一个微服务有多个vms, 那么就可以用ELB. ELB 还可以进行健康检查, 发现问题就可以自动发邮件</p>

<p>服务自动启停: <strong>AutoScaling</strong> (https://aws.amazon.com/autoscaling/) 可以通过一些事件触发, 自动添加实例. 当ELB 的健康检查发现了一个实例没有响应了, 就可以通知AutoScaling 将他下线, 并启动一个新的备用实例代替原来的那个.</p>

<h3 id="execution---ec2-and-lambda">Execution - EC2 and Lambda</h3>

<p>EC2 (https://aws.amazon.com/ec2/) 可以让我们创建虚拟机, 是AWS的核心计算单元.</p>

<p>EC2 Container Service (ECS) (https://aws.amazon.com/ecs) 是一个专门管理Docker 部署的EC2, 和 Kubernets 的功能类似.</p>

<p>Lambda 是一个分布式定时任务管理器</p>

<h3 id="storage---ebs-s3-rds-elasticcache-and-cloudfront">Storage - EBS, S3, RDS, ElasticCache, and CloudFront</h3>

<p>Simple Storage Service (S3) (https://aws.amazon.com/s3/)  是存储服务, 将数据存储到 bucket中. Bucket 是key-value 存储, value 就是我们要存的文件数据. Python中使用S3很方便, 所以使用 S3作为微服务的数据存储是很理想的.</p>

<p>ElasticCache (https://aws.amazon.com/elasticache/)  是一个缓存服务. 它是利用 Redis 和 Memcached 作为后端的支撑.</p>

<p>Relational Database Service (RDS) (https://aws.amazon.com/rds/)  是关系型数据库服务, 背后是Mysql, PostgreSQL 支撑.</p>

<p>CloudFront (https://aws.amazon.com/cloudfront/) 是 Amazon’s Content Delivery Network (CDN). 被频繁访问的静态文件可以放在CDN中, 但是少量的,就直接放在微服务中即可.</p>

<h3 id="messaging---ses-sqs-and-sns">Messaging - SES, SQS, and SNS</h3>

<p>AWS 提供的三种主要消息服务</p>

<ul>
  <li>Simple Email Service (SES): 邮件服务</li>
  <li>Simple Queue Service (SQS): 消息队列服务, 类似于 RabbitMQ</li>
  <li>Simple Notification Service (SNS): 消息推送系统</li>
</ul>

<p>Simple Email Service (SES): 邮件服务 Simple Email Service (SES) (https://aws.amazon.com/ses/ ) 发送邮件</p>

<p>SQS (https://aws.amazon.com/sqs/) 可以理解成是RabbitMQ的一个子集. 可以创建两种队列, 一种是先进先出型, 执行效果就等同于使用 Celery和Redis, 并发消息是2万. 另一种是标准型, 但是消息的顺序是不保障的, 并发消息限制是12万.</p>

<p>SNS (https://aws.amazon.com/sns/) 消息推送提供两种API, 第一种是发布/订阅型 pub/sub API, 发布者可以是某种AWS服务或者是我们的应用, 订阅者可以是SQS消息队列, Lambda, 或者是我们的某个微服务.  另一种是Push 推送API, 比如给手机发送短信.</p>

<h3 id="微服务的部署--实践">微服务的部署- 实践</h3>

<p>步骤:</p>

<ol>
  <li>
    <p>设置一个AWS账号,创建账号, 并设定最低消费提醒.</p>
  </li>
  <li>
    <p>创建一个EC2实例, 使用CoreOS的PV版本作为镜像, 过程中要设置一个keypair, 保存好. 并远程登录</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>ssh -i <span class="s2">"AmazonKeyPairDalong.pem"</span> core@ec2-52-206-71-113.compute-1.amazonaws.com
update_engine_client -update
sudo reboot
</pre></td></tr></tbody></table>
</div>
    </div>
  </li>
  <li>
    <p>并在CentOS中运行一个Docker命令(这时Docker已经在CoreOS上默认安装了)</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>ssh -i <span class="s2">"AmazonKeyPairDalong.pem"</span> core@ec2-52-206-71-113.compute-1.amazonaws.com
docker -v Docker version 17.05.0-ce, build 89658be
docker run busybox /bin/echo hello
   
</pre></td></tr></tbody></table>
</div>
    </div>
  </li>
  <li>
    <p>在Docker中配置Flask 的镜像  docker-flask</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>docker run -d -p 80:80 p0bailey/docker-flask
</pre></td></tr></tbody></table>
</div>
    </div>

    <p>AWS默认值开启22端口给SSH, 我们还要去EC2中的安全组中开启inbound 的 http的服务(80端口)</p>
  </li>
  <li>
    <p>再配置ECS的自动分布式. ECS负责自动部署Docker images.</p>

    <ul>
      <li>
        <p>ECS 部署需要包含一些因素</p>

        <ul>
          <li>一个ELB (Elastic Load Balancer)</li>
          <li>一个 Task Definition (任务定义), 它被用来决定那个Docker image 需要被部署, 那个端口可以用来给host 和 容器使用</li>
          <li>一个 Service, 使用任务定义去驱动EC2 的创建, 并运行EC2中的Docker</li>
          <li>一个 Cluster, 将 所有的服务, 任务定义, ELB 分组.</li>
        </ul>

        <p><img src="https://ws2.sinaimg.cn/large/0069RVTdgy1fv47i4iewfj30cv05wglx.jpg" alt="" /></p>
      </li>
      <li>
        <p>在AWS界面上点击 Deploy a sample application onto Amazon ECS Cluster , 按照指引完成上面内容的配置.</p>

        <p><img src="https://ws2.sinaimg.cn/large/0069RVTdgy1fv484yz4upj30dp0hvq4p.jpg" alt="" /></p>
      </li>
    </ul>
  </li>
  <li>
    <p>最后用Route53来在同一个域名下发布我们的众多微服务</p>

    <ul>
      <li>第5步完成后, 已经创建了load blancing.</li>
      <li>给LB创建一个别名:  https://console.aws.amazon.com/route53, 点击 hosted zones</li>
      <li>加入我们已经有一个域名了, 那么就可以在 AWS 的 DNS服务中点击 Create Hosted Zone 把自己的域名加进来.</li>
      <li>我们可以在域名这里看到之前创建好的LB , 这里要把域名连接到我们不熟的ECS cluster上, 并可以设定二级域名到不同的为服务上.</li>
    </ul>
  </li>
</ol>

<h2 id="在阿里云上部署微服务">在阿里云上部署微服务</h2>

<ol>
  <li>
    <p>创建账号</p>
  </li>
  <li>
    <p>创建ECS实例, 按量付费, 选择华东2的D区, 通用型. CentOS 镜像</p>

    <p>EC</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre><span class="c"># 设置成功后连接远程ECS服务器</span>
ssh root@101.132.164.124
   
<span class="c"># 安装Python3.6</span>
yum -y groupinstall <span class="s2">"Development tools"</span>
yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel
   
curl -O https://www.python.org/ftp/python/3.6.6/Python-3.6.6.tar.xz
   
tar -xvJf Python-3.6.6.tar.xz
   
<span class="nb">cd </span>Python-3.6.6
   
./configure --prefix<span class="o">=</span>/usr/local/python3
   
make <span class="o">&amp;&amp;</span> make install
</pre></td></tr></tbody></table>
</div>
    </div>
  </li>
</ol>

<h1 id="对微服务api服务网关的理解">对微服务API服务网关的理解</h1>

<h2 id="1-简介">1. 简介</h2>

<p>通过以下几个问题去理解微服务中的一个重要组件：API网关。</p>

<ol>
  <li>什么是API网关</li>
  <li>为什么需要API网关</li>
  <li>API网关在微服务架构体系中处于什么位置</li>
  <li>网关技术实现有哪些</li>
  <li>zuul网关工作原理是什么样的</li>
  <li>技术上如何选型</li>
</ol>

<h2 id="2-什么是api网关">2. 什么是API网关</h2>

<ul>
  <li>API网是一个反向路由：屏蔽内部细节，为调用者提供统一入口，接收所有调用者请求，通过路由机制转发到服务实例。</li>
  <li>API网关是一组“过滤器”集合：可以实现一系列与核心业务无关的横切面功能，如安全认证、限流熔断、日志监控。</li>
</ul>

<h2 id="3-为什么需要api网关">3. 为什么需要API网关</h2>

<p>　　什么是API网关中已给出理由，简单总结：</p>

<ul>
  <li>屏蔽内部细节</li>
  <li>反向路由</li>
  <li>安全认证</li>
  <li>限流熔断</li>
  <li>日志监控</li>
</ul>

<h2 id="4-api网关在微服务架构体系中处于什么位置">4. API网关在微服务架构体系中处于什么位置</h2>

<h3 id="41-调用者眼中的api网关">4.1 调用者眼中的API网关</h3>

<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwjn1qbngaj30pk0hs0sw.jpg" alt="" /></p>

<ul>
  <li>统一入口</li>
  <li>内部服务对于调用者是透明的</li>
</ul>

<h3 id="42-所处的位置">4.2 所处的位置</h3>

<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwjn2cx9ukj30up0i93z4.jpg" alt="" /></p>

<ul>
  <li>处于负载均衡与业务服务之间</li>
  <li>API网关也可实现负载均衡功能</li>
</ul>

<h2 id="5-网关技术实现有哪些">5. 网关技术实现有哪些</h2>

<p>简单列举，不做比较，有兴趣可查询资料，后续为基于zuul网关来理解工作流程原理</p>

<ul>
  <li><a href="https://github.com/Netflix/zuul">zuul</a>：是netflix开源的一个API Gateway 服务器, 本质上是一个web servlet应用。Spring Cloud已集成</li>
  <li><a href="https://getkong.org/">kong</a>：是一款基于Nginx_Lua模块写的高可用，易扩展由Mashape公司开源的API Gateway项目</li>
</ul>

<h2 id="6-zuul网关工作原理是什么样的">6. zuul网关工作原理是什么样的</h2>

<p>因为后续API网关组件会聚焦于zuul，这里对zuul工作原理提前学习。</p>

<h3 id="61-整体处理流程图">6.1 整体处理流程图</h3>

<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwjn48autlj30rz0ibglx.jpg" alt="" /></p>

<ol>
  <li>zuul本身是一个Servlet</li>
  <li>HttpServlet Request请求到达Zuul Servlet</li>
  <li>通过ZuulFilter Runner ，并且根据routing filter 类型执行filter 链</li>
  <li>根据FilterType类型不同，执行的顺序不同且可完成不同的功能
    <ol>
      <li>pre：在请求被路由之前调用，可实现日志监控、身份认证、黑名单等功能</li>
      <li>route：在路由请求时候被调用</li>
      <li>post：在route和error过滤器之后被调用，可实现审计、统计等功能</li>
      <li>error：处理请求时发生错误时被调用、可实现统一异常处理等功能</li>
    </ol>
  </li>
  <li>Request Context：在请求生命周期中共享变量</li>
  <li>Filter的实现是可插拔的
    <ol>
      <li>脚本实现Filter</li>
      <li>发布到filter目录中</li>
      <li>由filter manager与filter loader自动加载</li>
    </ol>
  </li>
</ol>

<h3 id="62-请求生命周期">6.2 请求生命周期</h3>

<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwjn6zbk1gj30pm0dbaa3.jpg" alt="" /></p>

<ol>
  <li>拦截请求</li>
  <li>根据filter类型，执行已加载的filter chain</li>
  <li>返回请求</li>
</ol>

<h2 id="7-技术上如何选型">7. 技术上如何选型</h2>

<ul>
  <li>若使用的微服务框架是Spring Cloud，可选择Netflix的zuul，已经很好的集成到SC中</li>
  <li>kong ，当然，能力强的可以自定义实现满足自己需求的API网关</li>
</ul>

<h1 id="对微服务路由发现体系的理解">对微服务路由发现体系的理解</h1>

<h2 id="简介">简介</h2>

<blockquote>
  <p>路由发现是微服务体系中一块重要组成，从以下几个方面理解微服务路由：</p>
</blockquote>

<ol>
  <li>什么是路由</li>
  <li>为什么需要路由</li>
  <li>从路由的角度看微服务的体系架构是什么样的</li>
  <li>路由、服务发现、负载均衡有什么关系</li>
  <li>补充：负载均衡算法有哪些</li>
</ol>

<h2 id="1什么是微服务路由">1.什么是微服务路由</h2>

<blockquote>
  <p>直白理解：“路由”是指根据请求URL，将请求分配到对应的处理程序。</p>
</blockquote>

<p>　　如SpringMVC的DispatchServlet，统一接收所有需要SpringMVC处理的请求，再根据指定饿匹配规则，将请求映射到最终的Controller中的某个方法。这里不再扩展，有兴趣的可以直接查看相关资料。</p>

<h2 id="2微服务为什么需要路由">2.微服务为什么需要路由</h2>

<blockquote>
  <p>微服务需要一套完善的请求分发机制来保证一个请求到来能正确的找到对应的服务实例</p>
</blockquote>

<p>　　微服务一般是由几十、上百个服务组成，无论是外部调用GW，或者内部服务之间的调用，对于一个URL请求，最终会确认一个服务实例进行处理。对每个服务实例手动指定一个唯一访问地址，然后根据URL去手动实现请求匹配是不可取的，尤其是基于云环境的微服务体系。 
　　反向路由是微服务的网关的功能之一，可以为我们处理每个请求到服务实例的绑定，结合网关特点，可以做许多额外的横切面的工作，让更多的精力聚焦于业务。对于为什么需要API网关，请查看《五：对微服务API服务网关的理解》</p>

<h2 id="3从路由的角度看微服务的体系架构是什么样的">3.从路由的角度看微服务的体系架构是什么样的</h2>

<blockquote>
  <p>理解阶段，只能先了解整体流程，后续实际代码阶段以及原理、源码分析阶段会深入了解。</p>
</blockquote>

<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwjdddb4pzj30tq0ifdgj.jpg" alt="" /></p>

<h3 id="31-内部服务如何调用">3.1 内部服务如何调用</h3>

<ul>
  <li>基础服务之间的调用：结合服务注册中心以及专属的具有负载均衡功能的客户端，如Eureka+（restTemplate+Ribbon）或者Eureka+Feign</li>
  <li>聚合服务调用：结合服务注册中心以及专属的具有负载均衡功能的客户端，如Eureka+（restTemplate+Ribbon）或者Eureka+Feign</li>
</ul>

<h3 id="32-外部路由如何实现">3.2 外部路由如何实现</h3>

<p>　　基于Netflix的zuul，做了简单了解，SpringCloud与zuul集成的方式。这里先对核心流程做个简单了解，后续会有深入的应用、分析。 
　　</p>

<ul>
  <li>Spring Cloud很好的集成了zuul，并且可以通过注解的形式来进行请求的反向路由以及API网关功能</li>
  <li>Spring Cloud集成zuul，对与url映射的处理方式与SpringMVC对url的请求方式类似，都是通过RequestMapping来进行请求绑定的。核心类：ZuulHandlerMapping</li>
  <li>zuul的核心是ZuulServlet，一个请求核心流程：HttpServletRequest –&gt;ZuulHandlerMapping –&gt;ZuulController –&gt; ZuulServlet –&gt; ZuulFilter –&gt; HttpServletResponse，详细流程请查看《五：对微服务API服务网关的理解》</li>
</ul>

<h2 id="4路由api网关服务发现负载均衡有什么关系">4.路由、API网关、服务发现、负载均衡有什么关系</h2>

<p>4.1 关系</p>

<blockquote>
  <p>都是组成微服务的不可或缺的一部分</p>
</blockquote>

<ul>
  <li>路由是API网关的一个功能点</li>
  <li>API网关需要定期或实时同步服务注册中心的服务列表，服务发现是将服务实例与服务注册中心进行实时关联</li>
  <li>微服务架构中的负载均衡一般采用进程内负载均衡或者独立主机负载均衡形式，要求客户端同样需要定时或实时同步服务注册中心维护的服务列表</li>
</ul>

<p>4.2 从服务发现工作流程理解一次请求过程</p>

<blockquote>
  <p>请求到来之前肯定需要服务提供者正常工作</p>
</blockquote>

<ul>
  <li>服务提供者启动时，将提供的服务名称、服务器地址注册到服务配置中心</li>
  <li>服务消费者通过服务配置中心来获取需要调度的服务机器列表</li>
  <li>一次请求到来，经过路由分发定位到一组服务，再通过负载均衡算法之后，选取一台服务器调用</li>
  <li>当服务器宕机或下线，相应的机器动态从服务配置中心移除，并通知相应的服务消费者</li>
  <li>服务消费者一次访问服务配置中心之后，会将查询到的信息缓存到本地，后面调用先查缓存，从而降低服务配置中心压力</li>
</ul>

<h2 id="5补充负载均衡算法有哪些">5.补充：负载均衡算法有哪些</h2>

<ul>
  <li>轮询法：将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</li>
  <li>随机法：通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</li>
  <li>加权轮询法：不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</li>
  <li>最小连接法：最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</li>
  <li>源地址哈希法：源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</li>
</ul>

            </div>

            <!-- Rating -->
            
            <div class="rating mb-4 d-flex align-items-center">
                <strong class="mr-1">Rating:</strong> <div class="rating-holder">
<div class="c-rating c-rating--regular" data-rating-value="4.5">
  <button>1</button>
  <button>2</button>
  <button>3</button>
  <button>4</button>
  <button>5</button>
</div>
</div>
            </div>
            

            <!-- Post Date -->
            <p>
            <small>
                <span class="post-date"><time class="post-date" datetime="2021-03-14">14 Mar 2021</time></span>           
                
                </small>
            </p>

            <!-- Post Categories -->
            <div class="after-post-cats">
                <ul class="tags mb-4">
                    
                    
                    <li>
                        <a class="smoothscroll" href="/categories#Container">Container</a>
                    </li>
                    
                    <li>
                        <a class="smoothscroll" href="/categories#Docker">Docker</a>
                    </li>
                    
                    <li>
                        <a class="smoothscroll" href="/categories#Microservice">Microservice</a>
                    </li>
                    
                    <li>
                        <a class="smoothscroll" href="/categories#Python">Python</a>
                    </li>
                    
                    <li>
                        <a class="smoothscroll" href="/categories#Rest-API">Rest API</a>
                    </li>
                    
                </ul>
            </div>
            <!-- End Categories -->

            <!-- Post Tags -->
            <div class="after-post-tags">
                <ul class="tags">
                    
                    
                </ul>
            </div>
            <!-- End Tags -->

            <!-- Prev/Next -->
            <div class="row PageNavigation d-flex justify-content-between font-weight-bold">
            
            <a class="prev d-block col-md-6" href="//Tensorflow-with-Python/"> &laquo; Tensorflow with Python</a>
            
            
            <a class="next d-block col-md-6 text-lg-right" href="//Docker-and-Kubernetes/">Building Microservice Systems with Docker and Kubernetes &raquo; </a>
            
            <div class="clearfix"></div>
            </div>
            <!-- End Categories -->

        </div>
        <!-- End Post -->

    </div>
</div>
<!-- End Article
================================================== -->

<!-- Begin Comments
================================================== -->

    <div class="container">
        <div id="comments" class="row justify-content-center mb-5">
            <div class="col-md-8">
                <section class="disqus">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'demowebsite'; 
        var disqus_developer = 0;
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = window.location.protocol + '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>

            </div>
        </div>
    </div>

<!--End Comments
================================================== -->

<!-- Review with LD-JSON, adapt it for your needs if you like, but make sure you test the generated HTML source code first: 
https://search.google.com/structured-data/testing-tool/u/0/
================================================== -->

<script type="application/ld+json">
{
  "@context": "http://schema.org/",
  "@type": "Review",
  "itemReviewed": {
    "@type": "Thing",
    "name": "Design Microservices with Python"
  },
  "author": {
    "@type": "Person",
    "name": "Dalong"
  },
  "datePublished": "2021-03-14",
  "reviewRating": {
    "@type": "Rating",
    "ratingValue": "4.5",
    "bestRating": "5"
  }
}
</script>

</div>


    
</div>

<!-- Categories Jumbotron
================================================== -->
<div class="jumbotron fortags">
	<div class="d-md-flex h-100">
		<div class="col-md-4 transpdark align-self-center text-center h-100">
            <div class="d-md-flex align-items-center justify-content-center h-100">
                <h2 class="d-md-block align-self-center py-1 font-weight-light">Explore <span class="d-none d-md-inline">→</span></h2>
            </div>
		</div>
		<div class="col-md-8 p-5 align-self-center text-center">
            
            
                
                    <a class="mt-1 mb-1" href="/categories#Linux">Linux (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Python">Python (16)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Mysql">Mysql (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Redis">Redis (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#MongoDB">MongoDB (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Flask">Flask (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Django">Django (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#DjangoRest">DjangoRest (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Web-development">Web development (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Numpy">Numpy (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Panda">Panda (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Sklearn">Sklearn (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Jupyter">Jupyter (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#OpenCV">OpenCV (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#AI">AI (4)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Data-Science">Data Science (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Tensorflow">Tensorflow (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#ML">ML (3)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Microservice">Microservice (4)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Docker">Docker (4)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Rest-API">Rest API (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Container">Container (3)</a>
                
                    <a class="mt-1 mb-1" href="/categories#NLP">NLP (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#AWS">AWS (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Architecture">Architecture (3)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Database">Database (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Storage">Storage (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#DevOps">DevOps (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#IAM">IAM (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Cloud">Cloud (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#API">API (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Data-Migration">Data Migration (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Network">Network (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#YAML">YAML (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Security">Security (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#kubernetes">kubernetes (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Serverless">Serverless (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#CICD">CICD (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Agile">Agile (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Scrum">Scrum (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Design-Thinking">Design Thinking (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#GCP">GCP (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Google-Cloud-Platform">Google Cloud Platform (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#MLPS">MLPS (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#PIPL">PIPL (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#PII">PII (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#GDPR">GDPR (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Metaverse">Metaverse (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#VR">VR (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#AR">AR (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#XR">XR (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Togaf">Togaf (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Architecture-Thinking">Architecture Thinking (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#ChatGPT">ChatGPT (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#OpenAI">OpenAI (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#LLM">LLM (2)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Prompt">Prompt (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#DALL-E">DALL-E (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Azure">Azure (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#OCR">OCR (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Face-API">Face API (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Chat-Bot">Chat Bot (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Speech-Service">Speech Service (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Computer-Vision">Computer Vision (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Custom-Vision">Custom Vision (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Video-indexer">Video indexer (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Translator">Translator (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Cognitive-Search">Cognitive Search (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Knowledge-Base">Knowledge Base (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#ITIL">ITIL (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#IT">IT (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Jekyll">Jekyll (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Github">Github (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Liquid">Liquid (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Markdown">Markdown (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Node.js">Node.js (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Yarn">Yarn (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Nest.JS">Nest.JS (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Typescript">Typescript (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#javascript">javascript (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Restful-API">Restful API (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Postman">Postman (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#Postgresql">Postgresql (1)</a>
                
                    <a class="mt-1 mb-1" href="/categories#TypeORM">TypeORM (1)</a>
                
            
            
		</div>
	</div>
</div>

<!-- Begin Footer
================================================== -->
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                Copyright © 2023 Dalong's personal blog 
            </div>
            <div class="col-md-6 col-sm-6 text-center text-lg-right">    
                <a target="_blank" href="#">Designed</a> by Dalong.work
            </div>
        </div>
    </div>
</footer>
<!-- End Footer
================================================== -->

</div> <!-- /.site-content -->

<!-- Scripts
================================================== -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>

<script src="/assets/js/mediumish.js"></script>



<script src="/assets/js/ie10-viewport-bug-workaround.js"></script> 


<script id="dsq-count-scr" src="//demowebsite.disqus.com/count.js"></script>


</body>
</html>
